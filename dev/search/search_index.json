{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Index","text":""},{"location":"#bioimageiocore","title":"bioimageio.core","text":"<p><code>bioimageio.core</code> is a python package that implements prediction with bioimage.io models including standardized pre- and postprocessing operations. Such models are represented as bioimageio.spec resource descriptions.</p> <p>In addition bioimageio.core provides functionality to convert model weight formats and compute selected dataset statistics used for preprocessing.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Here you find the bioimageio.core documentation.</p>"},{"location":"#examples","title":"Examples","text":"<p>Notebooks that save and load resource descriptions and validate their format (using bioimageio.spec, a dependency of bioimageio.core)</p> <ul> <li>load_model_and_create_your_own.ipynb </li> <li>dataset_creation.ipynb </li> </ul> <p>Use the described resources in Python with bioimageio.core</p> <ul> <li>model_usage.ipynb </li> </ul>"},{"location":"#presentations","title":"Presentations","text":"<ul> <li>Create a model from scratch (source)</li> </ul>"},{"location":"#set-up-development-environment","title":"Set up Development Environment","text":"<p>To set up a development environment run the following commands:</p> <pre><code>conda create -n core python=$(grep -E '^requires-python' pyproject.toml | grep -oE '[0-9]+\\.[0-9]+')\nconda activate core\npip install -e .[dev,partners]\n</code></pre>"},{"location":"#joint-development-of-bioimageiospec-and-bioimageiocore","title":"Joint development of bioimageio.spec and bioimageio.core","text":"<p>Assuming spec-bioimage-io is cloned to the parent folder a joint development environment can be created with the following commands:</p> <pre><code>conda create -n core python=$(grep -E '^requires-python' pyproject.toml | grep -oE '[0-9]+\\.[0-9]+')\nconda activate core\npip install -e .[dev,partners] -e ../spec-bioimage-io[dev]\n</code></pre>"},{"location":"#logging-level","title":"Logging level","text":"<p><code>bioimageio.spec</code> and <code>bioimageio.core</code> use loguru for logging, hence the logging level may be controlled with the <code>LOGURU_LEVEL</code> environment variable. The <code>bioimageio</code> CLI has logging enabled by default. To activate logging when using bioimageio.spec/bioimageio.core as a library, add</p> <pre><code>from loguru import logger\n\nlogger.enable(\"bioimageio\")\n</code></pre>"},{"location":"#changelog","title":"Changelog","text":"<p>See changelog.md</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#096","title":"0.9.6","text":"<ul> <li>bump bioimageio.spec library version to 0.5.7.2</li> <li>increase default reprducibility tolerance</li> <li>unify quantile (vs percentile) variable names</li> <li>add quantile computation method parameter</li> <li>accept <code>SampleQuantile</code> or <code>DatasetQuantile</code> as <code>min</code>/<code>max</code> arguments to <code>proc_ops.Clip</code></li> </ul>"},{"location":"changelog/#095","title":"0.9.5","text":"<ul> <li>bump bioimageio.spec library version to 0.5.6.0</li> <li>improved ONNX export from pytorch state dict or torchscript using torch dynamo</li> <li>default <code>opset_version</code> for <code>pytorch_to_onnx</code>/<code>torchscript_for_onnx</code> conversions bumped to 18.</li> </ul>"},{"location":"changelog/#094","title":"0.9.4","text":"<ul> <li>bump bioimageio.spec library version to 0.5.5.6</li> <li>Replace <code>conda activate &lt;env name&gt;</code> with <code>conda run -n &lt;env name&gt; python --version</code> when checking if a conda environment exists   (This is closer to the actual <code>conda run</code> command we need and avoids requests by conda to rerun <code>conda init</code> (in CI).)</li> <li>remove upper xarray pin (use ops from xarray.computation.ops, fallback to xarray.core.ops for older xarray versions)</li> </ul>"},{"location":"changelog/#093","title":"0.9.3","text":"<ul> <li>bump bioimageio.spec library version to 0.5.5.5</li> <li>more robust test model reporting</li> <li>improved user input axis intepretation</li> <li>fixed conda subprocess calls</li> </ul>"},{"location":"changelog/#092","title":"0.9.2","text":"<ul> <li>fix model inference tolerance reporting</li> </ul>"},{"location":"changelog/#091","title":"0.9.1","text":"<ul> <li>fixes:</li> <li>CLI<ul> <li>improved handling of summary argument to not create a path with brackets when given a list of paths.</li> <li>improved backward compatibility when runnig tests for models specifying an older bioimageio.core version in their environment. This is relevant when using <code>runtime_env=\"as-described\"</code>. It works by simply trying option <code>--summary</code> (new option name) and <code>--summary-path</code> (outdated option name)</li> </ul> </li> </ul>"},{"location":"changelog/#090","title":"0.9.0","text":"<ul> <li>update to bioimageio.spec 0.5.4.3</li> </ul>"},{"location":"changelog/#080","title":"0.8.0","text":"<ul> <li>breaking: removed <code>decimals</code> argument from bioimageio CLI and <code>bioimageio.core.commands.test()</code></li> <li>New feature: <code>bioimageio.core.test_description</code> accepts runtime_env and run_command to test a resource   using the conda environment described by that resource (or another specified conda env)</li> <li>new CLI command: <code>bioimageio add-weights</code> (and utility function: bioimageio.core.add_weights)</li> <li>removed <code>bioimageio.core.proc_ops.get_proc_class</code> in favor of <code>bioimageio.core.proc_ops.get_proc</code></li> <li>new CLI command: <code>bioimageio update-format</code></li> <li>new CLI command: <code>bioimageio update-hashes</code></li> </ul>"},{"location":"changelog/#070","title":"0.7.0","text":"<ul> <li>breaking:</li> <li>bioimageio CLI now has implicit boolean flags</li> <li>non-breaking:</li> <li>use new <code>ValidationDetail.recommended_env</code> in <code>ValidationSummary</code></li> <li>improve <code>get_io_sample_block_metas()</code><ul> <li>now works for sufficiently large, but not exactly shaped inputs</li> </ul> </li> <li>update to support <code>zipfile.ZipFile</code> object with bioimageio.spec==0.5.3.5</li> <li>add io helpers <code>resolve</code> and <code>resolve_and_extract</code></li> <li>added <code>enable_determinism</code> function and determinism input argument for testing with seeded     random generators and optionally (determinsim==\"full\") instructing DL frameworks to use     deterministic algorithms.</li> </ul>"},{"location":"changelog/#0610","title":"0.6.10","text":"<ul> <li>fix #423</li> </ul>"},{"location":"changelog/#069","title":"0.6.9","text":"<ul> <li>improve bioimageio command line interface (details in #157)</li> <li>add <code>predict</code> command</li> <li>package command input <code>path</code> is now required</li> </ul>"},{"location":"changelog/#068","title":"0.6.8","text":"<ul> <li>testing model inference will now check all weight formats   (previously only the first one for which model adapter creation succeeded had been checked)</li> <li>fix predict with blocking (Thanks @thodkatz)</li> </ul>"},{"location":"changelog/#067","title":"0.6.7","text":"<ul> <li><code>predict()</code> argument <code>inputs</code> may be sample</li> </ul>"},{"location":"changelog/#066","title":"0.6.6","text":"<ul> <li>add aliases to match previous API more closely</li> </ul>"},{"location":"changelog/#065","title":"0.6.5","text":"<ul> <li>improve adapter error messages</li> </ul>"},{"location":"changelog/#064","title":"0.6.4","text":"<ul> <li>add <code>bioimageio validate-format</code> command</li> <li>improve error messages and display of command results</li> </ul>"},{"location":"changelog/#063","title":"0.6.3","text":"<ul> <li>Fix #386</li> <li>(in model inference testing) stop assuming model inputs are tileable</li> </ul>"},{"location":"changelog/#062","title":"0.6.2","text":"<ul> <li>Fix #384</li> </ul>"},{"location":"changelog/#061","title":"0.6.1","text":"<ul> <li>Fix #378 (with #379)*</li> </ul>"},{"location":"changelog/#060","title":"0.6.0","text":"<ul> <li>add compatibility with new bioimageio.spec 0.5 (0.5.2post1)</li> <li>improve interfaces</li> </ul>"},{"location":"changelog/#0510","title":"0.5.10","text":"<ul> <li>Fix critical bug in predict with tiling</li> </ul>"},{"location":"cli/","title":"bioimageio CLI","text":""},{"location":"cli/#bioimageio-command-line-interface","title":"bioimageio Command Line Interface","text":"<p><code>bioimageio.core</code> installs a command line interface (CLI) for testing models and other functionality. You can list all the available commands via:</p> <pre><code>bioimageio --help\nusage: bioimageio [-h] {validate-format,test,package,predict,update-format,update-hashes,add-weights} ...\n\nbioimageio - CLI for bioimage.io resources \ud83e\udd92\n\nlibrary versions:\n  bioimageio.core 0.9.6\n  bioimageio.spec 0.5.7.2\n\nspec format versions:\n        model RDF 0.5.7\n      dataset RDF 0.3.0\n     notebook RDF 0.3.0\n\noptions:\n  -h, --help            show this help message and exit\n\nsubcommands:\n  {validate-format,test,package,predict,update-format,update-hashes,add-weights}\n    validate-format     Validate the meta data format of a bioimageio resource.\n    test                Test a bioimageio resource (beyond meta data formatting).\n    package             Save a resource's metadata with its associated files.\n    predict             Run inference on your data with a bioimage.io model.\n    update-format       Update the metadata format to the latest format version.\n    update-hashes       Create a bioimageio.yaml description with updated file hashes.\n    add-weights         Add additional weights to a model description by converting from available formats.\n</code></pre> <p>For concrete examples see Get started.</p>"},{"location":"cli/#cli-inputs-from-file","title":"CLI inputs from file","text":"<p>For convenience the command line options (not arguments) may be given in a <code>bioimageio-cli.json</code> or <code>bioimageio-cli.yaml</code> file, e.g.:</p> <pre><code># bioimageio-cli.yaml\ninputs: inputs/*_{tensor_id}.tiff\noutputs: outputs_{model_id}/{sample_id}_{tensor_id}.tiff\noverwrite: true\nblockwise: true\nstats: inputs/dataset_statistics.json\n</code></pre>"},{"location":"compatibility/","title":"Compatibility with bioimage.io resources","text":"<p>bioimageio.core is used on bioimage.io to test resources during and after the upload process. Results are reported as \"Test reports\" (bioimageio.core deployed in a generic Python environment) as well as the bioimageio.core tool compatibility (testing a resource with bioimageio.core in a dedicated Python environment).</p> <p>An overview of the latter is available as part of the collection documentation.</p>"},{"location":"coverage/","title":"Coverage report","text":""},{"location":"get_started/","title":"Get started","text":""},{"location":"get_started/#finding-a-compatible-python-environment","title":"Finding a compatible Python environment","text":"<p>For model inference you need a Python environment with the <code>bioimageio.core</code> package and model (framework) specific dependencies installed. You may choose to install <code>bioimageio.core</code> alongside (a) suitable framework(s) as optional dependencies with pip, e.g.:</p> <pre><code>pip install bioimageio.core[pytorch,onnx]\n</code></pre> <p>If you are not sure which framework you want to use this model with or the model comes with custom dependencies, you may choose to have the bioimageio Command Line Interface (CLI) create a suitable environment for a specific model, using mini-forge (or your favorite conda distribution). For more details on conda environments, checkout the conda docs. First create/use any conda environment with <code>bioimageio.core&gt;0.9.6</code> in it:</p> <pre><code>conda create -n bioimageio -c conda-forge \"bioimageio.core&gt;0.9.6\"\nconda activate bioimageio\n</code></pre> <p>Choose a model source, e.g. a bioimage.io model id like \"affable-shark\" or a path/url to a bioimageio.yaml (often named rdf.yaml). Then use the bioimageio CLI (or bioimageio.core.test_description) to test the model. Use runtime-env=as-described to test each available weight format in the recommended conda environment that is installed on the fly if necessary:</p> <pre><code>bioimageio test affable-shark --runtime-env=as-described\n</code></pre> <p>The resulting report shows details of the tests performed in the respective conda environments. Inspecting the report, choose a conda environment that passed all tests. The conda environments will be named by the SHA-256 value of the generated conda environment.yaml, e.g. \"95227f474ca45b024cf315edb4101e4919199d0a79ef5ff1eb474dc8ce1ec4d8\".</p> <p>You may want to rename or clone your chosen conda environment:</p> <pre><code>conda activate base\nconda rename -n 95227f474ca45b024cf315edb4101e4919199d0a79ef5ff1eb474dc8ce1ec4d8 bioimageio-affable-shark\nconda activate bioimageio-affable-shark\n</code></pre>"},{"location":"get_started/#test-modelenvironment","title":"Test model+environment","text":"<p>Test a bioimageio compatible model, e.g. \"affable-shark\" in an active Python environment:</p> <pre><code>bioimageio test affable-shark\n0:00:01.754788 | INFO     | cli - starting CLI with arguments:\n['/opt/hostedtoolcache/Python/3.12.12/x64/bin/bioimageio',\n 'test',\n 'affable-shark']\n0:00:01.755421 | INFO     | cli - loaded CLI input:\n{'test': {'source': 'affable-shark'}}\n0:00:01.755656 | INFO     | cli - executing CLI command:\n{'test': {'determinism': 'seed_only',\n          'devices': None,\n          'format_version': 'discover',\n          'runtime_env': 'currently-active',\n          'source': 'affable-shark',\n          'stop_early': False,\n          'summary': ['display'],\n          'weight_format': 'all',\n          'working_dir': None}}\n2026-02-13 09:51:23.774419247 [W:onnxruntime:Default, device_discovery.cc:131 GetPciBusId] Skipping pci_bus_id for PCI path at \"/sys/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/5620e0c7-8062-4dce-aeb7-520c7ef76171\" because filename \"\"5620e0c7-8062-4dce-aeb7-520c7ef76171\"\" dit not match expected pattern of [0-9a-f]+:[0-9a-f]+:[0-9a-f]+[.][0-9a-f]+\n/home/runner/work/core-bioimage-io-python/core-bioimage-io-python/src/bioimageio/core/backends/onnx_backend.py:105: UserWarning: Device management is not implemented for onnx yet, cannot unload model\n  warnings.warn(\n0:01:15.248353 | INFO     | _resource_tests - Testing inference with 'onnx' for 6 different inputs (B, N): {(1, 2), (2, 1), (1, 1), (2, 0), (2, 2), (1, 0)}\n2026-02-13 09:51:25.056560233 [W:onnxruntime:, execution_frame.cc:874 VerifyOutputSizes] Expected shape from model of {1,2,-1,-1} does not match actual shape of {2,2,64,64} for output output0\n2026-02-13 09:51:25.168635180 [W:onnxruntime:, execution_frame.cc:874 VerifyOutputSizes] Expected shape from model of {1,2,-1,-1} does not match actual shape of {2,2,80,80} for output output0\n2026-02-13 09:51:25.328660876 [W:onnxruntime:, execution_frame.cc:874 VerifyOutputSizes] Expected shape from model of {1,2,-1,-1} does not match actual shape of {2,2,96,96} for output output0\n/home/runner/work/core-bioimage-io-python/core-bioimage-io-python/src/bioimageio/core/backends/onnx_backend.py:105: UserWarning: Device management is not implemented for onnx yet, cannot unload model\n  warnings.warn(\n0:01:16.968462 | INFO     | _resource_tests - Testing inference with 'pytorch_state_dict' for 6 different inputs (B, N): {(1, 2), (2, 1), (1, 1), (2, 0), (2, 2), (1, 0)}\n0:01:19.029354 | INFO     | _resource_tests - Testing inference with 'torchscript' for 6 different inputs (B, N): {(1, 2), (2, 1), (1, 1), (2, 0), (2, 2), (1, 0)}\n::warning file=/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/bioimageio/spec/_get_conda_env.py,line=155,endLine=156,title=UPDATE NEEDED::Leaving torchvision and torchaudio unpinned for pytorch==2.8.0\n\n\n \u2714\ufe0f               bioimageio format validation \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n status           passed                       \n source           affable-shark                \n id               affable-shark                \n format version   model 0.5.7                  \n bioimageio.core  0.9.6                        \n bioimageio.spec  0.5.7.2                      \n\n\n\n     Location                    Details                                                                                      \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n \u2714\ufe0f                              Successfully created ModelDescr instance.                                                    \n \u2714\ufe0f                              bioimageio.spec format validation model 0.5.7                                                \n \u2714\ufe0f  weights.onnx                Reproduce test outputs from test inputs (onnx)                                               \n     weights.onnx                recommended conda environment (Reproduce test outputs from test inputs (onnx))               \n                                 See Recommended Conda Environment 1 below.                                                   \n     weights.onnx                conda compare (Reproduce test outputs from test inputs (onnx))                               \n                                 See Conda Environment Comparison 1 below.                                                    \n \u2714\ufe0f  weights.onnx                Run onnx inference for inputs with batch_size: 1 and size parameter n: 0                     \n \u2714\ufe0f  weights.onnx                Run onnx inference for inputs with batch_size: 1 and size parameter n: 1                     \n \u2714\ufe0f  weights.onnx                Run onnx inference for inputs with batch_size: 1 and size parameter n: 2                     \n \u2714\ufe0f  weights.onnx                Run onnx inference for inputs with batch_size: 2 and size parameter n: 0                     \n \u2714\ufe0f  weights.onnx                Run onnx inference for inputs with batch_size: 2 and size parameter n: 1                     \n \u2714\ufe0f  weights.onnx                Run onnx inference for inputs with batch_size: 2 and size parameter n: 2                     \n \u2714\ufe0f  weights.pytorch_state_dict  Reproduce test outputs from test inputs (pytorch_state_dict)                                 \n     weights.pytorch_state_dict  recommended conda environment (Reproduce test outputs from test inputs (pytorch_state_dict)) \n                                 See Recommended Conda Environment 2 below.                                                   \n     weights.pytorch_state_dict  conda compare (Reproduce test outputs from test inputs (pytorch_state_dict))                 \n                                 See Conda Environment Comparison 2 below.                                                    \n \u2714\ufe0f  weights.pytorch_state_dict  Run pytorch_state_dict inference for inputs with batch_size: 1 and size parameter n: 0       \n \u2714\ufe0f  weights.pytorch_state_dict  Run pytorch_state_dict inference for inputs with batch_size: 1 and size parameter n: 1       \n \u2714\ufe0f  weights.pytorch_state_dict  Run pytorch_state_dict inference for inputs with batch_size: 1 and size parameter n: 2       \n \u2714\ufe0f  weights.pytorch_state_dict  Run pytorch_state_dict inference for inputs with batch_size: 2 and size parameter n: 0       \n \u2714\ufe0f  weights.pytorch_state_dict  Run pytorch_state_dict inference for inputs with batch_size: 2 and size parameter n: 1       \n \u2714\ufe0f  weights.pytorch_state_dict  Run pytorch_state_dict inference for inputs with batch_size: 2 and size parameter n: 2       \n \u2714\ufe0f  weights.torchscript         Reproduce test outputs from test inputs (torchscript)                                        \n     weights.torchscript         recommended conda environment (Reproduce test outputs from test inputs (torchscript))        \n                                 See Recommended Conda Environment 3 below.                                                   \n     weights.torchscript         conda compare (Reproduce test outputs from test inputs (torchscript))                        \n                                 See Conda Environment Comparison 3 below.                                                    \n \u2714\ufe0f  weights.torchscript         Run torchscript inference for inputs with batch_size: 1 and size parameter n: 0              \n \u2714\ufe0f  weights.torchscript         Run torchscript inference for inputs with batch_size: 1 and size parameter n: 1              \n \u2714\ufe0f  weights.torchscript         Run torchscript inference for inputs with batch_size: 1 and size parameter n: 2              \n \u2714\ufe0f  weights.torchscript         Run torchscript inference for inputs with batch_size: 2 and size parameter n: 0              \n \u2714\ufe0f  weights.torchscript         Run torchscript inference for inputs with batch_size: 2 and size parameter n: 1              \n \u2714\ufe0f  weights.torchscript         Run torchscript inference for inputs with batch_size: 2 and size parameter n: 2              \n\nRecommended Conda Environment 1\n\n %YAML 1.2                                                                                                                                                                                              \n ---                                                                                                                                                                                                    \n channels:                                                                                                                                                                                              \n   - conda-forge                                                                                                                                                                                        \n   - nodefaults                                                                                                                                                                                         \n dependencies:                                                                                                                                                                                          \n   - conda-forge::bioimageio.core                                                                                                                                                                       \n   - onnxruntime                                                                                                                                                                                        \n   - pip                                                                                                                                                                                                \n\nConda Environment Comparison 1\n\n bioimageio.core not found onnxruntime not found                                                                                                                                                        \n\nRecommended Conda Environment 2\n\n %YAML 1.2                                                                                                                                                                                              \n ---                                                                                                                                                                                                    \n channels:                                                                                                                                                                                              \n   - pytorch                                                                                                                                                                                            \n   - conda-forge                                                                                                                                                                                        \n   - nodefaults                                                                                                                                                                                         \n dependencies:                                                                                                                                                                                          \n   - conda-forge::bioimageio.core                                                                                                                                                                       \n   - mkl ==2024.0.0                                                                                                                                                                                     \n   - numpy &lt;2                                                                                                                                                                                           \n   - pip                                                                                                                                                                                                \n   - pytorch==1.10.0                                                                                                                                                                                    \n   - setuptools &lt;70.0.0                                                                                                                                                                                 \n   - torchaudio==0.10.0                                                                                                                                                                                 \n   - torchvision==0.11.0                                                                                                                                                                                \n\nConda Environment Comparison 2\n\n bioimageio.core not found mkl not found numpy not found pytorch not found setuptools found but                                                                                                         \n mismatch. Specification pkg: setuptools[version='&lt;70.0.0'], Running pkg:                                                                                                                               \n setuptools=80.9.0=py313h06a4308_0 torchaudio not found torchvision not found                                                                                                                           \n\nRecommended Conda Environment 3\n\n %YAML 1.2                                                                                                                                                                                              \n ---                                                                                                                                                                                                    \n channels:                                                                                                                                                                                              \n   - conda-forge                                                                                                                                                                                        \n   - nodefaults                                                                                                                                                                                         \n dependencies:                                                                                                                                                                                          \n   - conda-forge::bioimageio.core                                                                                                                                                                       \n   - numpy &gt;=2,&lt;3                                                                                                                                                                                       \n   - pip                                                                                                                                                                                                \n   - pytorch==2.8.0                                                                                                                                                                                     \n   - torchaudio                                                                                                                                                                                         \n   - torchvision                                                                                                                                                                                        \n\nConda Environment Comparison 3\n\n bioimageio.core not found numpy not found pytorch not found torchaudio not found torchvision not                                                                                                       \n found                                                                                                                                                                                                  \n</code></pre> <p>To test your model replace the already published model identifier 'affabl-shark' with a local folder or path to a bioimageio.yaml file. Check out the bioimageio.spec documentation for more information on the bioimage.io metadata description format.</p> <p>The Python equivalent would be:</p> <p></p>"},{"location":"get_started/#cli-bioimageio-predict","title":"CLI: bioimageio predict","text":"<p>You can use the <code>bioimageio</code> Command Line Interface (CLI) provided by the <code>bioimageio.core</code> package to run prediction with a bioimageio compatible model in a suitable Python environment.</p> <pre><code>bioimageio predict --help\nusage: bioimageio predict [-h] [--inputs List[{str,List[str]}]] [--outputs {str,Tuple[str,...]}] [--overwrite | --no-overwrite] [--blockwise | --no-blockwise] [--stats Path]\n                          [--preview | --no-preview] [--weight-format {keras_hdf5,onnx,pytorch_state_dict,tensorflow_saved_model_bundle,torchscript,any}] [--example | --no-example]\n                          SOURCE\n\nRun inference on your data with a bioimage.io model.\n\npositional arguments:\n  SOURCE                Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file\n                        or a bioimage.io resource identifier, e.g. 'affable-shark'\n\noptions:\n  -h, --help            show this help message and exit\n  --inputs List[{str,List[str]}]\n                        Model input sample paths (for each input tensor)\n\n                        The input paths are expected to have shape...\n                         - (n_samples,) or (n_samples,1) for models expecting a single input tensor\n                         - (n_samples,) containing the substring '{input_id}', or\n                         - (n_samples, n_model_inputs) to provide each input tensor path explicitly.\n\n                        All substrings that are replaced by metadata from the model description:\n                        - '{model_id}'\n                        - '{input_id}'\n\n                        Example inputs to process sample 'a' and 'b'\n                        for a model expecting a 'raw' and a 'mask' input tensor:\n                        --inputs=\"[[\\\"a_raw.tif\\\",\\\"a_mask.tif\\\"],[\\\"b_raw.tif\\\",\\\"b_mask.tif\\\"]]\"\n                        (Note that JSON double quotes need to be escaped.)\n\n                        Alternatively a `bioimageio-cli.yaml` (or `bioimageio-cli.json`) file\n                        may provide the arguments, e.g.:\n                        ```yaml\n                        inputs:\n                        - [a_raw.tif, a_mask.tif]\n                        - [b_raw.tif, b_mask.tif]\n                        ```\n\n                        `.npy` and any file extension supported by imageio are supported.\n                         Aavailable formats are listed at\n                        https://imageio.readthedocs.io/en/stable/formats/index.html#all-formats.\n                        Some formats have additional dependencies.\n\n                        \u200a (default factory: PredictCmd.&lt;lambda&gt;)\n  --outputs {str,Tuple[str,...]}\n                        Model output path pattern (per output tensor)\n\n                        All substrings that are replaced:\n                        - '{model_id}' (from model description)\n                        - '{output_id}' (from model description)\n                        - '{sample_id}' (extracted from input paths)\n\n                        \u200a (default: outputs_{model_id}/{output_id}/{sample_id}.tif)\n  --overwrite, --no-overwrite\n                        allow overwriting existing output files (default: False)\n  --blockwise, --no-blockwise\n                        process inputs blockwise (default: False)\n  --stats Path          path to dataset statistics\n                        (will be written if it does not exist,\n                        but the model requires statistical dataset measures)\n                        \u200a (default: dataset_statistics.json)\n  --preview, --no-preview\n                        preview which files would be processed\n                        and what outputs would be generated. (default: False)\n  --weight-format {keras_hdf5,onnx,pytorch_state_dict,tensorflow_saved_model_bundle,torchscript,any}, --weights-format {keras_hdf5,onnx,pytorch_state_dict,tensorflow_saved_model_bundle,torchscript,any}, --weight_format {keras_hdf5,onnx,pytorch_state_dict,tensorflow_saved_model_bundle,torchscript,any}, --weights_format {keras_hdf5,onnx,pytorch_state_dict,tensorflow_saved_model_bundle,torchscript,any}\n                        The weight format to use. (default: any)\n  --example, --no-example\n                        generate and run an example\n\n                        1. downloads example model inputs\n                        2. creates a `{model_id}_example` folder\n                        3. writes input arguments to `{model_id}_example/bioimageio-cli.yaml`\n                        4. executes a preview dry-run\n                        5. executes prediction with example input\n\n                        \u200a (default: False)\n</code></pre> <p>Create a local example and run prediction locally:</p> <pre><code>bioimageio predict affable-shark --example\n0:00:01.770879 | INFO     | cli - starting CLI with arguments:\n['/opt/hostedtoolcache/Python/3.12.12/x64/bin/bioimageio',\n 'predict',\n 'affable-shark',\n '--example']\n0:00:01.771715 | INFO     | cli - loaded CLI input:\n{'predict': {'example': True, 'source': 'affable-shark'}}\n0:00:01.771963 | INFO     | cli - executing CLI command:\n{'predict': {'blockwise': False,\n             'example': True,\n             'inputs': ['{input_id}/001.tif'],\n             'outputs': 'outputs_{model_id}/{output_id}/{sample_id}.tif',\n             'overwrite': False,\n             'preview': False,\n             'source': 'affable-shark',\n             'stats': 'dataset_statistics.json',\n             'weight_format': 'any'}}\n0:00:01.753832 | INFO     | cli - starting CLI with arguments:\n['/opt/hostedtoolcache/Python/3.12.12/x64/bin/bioimageio',\n 'predict',\n '--preview',\n '--overwrite',\n '--stats=affable-shark_example/dataset_statistics.json',\n '--inputs=[[\"affable-shark_example/input0/001.tif\"]]',\n '--outputs=affable-shark_example/outputs/{output_id}/{sample_id}.tif',\n 'affable-shark']\n0:00:01.755007 | INFO     | cli - loaded CLI input:\n{'predict': {'inputs': [['affable-shark_example/input0/001.tif']],\n             'outputs': 'affable-shark_example/outputs/{output_id}/{sample_id}.tif',\n             'overwrite': True,\n             'preview': True,\n             'source': 'affable-shark',\n             'stats': 'affable-shark_example/dataset_statistics.json'}}\n0:00:01.755292 | INFO     | cli - executing CLI command:\n{'predict': {'blockwise': False,\n             'example': False,\n             'inputs': [['affable-shark_example/input0/001.tif']],\n             'outputs': 'affable-shark_example/outputs/{output_id}/{sample_id}.tif',\n             'overwrite': True,\n             'preview': True,\n             'source': 'affable-shark',\n             'stats': 'affable-shark_example/dataset_statistics.json',\n             'weight_format': 'any'}}\n\ud83d\udec8 bioimageio prediction preview structure:\n{'{sample_id}': {'inputs': {'{input_id}': '&lt;input path&gt;'},\n                 'outputs': {'{output_id}': '&lt;output path&gt;'}}}\n\ud83d\udd0e bioimageio prediction preview output:\n{'1': {'inputs': {'input0': 'affable-shark_example/input0/001.tif'},\n       'outputs': {'output0': 'affable-shark_example/outputs/output0/1.tif'}}}\n0:00:01.748502 | INFO     | cli - starting CLI with arguments:\n['/opt/hostedtoolcache/Python/3.12.12/x64/bin/bioimageio',\n 'predict',\n '--overwrite',\n '--stats=affable-shark_example/dataset_statistics.json',\n '--inputs=[[\"affable-shark_example/input0/001.tif\"]]',\n '--outputs=affable-shark_example/outputs/{output_id}/{sample_id}.tif',\n 'affable-shark']\n0:00:01.749636 | INFO     | cli - loaded CLI input:\n{'predict': {'inputs': [['affable-shark_example/input0/001.tif']],\n             'outputs': 'affable-shark_example/outputs/{output_id}/{sample_id}.tif',\n             'overwrite': True,\n             'source': 'affable-shark',\n             'stats': 'affable-shark_example/dataset_statistics.json'}}\n0:00:01.749931 | INFO     | cli - executing CLI command:\n{'predict': {'blockwise': False,\n             'example': False,\n             'inputs': [['affable-shark_example/input0/001.tif']],\n             'outputs': 'affable-shark_example/outputs/{output_id}/{sample_id}.tif',\n             'overwrite': True,\n             'preview': False,\n             'source': 'affable-shark',\n             'stats': 'affable-shark_example/dataset_statistics.json',\n             'weight_format': 'any'}}\n\npredict with affable-shark:   0%|          | 0/1 [00:00&lt;?, ?sample/s]\npredict with affable-shark: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00,  1.42sample/s]\npredict with affable-shark: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00,  1.42sample/s]\n\ud83c\udf89 Sucessfully ran example prediction!\nTo predict the example input using the CLI example config file affable-shark_example/bioimageio-cli.yaml, execute `bioimageio predict` from affable-shark_example:\n$ cd affable-shark_example\n$ bioimageio predict \"affable-shark\"\n\nAlternatively run the following command in the current workind directory, not the example folder:\n$ bioimageio predict --overwrite --stats=\"affable-shark_example/dataset_statistics.json\" --inputs=\"[[\\\"affable-shark_example/input0/001.tif\\\"]]\" --outputs=\"affable-shark_example/outputs/{output_id}/{sample_id}.tif\" \"affable-shark\"\n(note that a local 'bioimageio-cli.json' or 'bioimageio-cli.yaml' may interfere with this)\n</code></pre>"},{"location":"get_started/#python-bioimageiocorepredict","title":"Python: bioimageio.core.predict","text":"<p>Here is a code snippet to get started deploying a model in Python using the test sample provided by the model description:</p> <pre><code>from bioimageio.core import load_model_description, predict\nfrom bioimageio.core.digest_spec import get_test_input_sample\n\nmodel_descr = load_model_description(\"&lt;model.yaml or model.zip path or URL&gt;\")\ninput_sample = get_test_input_sample(model_descr)\noutput_sample = predict(model=model_descr, inputs=input_sample)\n</code></pre>"},{"location":"get_started/#python-predict-your-own-data","title":"Python: predict your own data","text":"<pre><code>from bioimageio.core.digest_spec import create_sample_for_model\n\ninput_sample = create_sample_for_model(\n    model_descr,\n    inputs={{\"raw\": \"&lt;path to your input image&gt;\"}}\n)\noutput_sample = predict(model=model_descr, inputs=input_sample)\n</code></pre>"},{"location":"get_started/#python-prediction-options","title":"Python: prediction options","text":"<p>For model inference from within Python these options are available:</p> <ul> <li>bioimageio.core.predict to run inference on a single sample/image.</li> <li>bioimageio.core.predict_many to run inference on a set of samples.</li> <li>bioimageio.core.create_prediction_pipeline for reusing the instatiated model and more fine-grain control over the inference process this function creates a suitable bioimageio.core.PredictionPipeline for more advanced use.</li> </ul>"},{"location":"get_started/#other-bioimageiocore-functionality","title":"Other bioimageio.core functionality","text":""},{"location":"get_started/#cli-bioimageio-commands","title":"CLI: bioimageio commands","text":"<p>To get an overview of available commands:</p> <pre><code>bioimageio --help\nusage: bioimageio [-h] {validate-format,test,package,predict,update-format,update-hashes,add-weights} ...\n\nbioimageio - CLI for bioimage.io resources \ud83e\udd92\n\nlibrary versions:\n  bioimageio.core 0.9.6\n  bioimageio.spec 0.5.7.2\n\nspec format versions:\n        model RDF 0.5.7\n      dataset RDF 0.3.0\n     notebook RDF 0.3.0\n\noptions:\n  -h, --help            show this help message and exit\n\nsubcommands:\n  {validate-format,test,package,predict,update-format,update-hashes,add-weights}\n    validate-format     Validate the meta data format of a bioimageio resource.\n    test                Test a bioimageio resource (beyond meta data formatting).\n    package             Save a resource's metadata with its associated files.\n    predict             Run inference on your data with a bioimage.io model.\n    update-format       Update the metadata format to the latest format version.\n    update-hashes       Create a bioimageio.yaml description with updated file hashes.\n    add-weights         Add additional weights to a model description by converting from available formats.\n</code></pre>"},{"location":"get_started/#python-api-docs","title":"Python: API docs","text":"<p>See bioimageio.core.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#via-conda","title":"Via Conda","text":"<p>The <code>bioimageio.core</code> package can be installed from conda-forge via</p> <pre><code>conda install -c conda-forge bioimageio.core\n</code></pre> <p>If you do not install any additional deep learning (DL) libraries, you will only be able to use general convenience functionality, but model inference will be unavailable. To install additional deep learning libraries add <code>pytorch</code>, <code>onnxruntime</code>, <code>keras</code> or <code>tensorflow</code>.</p> <p>Deeplearning frameworks to consider installing alongside <code>bioimageio.core</code>:</p> <ul> <li>Pytorch/Torchscript</li> <li>TensorFlow</li> <li>ONNXRuntime</li> </ul> <p>Example for installing bioimageio.core via conda with additional DL frameworks:</p> <pre><code>conda install -c conda-forge bioimageio.core pytorch torchvision onnxruntime\n</code></pre>"},{"location":"installation/#via-pip","title":"Via pip","text":"<p>The package is also available via pip (e.g. with recommended extras <code>onnx</code> and <code>pytorch</code>):</p> <pre><code>pip install \"bioimageio.core[pytorch,onnx]\"\n</code></pre>"},{"location":"use_in_python/","title":"Use in Python","text":"<p>Here you can find recommendations for using bioimageio.core in your Python package or scripts.</p> <p>See API reference for details beyond this brief orientation.</p>"},{"location":"use_in_python/#run-inference","title":"Run inference","text":"<p>The bioimageio.core.predict and predict_many aim to provide an easy-to-use interface to run inference with a bioimage.io model. See Compatibility for a list of compatible models or browser the Model Zoo at https://bioimage.io.</p>"},{"location":"api/","title":"bioimageio.core","text":""},{"location":"api/#bioimageio.core","title":"core","text":"<p>bioimageio.core --- core functionality for BioImage.IO resources</p> <p>The main focus on this library is to provide functionality to run prediction with BioImage.IO models, including standardized pre- and postprocessing operations. The BioImage.IO models (and other resources) are described by---and can be loaded with---the bioimageio.spec package.</p> <p>See <code>predict</code> and <code>predict_many</code> for straight-forward model inference and <code>create_prediction_pipeline</code> for finer control of the inference process.</p> <p>Other notable bioimageio.core functionalities include: - Testing BioImage.IO resources beyond format validation, e.g. by generating model outputs from test inputs.   See <code>test_model</code> or for arbitrary resource types <code>test_description</code>. - Extending available model weight formats by converting existing ones, see <code>add_weights</code>. - Creating and manipulating <code>Sample</code>s consisting of tensors with associated statistics. - Computing statistics on datasets (represented as sequences of samples), see <code>compute_dataset_measures</code>.</p> <p>Modules:</p> Name Description <code>__main__</code> <code>axis</code> <code>backends</code> <code>block</code> <code>block_meta</code> <code>cli</code> <p>bioimageio CLI</p> <code>commands</code> <p>These functions are used in the bioimageio command line interface</p> <code>common</code> <code>dataset</code> <code>digest_spec</code> <code>io</code> <code>model_adapters</code> <p>DEPRECATED</p> <code>prediction</code> <code>proc_ops</code> <code>proc_setup</code> <code>sample</code> <code>stat_calculators</code> <code>stat_measures</code> <code>tensor</code> <code>utils</code> <code>weight_converters</code> <p>Classes:</p> Name Description <code>PredictionPipeline</code> <p>Represents model computation including preprocessing and postprocessing</p> <code>Settings</code> <p>environment variables for bioimageio.spec and bioimageio.core</p> <p>Functions:</p> Name Description <code>create_prediction_pipeline</code> <p>Creates prediction pipeline which includes:</p> <code>enable_determinism</code> <p>Seed and configure ML frameworks for maximum reproducibility.</p> <code>load_description_and_test</code> <p>Test a bioimage.io resource dynamically,</p> <code>test_description</code> <p>Test a bioimage.io resource dynamically,</p> <code>test_model</code> <p>Test model inference</p> <p>Attributes:</p> Name Type Description <code>Axis</code> <code>AxisId</code> <code>BlockMeta</code> <code>MemberId</code> <code>Sample</code> <code>Stat</code> <code>Tensor</code> <code>ValidationSummary</code> <code>__version__</code> <code>add_weights</code> <code>build_description</code> <code>compute_dataset_measures</code> <code>create_model_adapter</code> <code>dump_description</code> <code>load_dataset_description</code> <code>load_description</code> <code>load_description_and_validate_format_only</code> <code>load_model</code> <p>alias of <code>load_model_description</code></p> <code>load_model_description</code> <code>load_resource</code> <p>alias of <code>load_description</code></p> <code>predict</code> <code>predict_many</code> <code>save_bioimageio_package</code> <code>save_bioimageio_package_as_folder</code> <code>save_bioimageio_yaml_only</code> <code>settings</code> <p>parsed environment variables for bioimageio.spec and bioimageio.core</p> <code>test_resource</code> <p>alias of <code>test_description</code></p> <code>validate_format</code>"},{"location":"api/#bioimageio.core.Axis","title":"Axis  <code>module-attribute</code>","text":"<pre><code>Axis = axis.Axis\n</code></pre>"},{"location":"api/#bioimageio.core.AxisId","title":"AxisId  <code>module-attribute</code>","text":"<pre><code>AxisId = axis.AxisId\n</code></pre>"},{"location":"api/#bioimageio.core.BlockMeta","title":"BlockMeta  <code>module-attribute</code>","text":"<pre><code>BlockMeta = block_meta.BlockMeta\n</code></pre>"},{"location":"api/#bioimageio.core.MemberId","title":"MemberId  <code>module-attribute</code>","text":"<pre><code>MemberId = common.MemberId\n</code></pre>"},{"location":"api/#bioimageio.core.Sample","title":"Sample  <code>module-attribute</code>","text":"<pre><code>Sample = sample.Sample\n</code></pre>"},{"location":"api/#bioimageio.core.Stat","title":"Stat  <code>module-attribute</code>","text":"<pre><code>Stat = stat_measures.Stat\n</code></pre>"},{"location":"api/#bioimageio.core.Tensor","title":"Tensor  <code>module-attribute</code>","text":"<pre><code>Tensor = tensor.Tensor\n</code></pre>"},{"location":"api/#bioimageio.core.ValidationSummary","title":"ValidationSummary  <code>module-attribute</code>","text":"<pre><code>ValidationSummary = bioimageio.spec.ValidationSummary\n</code></pre>"},{"location":"api/#bioimageio.core.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = '0.9.6'\n</code></pre>"},{"location":"api/#bioimageio.core.add_weights","title":"add_weights  <code>module-attribute</code>","text":"<pre><code>add_weights = weight_converters.add_weights\n</code></pre>"},{"location":"api/#bioimageio.core.build_description","title":"build_description  <code>module-attribute</code>","text":"<pre><code>build_description = bioimageio.spec.build_description\n</code></pre>"},{"location":"api/#bioimageio.core.compute_dataset_measures","title":"compute_dataset_measures  <code>module-attribute</code>","text":"<pre><code>compute_dataset_measures = stat_calculators.compute_dataset_measures\n</code></pre>"},{"location":"api/#bioimageio.core.create_model_adapter","title":"create_model_adapter  <code>module-attribute</code>","text":"<pre><code>create_model_adapter = backends.create_model_adapter\n</code></pre>"},{"location":"api/#bioimageio.core.dump_description","title":"dump_description  <code>module-attribute</code>","text":"<pre><code>dump_description = bioimageio.spec.dump_description\n</code></pre>"},{"location":"api/#bioimageio.core.load_dataset_description","title":"load_dataset_description  <code>module-attribute</code>","text":"<pre><code>load_dataset_description = bioimageio.spec.load_dataset_description\n</code></pre>"},{"location":"api/#bioimageio.core.load_description","title":"load_description  <code>module-attribute</code>","text":"<pre><code>load_description = bioimageio.spec.load_description\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0load_resource </li> </ul>"},{"location":"api/#bioimageio.core.load_description_and_validate_format_only","title":"load_description_and_validate_format_only  <code>module-attribute</code>","text":"<pre><code>load_description_and_validate_format_only = bioimageio.spec.load_description_and_validate_format_only\n</code></pre>"},{"location":"api/#bioimageio.core.load_model","title":"load_model  <code>module-attribute</code>","text":"<pre><code>load_model = load_model_description\n</code></pre> <p>alias of <code>load_model_description</code></p>"},{"location":"api/#bioimageio.core.load_model_description","title":"load_model_description  <code>module-attribute</code>","text":"<pre><code>load_model_description = bioimageio.spec.load_model_description\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0load_model </li> </ul>"},{"location":"api/#bioimageio.core.load_resource","title":"load_resource  <code>module-attribute</code>","text":"<pre><code>load_resource = load_description\n</code></pre> <p>alias of <code>load_description</code></p>"},{"location":"api/#bioimageio.core.predict","title":"predict  <code>module-attribute</code>","text":"<pre><code>predict = prediction.predict\n</code></pre> Referenced by: <ul> <li> Home Use in Python Run inference </li> </ul>"},{"location":"api/#bioimageio.core.predict_many","title":"predict_many  <code>module-attribute</code>","text":"<pre><code>predict_many = prediction.predict_many\n</code></pre> Referenced by: <ul> <li> Home Use in Python Run inference </li> </ul>"},{"location":"api/#bioimageio.core.save_bioimageio_package","title":"save_bioimageio_package  <code>module-attribute</code>","text":"<pre><code>save_bioimageio_package = bioimageio.spec.save_bioimageio_package\n</code></pre>"},{"location":"api/#bioimageio.core.save_bioimageio_package_as_folder","title":"save_bioimageio_package_as_folder  <code>module-attribute</code>","text":"<pre><code>save_bioimageio_package_as_folder = bioimageio.spec.save_bioimageio_package_as_folder\n</code></pre>"},{"location":"api/#bioimageio.core.save_bioimageio_yaml_only","title":"save_bioimageio_yaml_only  <code>module-attribute</code>","text":"<pre><code>save_bioimageio_yaml_only = bioimageio.spec.save_bioimageio_yaml_only\n</code></pre>"},{"location":"api/#bioimageio.core.settings","title":"settings  <code>module-attribute</code>","text":"<pre><code>settings = Settings()\n</code></pre> <p>parsed environment variables for bioimageio.spec and bioimageio.core</p>"},{"location":"api/#bioimageio.core.test_resource","title":"test_resource  <code>module-attribute</code>","text":"<pre><code>test_resource = test_description\n</code></pre> <p>alias of <code>test_description</code></p>"},{"location":"api/#bioimageio.core.validate_format","title":"validate_format  <code>module-attribute</code>","text":"<pre><code>validate_format = bioimageio.spec.validate_format\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline","title":"PredictionPipeline","text":"<pre><code>PredictionPipeline(*, name: str, model_description: AnyModelDescr, preprocessing: List[Processing], postprocessing: List[Processing], model_adapter: ModelAdapter, default_ns: Optional[BlocksizeParameter] = None, default_blocksize_parameter: BlocksizeParameter = 10, default_batch_size: int = 1)\n</code></pre> <p>Represents model computation including preprocessing and postprocessing Note: Ideally use the <code>PredictionPipeline</code> in a with statement     (as a context manager).</p> Returned by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0create_prediction_pipeline </li> </ul> Used by: <ul> <li> API Reference <code></code>\u00a0prediction <ul> <li> <code></code>\u00a0predict </li> <li> <code></code>\u00a0predict_many </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__enter__</code> <code>__exit__</code> <code>apply_postprocessing</code> <p>apply postprocessing in-place, also updates samples stats</p> <code>apply_preprocessing</code> <p>apply preprocessing in-place, also updates sample stats</p> <code>get_output_sample_id</code> <code>load</code> <p>optional step: load model onto devices before calling forward if not using it as context manager</p> <code>predict_sample_block</code> <code>predict_sample_with_blocking</code> <p>predict a sample by splitting it into blocks according to the model and the <code>ns</code> parameter</p> <code>predict_sample_with_fixed_blocking</code> <code>predict_sample_without_blocking</code> <p>predict a sample.</p> <code>unload</code> <p>free any device memory in use</p> <p>Attributes:</p> Name Type Description <code>model_description</code> <code>name</code> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def __init__(\n    self,\n    *,\n    name: str,\n    model_description: AnyModelDescr,\n    preprocessing: List[Processing],\n    postprocessing: List[Processing],\n    model_adapter: ModelAdapter,\n    default_ns: Optional[BlocksizeParameter] = None,\n    default_blocksize_parameter: BlocksizeParameter = 10,\n    default_batch_size: int = 1,\n) -&gt; None:\n    \"\"\"Consider using `create_prediction_pipeline` to create a `PredictionPipeline` with sensible defaults.\"\"\"\n    super().__init__()\n    default_blocksize_parameter = default_ns or default_blocksize_parameter\n    if default_ns is not None:\n        warnings.warn(\n            \"Argument `default_ns` is deprecated in favor of\"\n            + \" `default_blocksize_paramter` and will be removed soon.\"\n        )\n    del default_ns\n\n    if model_description.run_mode:\n        warnings.warn(\n            f\"Not yet implemented inference for run mode '{model_description.run_mode.name}'\"\n        )\n\n    self.name = name\n    self._preprocessing = preprocessing\n    self._postprocessing = postprocessing\n\n    self.model_description = model_description\n    if isinstance(model_description, v0_4.ModelDescr):\n        self._default_input_halo: PerMember[PerAxis[Halo]] = {}\n        self._block_transform = None\n    else:\n        default_output_halo = {\n            t.id: {\n                a.id: Halo(a.halo, a.halo)\n                for a in t.axes\n                if isinstance(a, v0_5.WithHalo)\n            }\n            for t in model_description.outputs\n        }\n        self._default_input_halo = get_input_halo(\n            model_description, default_output_halo\n        )\n        self._block_transform = get_block_transform(model_description)\n\n    self._default_blocksize_parameter = default_blocksize_parameter\n    self._default_batch_size = default_batch_size\n\n    self._input_ids = get_member_ids(model_description.inputs)\n    self._output_ids = get_member_ids(model_description.outputs)\n\n    self._adapter: ModelAdapter = model_adapter\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.model_description","title":"model_description  <code>instance-attribute</code>","text":"<pre><code>model_description = model_description\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def __enter__(self):\n    self.load()\n    return self\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):  # type: ignore\n    self.unload()\n    return False\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.apply_postprocessing","title":"apply_postprocessing","text":"<pre><code>apply_postprocessing(sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]) -&gt; None\n</code></pre> <p>apply postprocessing in-place, also updates samples stats</p> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def apply_postprocessing(\n    self, sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]\n) -&gt; None:\n    \"\"\"apply postprocessing in-place, also updates samples stats\"\"\"\n    for op in self._postprocessing:\n        if isinstance(sample, (Sample, SampleBlockWithOrigin)):\n            op(sample)\n        elif not isinstance(op, BlockedOperator):\n            raise NotImplementedError(\n                \"block wise update of output statistics not yet implemented\"\n            )\n        else:\n            op(sample)\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.apply_preprocessing","title":"apply_preprocessing","text":"<pre><code>apply_preprocessing(sample: Union[Sample, SampleBlockWithOrigin]) -&gt; None\n</code></pre> <p>apply preprocessing in-place, also updates sample stats</p> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def apply_preprocessing(self, sample: Union[Sample, SampleBlockWithOrigin]) -&gt; None:\n    \"\"\"apply preprocessing in-place, also updates sample stats\"\"\"\n    for op in self._preprocessing:\n        op(sample)\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.get_output_sample_id","title":"get_output_sample_id","text":"<pre><code>get_output_sample_id(input_sample_id: SampleId)\n</code></pre> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def get_output_sample_id(self, input_sample_id: SampleId):\n    warnings.warn(\n        \"`PredictionPipeline.get_output_sample_id()` is deprecated and will be\"\n        + \" removed soon. Output sample id is equal to input sample id, hence this\"\n        + \" function is not needed.\"\n    )\n    return input_sample_id\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>optional step: load model onto devices before calling forward if not using it as context manager</p> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def load(self):\n    \"\"\"\n    optional step: load model onto devices before calling forward if not using it as context manager\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.predict_sample_block","title":"predict_sample_block","text":"<pre><code>predict_sample_block(sample_block: SampleBlockWithOrigin, skip_preprocessing: bool = False, skip_postprocessing: bool = False) -&gt; SampleBlock\n</code></pre> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def predict_sample_block(\n    self,\n    sample_block: SampleBlockWithOrigin,\n    skip_preprocessing: bool = False,\n    skip_postprocessing: bool = False,\n) -&gt; SampleBlock:\n    if isinstance(self.model_description, v0_4.ModelDescr):\n        raise NotImplementedError(\n            f\"predict_sample_block not implemented for model {self.model_description.format_version}\"\n        )\n    else:\n        assert self._block_transform is not None\n\n    if not skip_preprocessing:\n        self.apply_preprocessing(sample_block)\n\n    output_meta = sample_block.get_transformed_meta(self._block_transform)\n    local_output = self._adapter.forward(sample_block)\n\n    output = output_meta.with_data(local_output.members, stat=local_output.stat)\n    if not skip_postprocessing:\n        self.apply_postprocessing(output)\n\n    return output\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.predict_sample_with_blocking","title":"predict_sample_with_blocking","text":"<pre><code>predict_sample_with_blocking(sample: Sample, skip_preprocessing: bool = False, skip_postprocessing: bool = False, ns: Optional[Union[v0_5.ParameterizedSize_N, Mapping[Tuple[MemberId, AxisId], v0_5.ParameterizedSize_N]]] = None, batch_size: Optional[int] = None) -&gt; Sample\n</code></pre> <p>predict a sample by splitting it into blocks according to the model and the <code>ns</code> parameter</p> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def predict_sample_with_blocking(\n    self,\n    sample: Sample,\n    skip_preprocessing: bool = False,\n    skip_postprocessing: bool = False,\n    ns: Optional[\n        Union[\n            v0_5.ParameterizedSize_N,\n            Mapping[Tuple[MemberId, AxisId], v0_5.ParameterizedSize_N],\n        ]\n    ] = None,\n    batch_size: Optional[int] = None,\n) -&gt; Sample:\n    \"\"\"predict a sample by splitting it into blocks according to the model and the `ns` parameter\"\"\"\n\n    if isinstance(self.model_description, v0_4.ModelDescr):\n        raise NotImplementedError(\n            \"`predict_sample_with_blocking` not implemented for v0_4.ModelDescr\"\n            + f\" {self.model_description.name}.\"\n            + \" Consider using `predict_sample_with_fixed_blocking`\"\n        )\n\n    ns = ns or self._default_blocksize_parameter\n    if isinstance(ns, int):\n        ns = {\n            (ipt.id, a.id): ns\n            for ipt in self.model_description.inputs\n            for a in ipt.axes\n            if isinstance(a.size, v0_5.ParameterizedSize)\n        }\n    input_block_shape = self.model_description.get_tensor_sizes(\n        ns, batch_size or self._default_batch_size\n    ).inputs\n\n    return self.predict_sample_with_fixed_blocking(\n        sample,\n        input_block_shape=input_block_shape,\n        skip_preprocessing=skip_preprocessing,\n        skip_postprocessing=skip_postprocessing,\n    )\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.predict_sample_with_fixed_blocking","title":"predict_sample_with_fixed_blocking","text":"<pre><code>predict_sample_with_fixed_blocking(sample: Sample, input_block_shape: Mapping[MemberId, Mapping[AxisId, int]], *, skip_preprocessing: bool = False, skip_postprocessing: bool = False) -&gt; Sample\n</code></pre> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def predict_sample_with_fixed_blocking(\n    self,\n    sample: Sample,\n    input_block_shape: Mapping[MemberId, Mapping[AxisId, int]],\n    *,\n    skip_preprocessing: bool = False,\n    skip_postprocessing: bool = False,\n) -&gt; Sample:\n    if not skip_preprocessing:\n        self.apply_preprocessing(sample)\n\n    n_blocks, input_blocks = sample.split_into_blocks(\n        input_block_shape,\n        halo=self._default_input_halo,\n        pad_mode=\"reflect\",\n    )\n    input_blocks = list(input_blocks)\n    predicted_blocks: List[SampleBlock] = []\n    logger.info(\n        \"split sample shape {} into {} blocks of {}.\",\n        {k: dict(v) for k, v in sample.shape.items()},\n        n_blocks,\n        {k: dict(v) for k, v in input_block_shape.items()},\n    )\n    for b in tqdm(\n        input_blocks,\n        desc=f\"predict {sample.id or ''} with {self.model_description.id or self.model_description.name}\",\n        unit=\"block\",\n        unit_divisor=1,\n        total=n_blocks,\n    ):\n        predicted_blocks.append(\n            self.predict_sample_block(\n                b, skip_preprocessing=True, skip_postprocessing=True\n            )\n        )\n\n    predicted_sample = Sample.from_blocks(predicted_blocks)\n    if not skip_postprocessing:\n        self.apply_postprocessing(predicted_sample)\n\n    return predicted_sample\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.predict_sample_without_blocking","title":"predict_sample_without_blocking","text":"<pre><code>predict_sample_without_blocking(sample: Sample, skip_preprocessing: bool = False, skip_postprocessing: bool = False) -&gt; Sample\n</code></pre> <p>predict a sample. The sample's tensor shapes have to match the model's input tensor description. If that is not the case, consider <code>predict_sample_with_blocking</code></p> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def predict_sample_without_blocking(\n    self,\n    sample: Sample,\n    skip_preprocessing: bool = False,\n    skip_postprocessing: bool = False,\n) -&gt; Sample:\n    \"\"\"predict a sample.\n    The sample's tensor shapes have to match the model's input tensor description.\n    If that is not the case, consider `predict_sample_with_blocking`\"\"\"\n\n    if not skip_preprocessing:\n        self.apply_preprocessing(sample)\n\n    output = self._adapter.forward(sample)\n    if not skip_postprocessing:\n        self.apply_postprocessing(output)\n\n    return output\n</code></pre>"},{"location":"api/#bioimageio.core.PredictionPipeline.unload","title":"unload","text":"<pre><code>unload()\n</code></pre> <p>free any device memory in use</p> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def unload(self):\n    \"\"\"\n    free any device memory in use\n    \"\"\"\n    self._adapter.unload()\n</code></pre>"},{"location":"api/#bioimageio.core.Settings","title":"Settings","text":"<p>               Bases: <code>SpecSettings</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.Settings[Settings]\n              bioimageio.spec._internal._settings.Settings[Settings]\n\n                              bioimageio.spec._internal._settings.Settings --&gt; bioimageio.core.Settings\n                \n\n\n              click bioimageio.core.Settings href \"\" \"bioimageio.core.Settings\"\n              click bioimageio.spec._internal._settings.Settings href \"\" \"bioimageio.spec._internal._settings.Settings\"\n            </code></pre> <p>environment variables for bioimageio.spec and bioimageio.core</p> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0settings </li> </ul> <p>Attributes:</p> Name Type Description <code>CI</code> <code>Annotated[Union[bool, str], Field(alias=CI)]</code> <p>Wether or not the execution happens in a continuous integration (CI) environment.</p> <code>allow_pickle</code> <code>bool</code> <p>Sets the <code>allow_pickle</code> argument for <code>numpy.load()</code></p> <code>cache_path</code> <code>Path</code> <p>bioimageio cache location</p> <code>collection_http_pattern</code> <code>str</code> <p>A pattern to map bioimageio IDs to bioimageio.yaml URLs.</p> <code>disk_cache</code> <code>github_auth</code> <code>github_token</code> <code>Optional[str]</code> <p>GitHub token for API requests</p> <code>github_username</code> <code>Optional[str]</code> <p>GitHub username for API requests</p> <code>http_timeout</code> <code>float</code> <p>Timeout in seconds for http requests.</p> <code>huggingface_http_pattern</code> <code>str</code> <p>A pattern to map huggingface repo IDs to bioimageio.yaml URLs.</p> <code>hypha_upload</code> <code>str</code> <p>URL to the upload endpoint for bioimageio resources.</p> <code>hypha_upload_token</code> <code>Optional[str]</code> <p>Hypha API token to use for uploads.</p> <code>id_map</code> <code>str</code> <p>URL to bioimageio id_map.json to resolve resource IDs.</p> <code>id_map_draft</code> <code>str</code> <p>URL to bioimageio id_map_draft.json to resolve draft IDs ending with '/draft'.</p> <code>keras_backend</code> <code>Annotated[Literal['torch', 'tensorflow', 'jax'], Field(alias=KERAS_BACKEND)]</code> <code>log_warnings</code> <code>bool</code> <p>Log validation warnings to console.</p> <code>model_config</code> <code>perform_io_checks</code> <code>bool</code> <p>Wether or not to perform validation that requires file io,</p> <code>resolve_draft</code> <code>bool</code> <p>Flag to resolve draft resource versions following the pattern</p> <code>user_agent</code> <code>Optional[str]</code> <p>user agent for http requests</p>"},{"location":"api/#bioimageio.core.Settings.CI","title":"CI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CI: Annotated[Union[bool, str], Field(alias=CI)] = False\n</code></pre> <p>Wether or not the execution happens in a continuous integration (CI) environment.</p>"},{"location":"api/#bioimageio.core.Settings.allow_pickle","title":"allow_pickle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allow_pickle: bool = False\n</code></pre> <p>Sets the <code>allow_pickle</code> argument for <code>numpy.load()</code></p>"},{"location":"api/#bioimageio.core.Settings.cache_path","title":"cache_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache_path: Path = Path(platformdirs.user_cache_dir('bioimageio'))\n</code></pre> <p>bioimageio cache location</p>"},{"location":"api/#bioimageio.core.Settings.collection_http_pattern","title":"collection_http_pattern  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>collection_http_pattern: str = 'https://hypha.aicell.io/bioimage-io/artifacts/{bioimageio_id}/files/rdf.yaml'\n</code></pre> <p>A pattern to map bioimageio IDs to bioimageio.yaml URLs. Notes: - '{bioimageio_id}' is replaced with user query,   e.g. \"affable-shark\" when calling <code>load_description(\"affable-shark\")</code>. - This method takes precedence over resolving via <code>id_map</code>. - If this endpoints fails, we fall back to <code>id_map</code>.</p>"},{"location":"api/#bioimageio.core.Settings.disk_cache","title":"disk_cache  <code>cached</code> <code>property</code>","text":"<pre><code>disk_cache\n</code></pre>"},{"location":"api/#bioimageio.core.Settings.github_auth","title":"github_auth  <code>property</code>","text":"<pre><code>github_auth\n</code></pre>"},{"location":"api/#bioimageio.core.Settings.github_token","title":"github_token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>github_token: Optional[str] = None\n</code></pre> <p>GitHub token for API requests</p>"},{"location":"api/#bioimageio.core.Settings.github_username","title":"github_username  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>github_username: Optional[str] = None\n</code></pre> <p>GitHub username for API requests</p>"},{"location":"api/#bioimageio.core.Settings.http_timeout","title":"http_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>http_timeout: float = 10.0\n</code></pre> <p>Timeout in seconds for http requests.</p>"},{"location":"api/#bioimageio.core.Settings.huggingface_http_pattern","title":"huggingface_http_pattern  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>huggingface_http_pattern: str = 'https://huggingface.co/{repo_id}/tree/{branch}/package/bioimageio.yaml'\n</code></pre> <p>A pattern to map huggingface repo IDs to bioimageio.yaml URLs. Notes: - Used for loading source strings of the form \"huggingface/{user_or_org}/{resource_id}[/{version}]\" - example use: <code>load_description(\"huggingface/fynnbe/ambitious-sloth/1.3\")</code> - A given version {version} is mapped to a branch name \"v{version}\", e.g. \"v1.3\". - If no version is provided the \"main\" branch is used. - This method takes precedence over resolving via <code>id_map</code>. - If this endpoints fails, we fall back to <code>id_map</code>.</p>"},{"location":"api/#bioimageio.core.Settings.hypha_upload","title":"hypha_upload  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hypha_upload: str = 'https://hypha.aicell.io/public/services/artifact-manager/create'\n</code></pre> <p>URL to the upload endpoint for bioimageio resources.</p>"},{"location":"api/#bioimageio.core.Settings.hypha_upload_token","title":"hypha_upload_token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hypha_upload_token: Optional[str] = None\n</code></pre> <p>Hypha API token to use for uploads.</p> <p>By setting this token you agree to our terms of service at https://bioimage.io/#/toc.</p> How to obtain a token <ol> <li>Login to https://bioimage.io</li> <li>Generate a new token at https://bioimage.io/#/api?tab=hypha-rpc</li> </ol>"},{"location":"api/#bioimageio.core.Settings.id_map","title":"id_map  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id_map: str = 'https://uk1s3.embassy.ebi.ac.uk/public-datasets/bioimage.io/id_map.json'\n</code></pre> <p>URL to bioimageio id_map.json to resolve resource IDs.</p>"},{"location":"api/#bioimageio.core.Settings.id_map_draft","title":"id_map_draft  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id_map_draft: str = 'https://uk1s3.embassy.ebi.ac.uk/public-datasets/bioimage.io/id_map_draft.json'\n</code></pre> <p>URL to bioimageio id_map_draft.json to resolve draft IDs ending with '/draft'.</p>"},{"location":"api/#bioimageio.core.Settings.keras_backend","title":"keras_backend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keras_backend: Annotated[Literal['torch', 'tensorflow', 'jax'], Field(alias=KERAS_BACKEND)] = 'torch'\n</code></pre>"},{"location":"api/#bioimageio.core.Settings.log_warnings","title":"log_warnings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_warnings: bool = True\n</code></pre> <p>Log validation warnings to console.</p>"},{"location":"api/#bioimageio.core.Settings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(env_prefix='BIOIMAGEIO_', env_file='.env', env_file_encoding='utf-8')\n</code></pre>"},{"location":"api/#bioimageio.core.Settings.perform_io_checks","title":"perform_io_checks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>perform_io_checks: bool = True\n</code></pre> <p>Wether or not to perform validation that requires file io, e.g. downloading a remote files.</p> <p>Existence of any local absolute file paths is still being checked.</p>"},{"location":"api/#bioimageio.core.Settings.resolve_draft","title":"resolve_draft  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resolve_draft: bool = True\n</code></pre> <p>Flag to resolve draft resource versions following the pattern /draft. <p>Note that anyone may stage a new draft and that such a draft version may not have been reviewed yet. Set this flag to False to avoid this potential security risk and disallow loading draft versions.</p>"},{"location":"api/#bioimageio.core.Settings.user_agent","title":"user_agent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_agent: Optional[str] = None\n</code></pre> <p>user agent for http requests</p>"},{"location":"api/#bioimageio.core.create_prediction_pipeline","title":"create_prediction_pipeline","text":"<pre><code>create_prediction_pipeline(bioimageio_model: AnyModelDescr, *, devices: Optional[Sequence[str]] = None, weight_format: Optional[SupportedWeightsFormat] = None, weights_format: Optional[SupportedWeightsFormat] = None, dataset_for_initial_statistics: Iterable[Union[Sample, Sequence[Tensor]]] = tuple(), keep_updating_initial_dataset_statistics: bool = False, fixed_dataset_statistics: Mapping[DatasetMeasure, MeasureValue] = MappingProxyType({}), model_adapter: Optional[ModelAdapter] = None, ns: Optional[BlocksizeParameter] = None, default_blocksize_parameter: BlocksizeParameter = 10, **deprecated_kwargs: Any) -&gt; PredictionPipeline\n</code></pre> <p>Creates prediction pipeline which includes: * computation of input statistics * preprocessing * model prediction * computation of output statistics * postprocessing</p> <p>Parameters:</p> Name Type Description Default <code>AnyModelDescr</code> <p>A bioimageio model description.</p> required <code>Optional[Sequence[str]]</code> <p>(optional)</p> <code>None</code> <code>Optional[SupportedWeightsFormat]</code> <p>deprecated in favor of weights_format</p> <code>None</code> <code>Optional[SupportedWeightsFormat]</code> <p>(optional) Use a specific weights_format rather than choosing one automatically. A corresponding <code>bioimageio.core.model_adapters.ModelAdapter</code> will be created to run inference with the bioimageio_model.</p> <code>None</code> <code>Iterable[Union[Sample, Sequence[Tensor]]]</code> <p>(optional) If preprocessing steps require input dataset statistics, dataset_for_initial_statistics allows you to specifcy a dataset from which these statistics are computed.</p> <code>tuple()</code> <code>bool</code> <p>(optional) Set to <code>True</code> if you want to update dataset statistics with each processed sample.</p> <code>False</code> <code>Mapping[DatasetMeasure, MeasureValue]</code> <p>(optional) Allows you to specify a mapping of <code>DatasetMeasure</code>s to precomputed <code>MeasureValue</code>s.</p> <code>MappingProxyType({})</code> <code>Optional[ModelAdapter]</code> <p>(optional) Allows you to use a custom model_adapter instead of creating one according to the present/selected weights_format.</p> <code>None</code> <code>Optional[BlocksizeParameter]</code> <p>deprecated in favor of default_blocksize_parameter</p> <code>None</code> <code>BlocksizeParameter</code> <p>Allows to control the default block size for blockwise predictions, see <code>BlocksizeParameter</code>.</p> <code>10</code> Source code in <code>src/bioimageio/core/_prediction_pipeline.py</code> <pre><code>def create_prediction_pipeline(\n    bioimageio_model: AnyModelDescr,\n    *,\n    devices: Optional[Sequence[str]] = None,\n    weight_format: Optional[SupportedWeightsFormat] = None,\n    weights_format: Optional[SupportedWeightsFormat] = None,\n    dataset_for_initial_statistics: Iterable[Union[Sample, Sequence[Tensor]]] = tuple(),\n    keep_updating_initial_dataset_statistics: bool = False,\n    fixed_dataset_statistics: Mapping[DatasetMeasure, MeasureValue] = MappingProxyType(\n        {}\n    ),\n    model_adapter: Optional[ModelAdapter] = None,\n    ns: Optional[BlocksizeParameter] = None,\n    default_blocksize_parameter: BlocksizeParameter = 10,\n    **deprecated_kwargs: Any,\n) -&gt; PredictionPipeline:\n    \"\"\"\n    Creates prediction pipeline which includes:\n    * computation of input statistics\n    * preprocessing\n    * model prediction\n    * computation of output statistics\n    * postprocessing\n\n    Args:\n        bioimageio_model: A bioimageio model description.\n        devices: (optional)\n        weight_format: deprecated in favor of **weights_format**\n        weights_format: (optional) Use a specific **weights_format** rather than\n            choosing one automatically.\n            A corresponding `bioimageio.core.model_adapters.ModelAdapter` will be\n            created to run inference with the **bioimageio_model**.\n        dataset_for_initial_statistics: (optional) If preprocessing steps require input\n            dataset statistics, **dataset_for_initial_statistics** allows you to\n            specifcy a dataset from which these statistics are computed.\n        keep_updating_initial_dataset_statistics: (optional) Set to `True` if you want\n            to update dataset statistics with each processed sample.\n        fixed_dataset_statistics: (optional) Allows you to specify a mapping of\n            `DatasetMeasure`s to precomputed `MeasureValue`s.\n        model_adapter: (optional) Allows you to use a custom **model_adapter** instead\n            of creating one according to the present/selected **weights_format**.\n        ns: deprecated in favor of **default_blocksize_parameter**\n        default_blocksize_parameter: Allows to control the default block size for\n            blockwise predictions, see `BlocksizeParameter`.\n\n    \"\"\"\n    weights_format = weight_format or weights_format\n    del weight_format\n    default_blocksize_parameter = ns or default_blocksize_parameter\n    del ns\n    if deprecated_kwargs:\n        warnings.warn(\n            f\"deprecated create_prediction_pipeline kwargs: {set(deprecated_kwargs)}\"\n        )\n\n    model_adapter = model_adapter or create_model_adapter(\n        model_description=bioimageio_model,\n        devices=devices,\n        weight_format_priority_order=weights_format and (weights_format,),\n    )\n\n    input_ids = get_member_ids(bioimageio_model.inputs)\n\n    def dataset():\n        common_stat: Stat = {}\n        for i, x in enumerate(dataset_for_initial_statistics):\n            if isinstance(x, Sample):\n                yield x\n            else:\n                yield Sample(members=dict(zip(input_ids, x)), stat=common_stat, id=i)\n\n    preprocessing, postprocessing = setup_pre_and_postprocessing(\n        bioimageio_model,\n        dataset(),\n        keep_updating_initial_dataset_stats=keep_updating_initial_dataset_statistics,\n        fixed_dataset_stats=fixed_dataset_statistics,\n    )\n\n    return PredictionPipeline(\n        name=bioimageio_model.name,\n        model_description=bioimageio_model,\n        model_adapter=model_adapter,\n        preprocessing=preprocessing,\n        postprocessing=postprocessing,\n        default_blocksize_parameter=default_blocksize_parameter,\n    )\n</code></pre>"},{"location":"api/#bioimageio.core.create_prediction_pipeline(bioimageio_model)","title":"<code>bioimageio_model</code>","text":""},{"location":"api/#bioimageio.core.create_prediction_pipeline(devices)","title":"<code>devices</code>","text":""},{"location":"api/#bioimageio.core.create_prediction_pipeline(weight_format)","title":"<code>weight_format</code>","text":""},{"location":"api/#bioimageio.core.create_prediction_pipeline(weights_format)","title":"<code>weights_format</code>","text":""},{"location":"api/#bioimageio.core.create_prediction_pipeline(dataset_for_initial_statistics)","title":"<code>dataset_for_initial_statistics</code>","text":""},{"location":"api/#bioimageio.core.create_prediction_pipeline(keep_updating_initial_dataset_statistics)","title":"<code>keep_updating_initial_dataset_statistics</code>","text":""},{"location":"api/#bioimageio.core.create_prediction_pipeline(fixed_dataset_statistics)","title":"<code>fixed_dataset_statistics</code>","text":""},{"location":"api/#bioimageio.core.create_prediction_pipeline(model_adapter)","title":"<code>model_adapter</code>","text":""},{"location":"api/#bioimageio.core.create_prediction_pipeline(ns)","title":"<code>ns</code>","text":""},{"location":"api/#bioimageio.core.create_prediction_pipeline(default_blocksize_parameter)","title":"<code>default_blocksize_parameter</code>","text":""},{"location":"api/#bioimageio.core.enable_determinism","title":"enable_determinism","text":"<pre><code>enable_determinism(mode: Literal['seed_only', 'full'] = 'full', weight_formats: Optional[Sequence[SupportedWeightsFormat]] = None)\n</code></pre> <p>Seed and configure ML frameworks for maximum reproducibility. May degrade performance. Only recommended for testing reproducibility!</p> <p>Seed any random generators and (if mode==\"full\") request ML frameworks to use deterministic algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['seed_only', 'full']</code> <p>determinism mode - 'seed_only' -- only set seeds, or - 'full' determinsm features (might degrade performance or throw exceptions)</p> <code>'full'</code> <code>Optional[Sequence[SupportedWeightsFormat]]</code> <p>Limit deep learning importing deep learning frameworks based on weight_formats. E.g. this allows to avoid importing tensorflow when testing with pytorch.</p> <code>None</code> Notes <ul> <li>mode == \"full\"  might degrade performance or throw exceptions.</li> <li>Subsequent inference calls might still differ. Call before each function   (sequence) that is expected to be reproducible.</li> <li>Degraded performance: Use for testing reproducibility only!</li> <li>Recipes:<ul> <li>PyTorch</li> <li>Keras</li> <li>NumPy</li> </ul> </li> </ul> Source code in <code>src/bioimageio/core/_resource_tests.py</code> <pre><code>def enable_determinism(\n    mode: Literal[\"seed_only\", \"full\"] = \"full\",\n    weight_formats: Optional[Sequence[SupportedWeightsFormat]] = None,\n):\n    \"\"\"Seed and configure ML frameworks for maximum reproducibility.\n    May degrade performance. Only recommended for testing reproducibility!\n\n    Seed any random generators and (if **mode**==\"full\") request ML frameworks to use\n    deterministic algorithms.\n\n    Args:\n        mode: determinism mode\n            - 'seed_only' -- only set seeds, or\n            - 'full' determinsm features (might degrade performance or throw exceptions)\n        weight_formats: Limit deep learning importing deep learning frameworks\n            based on weight_formats.\n            E.g. this allows to avoid importing tensorflow when testing with pytorch.\n\n    Notes:\n        - **mode** == \"full\"  might degrade performance or throw exceptions.\n        - Subsequent inference calls might still differ. Call before each function\n          (sequence) that is expected to be reproducible.\n        - Degraded performance: Use for testing reproducibility only!\n        - Recipes:\n            - [PyTorch](https://pytorch.org/docs/stable/notes/randomness.html)\n            - [Keras](https://keras.io/examples/keras_recipes/reproducibility_recipes/)\n            - [NumPy](https://numpy.org/doc/2.0/reference/random/generated/numpy.random.seed.html)\n    \"\"\"\n    try:\n        try:\n            import numpy.random\n        except ImportError:\n            pass\n        else:\n            numpy.random.seed(0)\n    except Exception as e:\n        logger.debug(str(e))\n\n    if (\n        weight_formats is None\n        or \"pytorch_state_dict\" in weight_formats\n        or \"torchscript\" in weight_formats\n    ):\n        try:\n            try:\n                import torch\n            except ImportError:\n                pass\n            else:\n                _ = torch.manual_seed(0)\n                torch.use_deterministic_algorithms(mode == \"full\")\n        except Exception as e:\n            logger.debug(str(e))\n\n    if (\n        weight_formats is None\n        or \"tensorflow_saved_model_bundle\" in weight_formats\n        or \"keras_hdf5\" in weight_formats\n    ):\n        try:\n            os.environ[\"TF_ENABLE_ONEDNN_OPTS\"] = \"0\"\n            try:\n                import tensorflow as tf  # pyright: ignore[reportMissingTypeStubs]\n            except ImportError:\n                pass\n            else:\n                tf.random.set_seed(0)\n                if mode == \"full\":\n                    tf.config.experimental.enable_op_determinism()\n                # TODO: find possibility to switch it off again??\n        except Exception as e:\n            logger.debug(str(e))\n\n    if weight_formats is None or \"keras_hdf5\" in weight_formats:\n        try:\n            try:\n                import keras  # pyright: ignore[reportMissingTypeStubs]\n            except ImportError:\n                pass\n            else:\n                keras.utils.set_random_seed(0)\n        except Exception as e:\n            logger.debug(str(e))\n</code></pre>"},{"location":"api/#bioimageio.core.enable_determinism(mode)","title":"<code>mode</code>","text":""},{"location":"api/#bioimageio.core.enable_determinism(weight_formats)","title":"<code>weight_formats</code>","text":""},{"location":"api/#bioimageio.core.load_description_and_test","title":"load_description_and_test","text":"<pre><code>load_description_and_test(source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent], *, format_version: Literal['latest'], weight_format: Optional[SupportedWeightsFormat] = None, devices: Optional[Sequence[str]] = None, determinism: Literal['seed_only', 'full'] = 'seed_only', expected_type: Literal['model'], sha256: Optional[Sha256] = None, stop_early: bool = True, **deprecated: Unpack[DeprecatedKwargs]) -&gt; Union[ModelDescr, InvalidDescr]\n</code></pre><pre><code>load_description_and_test(source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent], *, format_version: Literal['latest'], weight_format: Optional[SupportedWeightsFormat] = None, devices: Optional[Sequence[str]] = None, determinism: Literal['seed_only', 'full'] = 'seed_only', expected_type: Literal['dataset'], sha256: Optional[Sha256] = None, stop_early: bool = True, **deprecated: Unpack[DeprecatedKwargs]) -&gt; Union[DatasetDescr, InvalidDescr]\n</code></pre><pre><code>load_description_and_test(source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent], *, format_version: Literal['latest'], weight_format: Optional[SupportedWeightsFormat] = None, devices: Optional[Sequence[str]] = None, determinism: Literal['seed_only', 'full'] = 'seed_only', expected_type: Optional[str] = None, sha256: Optional[Sha256] = None, stop_early: bool = True, **deprecated: Unpack[DeprecatedKwargs]) -&gt; Union[LatestResourceDescr, InvalidDescr]\n</code></pre><pre><code>load_description_and_test(source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent], *, format_version: Union[FormatVersionPlaceholder, str] = DISCOVER, weight_format: Optional[SupportedWeightsFormat] = None, devices: Optional[Sequence[str]] = None, determinism: Literal['seed_only', 'full'] = 'seed_only', expected_type: Literal['model'], sha256: Optional[Sha256] = None, stop_early: bool = True, **deprecated: Unpack[DeprecatedKwargs]) -&gt; Union[AnyModelDescr, InvalidDescr]\n</code></pre><pre><code>load_description_and_test(source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent], *, format_version: Union[FormatVersionPlaceholder, str] = DISCOVER, weight_format: Optional[SupportedWeightsFormat] = None, devices: Optional[Sequence[str]] = None, determinism: Literal['seed_only', 'full'] = 'seed_only', expected_type: Literal['dataset'], sha256: Optional[Sha256] = None, stop_early: bool = True, **deprecated: Unpack[DeprecatedKwargs]) -&gt; Union[AnyDatasetDescr, InvalidDescr]\n</code></pre><pre><code>load_description_and_test(source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent], *, format_version: Union[FormatVersionPlaceholder, str] = DISCOVER, weight_format: Optional[SupportedWeightsFormat] = None, devices: Optional[Sequence[str]] = None, determinism: Literal['seed_only', 'full'] = 'seed_only', expected_type: Optional[str] = None, sha256: Optional[Sha256] = None, stop_early: bool = True, **deprecated: Unpack[DeprecatedKwargs]) -&gt; Union[ResourceDescr, InvalidDescr]\n</code></pre> <pre><code>load_description_and_test(source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent], *, format_version: Union[FormatVersionPlaceholder, str] = DISCOVER, weight_format: Optional[SupportedWeightsFormat] = None, devices: Optional[Sequence[str]] = None, determinism: Literal['seed_only', 'full'] = 'seed_only', expected_type: Optional[str] = None, sha256: Optional[Sha256] = None, stop_early: bool = True, **deprecated: Unpack[DeprecatedKwargs]) -&gt; Union[ResourceDescr, InvalidDescr]\n</code></pre> <p>Test a bioimage.io resource dynamically, for example run prediction of test tensors for models.</p> <p>See <code>test_description</code> for more details.</p> <p>Returns:</p> Type Description <code>Union[ResourceDescr, InvalidDescr]</code> <p>A (possibly invalid) resource description object with a populated <code>.validation_summary</code> attribute.</p> Source code in <code>src/bioimageio/core/_resource_tests.py</code> <pre><code>def load_description_and_test(\n    source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent],\n    *,\n    format_version: Union[FormatVersionPlaceholder, str] = DISCOVER,\n    weight_format: Optional[SupportedWeightsFormat] = None,\n    devices: Optional[Sequence[str]] = None,\n    determinism: Literal[\"seed_only\", \"full\"] = \"seed_only\",\n    expected_type: Optional[str] = None,\n    sha256: Optional[Sha256] = None,\n    stop_early: bool = True,\n    **deprecated: Unpack[DeprecatedKwargs],\n) -&gt; Union[ResourceDescr, InvalidDescr]:\n    \"\"\"Test a bioimage.io resource dynamically,\n    for example run prediction of test tensors for models.\n\n    See `test_description` for more details.\n\n    Returns:\n        A (possibly invalid) resource description object\n        with a populated `.validation_summary` attribute.\n    \"\"\"\n    if isinstance(source, ResourceDescrBase):\n        root = source.root\n        file_name = source.file_name\n        if (\n            (\n                format_version\n                not in (\n                    DISCOVER,\n                    source.format_version,\n                    \".\".join(source.format_version.split(\".\")[:2]),\n                )\n            )\n            or (c := source.validation_summary.details[0].context) is None\n            or not c.perform_io_checks\n        ):\n            logger.debug(\n                \"deserializing source to ensure we validate and test using format {} and perform io checks\",\n                format_version,\n            )\n            source = dump_description(source)\n    else:\n        root = Path()\n        file_name = None\n\n    if isinstance(source, ResourceDescrBase):\n        rd = source\n    elif isinstance(source, dict):\n        # check context for a given root; default to root of source\n        context = get_validation_context(\n            ValidationContext(root=root, file_name=file_name)\n        ).replace(\n            perform_io_checks=True  # make sure we perform io checks though\n        )\n\n        rd = build_description(\n            source,\n            format_version=format_version,\n            context=context,\n        )\n    else:\n        rd = load_description(\n            source, format_version=format_version, sha256=sha256, perform_io_checks=True\n        )\n\n    rd.validation_summary.env.add(\n        InstalledPackage(name=\"bioimageio.core\", version=__version__)\n    )\n\n    if expected_type is not None:\n        _test_expected_resource_type(rd, expected_type)\n\n    if isinstance(rd, (v0_4.ModelDescr, v0_5.ModelDescr)):\n        if weight_format is None:\n            weight_formats: List[SupportedWeightsFormat] = [\n                w for w, we in rd.weights if we is not None\n            ]  # pyright: ignore[reportAssignmentType]\n        else:\n            weight_formats = [weight_format]\n\n        enable_determinism(determinism, weight_formats=weight_formats)\n        for w in weight_formats:\n            _test_model_inference(rd, w, devices, stop_early=stop_early, **deprecated)\n            if stop_early and rd.validation_summary.status != \"passed\":\n                break\n\n            if not isinstance(rd, v0_4.ModelDescr):\n                _test_model_inference_parametrized(\n                    rd, w, devices, stop_early=stop_early\n                )\n                if stop_early and rd.validation_summary.status != \"passed\":\n                    break\n\n    # TODO: add execution of jupyter notebooks\n    # TODO: add more tests\n\n    return rd\n</code></pre>"},{"location":"api/#bioimageio.core.test_description","title":"test_description","text":"<pre><code>test_description(source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent], *, format_version: Union[FormatVersionPlaceholder, str] = 'discover', weight_format: Optional[SupportedWeightsFormat] = None, devices: Optional[Sequence[str]] = None, determinism: Literal['seed_only', 'full'] = 'seed_only', expected_type: Optional[str] = None, sha256: Optional[Sha256] = None, stop_early: bool = True, runtime_env: Union[Literal['currently-active', 'as-described'], Path, BioimageioCondaEnv] = 'currently-active', run_command: Callable[[Sequence[str]], None] = default_run_command, working_dir: Optional[Union[os.PathLike[str], str]] = None, **deprecated: Unpack[DeprecatedKwargs]) -&gt; ValidationSummary\n</code></pre> <p>Test a bioimage.io resource dynamically, for example run prediction of test tensors for models.</p> <p>Parameters:</p> Name Type Description Default <code>Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent]</code> <p>model description source.</p> required <code>Optional[SupportedWeightsFormat]</code> <p>Weight format to test. Default: All weight formats present in source.</p> <code>None</code> <code>Optional[Sequence[str]]</code> <p>Devices to test with, e.g. 'cpu', 'cuda'. Default (may be weight format dependent): ['cuda'] if available, ['cpu'] otherwise.</p> <code>None</code> <code>Literal['seed_only', 'full']</code> <p>Modes to improve reproducibility of test outputs.</p> <code>'seed_only'</code> <code>Optional[str]</code> <p>Assert an expected resource description <code>type</code>.</p> <code>None</code> <code>Optional[Sha256]</code> <p>Expected SHA256 value of source.     (Ignored if source already is a loaded <code>ResourceDescr</code> object.)</p> <code>None</code> <code>bool</code> <p>Do not run further subtests after a failed one.</p> <code>True</code> <code>Union[Literal['currently-active', 'as-described'], Path, BioimageioCondaEnv]</code> <p>(Experimental feature!) The Python environment to run the tests in - <code>\"currently-active\"</code>: Use active Python interpreter. - <code>\"as-described\"</code>: Use <code>bioimageio.spec.get_conda_env</code> to generate a conda     environment YAML file based on the model weights description. - A <code>BioimageioCondaEnv</code> or a path to a conda environment YAML file.     Note: The <code>bioimageio.core</code> dependency will be added automatically if not present.</p> <code>'currently-active'</code> <code>Callable[[Sequence[str]], None]</code> <p>(Experimental feature!) Function to execute (conda) terminal commands in a subprocess. The function should raise an exception if the command fails. run_command is ignored if runtime_env is <code>\"currently-active\"</code>.</p> <code>default_run_command</code> <code>Optional[Union[os.PathLike[str], str]]</code> <p>(for debugging) directory to save any temporary files (model packages, conda environments, test summaries). Defaults to a temporary directory.</p> <code>None</code> Referenced by: <ul> <li> Home Get started Finding a compatible Python environment </li> </ul> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0test_resource </li> </ul> Source code in <code>src/bioimageio/core/_resource_tests.py</code> <pre><code>def test_description(\n    source: Union[ResourceDescr, PermissiveFileSource, BioimageioYamlContent],\n    *,\n    format_version: Union[FormatVersionPlaceholder, str] = \"discover\",\n    weight_format: Optional[SupportedWeightsFormat] = None,\n    devices: Optional[Sequence[str]] = None,\n    determinism: Literal[\"seed_only\", \"full\"] = \"seed_only\",\n    expected_type: Optional[str] = None,\n    sha256: Optional[Sha256] = None,\n    stop_early: bool = True,\n    runtime_env: Union[\n        Literal[\"currently-active\", \"as-described\"], Path, BioimageioCondaEnv\n    ] = (\"currently-active\"),\n    run_command: Callable[[Sequence[str]], None] = default_run_command,\n    working_dir: Optional[Union[os.PathLike[str], str]] = None,\n    **deprecated: Unpack[DeprecatedKwargs],\n) -&gt; ValidationSummary:\n    \"\"\"Test a bioimage.io resource dynamically,\n    for example run prediction of test tensors for models.\n\n    Args:\n        source: model description source.\n        weight_format: Weight format to test.\n            Default: All weight formats present in **source**.\n        devices: Devices to test with, e.g. 'cpu', 'cuda'.\n            Default (may be weight format dependent): ['cuda'] if available, ['cpu'] otherwise.\n        determinism: Modes to improve reproducibility of test outputs.\n        expected_type: Assert an expected resource description `type`.\n        sha256: Expected SHA256 value of **source**.\n                (Ignored if **source** already is a loaded `ResourceDescr` object.)\n        stop_early: Do not run further subtests after a failed one.\n        runtime_env: (Experimental feature!) The Python environment to run the tests in\n            - `\"currently-active\"`: Use active Python interpreter.\n            - `\"as-described\"`: Use `bioimageio.spec.get_conda_env` to generate a conda\n                environment YAML file based on the model weights description.\n            - A `BioimageioCondaEnv` or a path to a conda environment YAML file.\n                Note: The `bioimageio.core` dependency will be added automatically if not present.\n        run_command: (Experimental feature!) Function to execute (conda) terminal commands in a subprocess.\n            The function should raise an exception if the command fails.\n            **run_command** is ignored if **runtime_env** is `\"currently-active\"`.\n        working_dir: (for debugging) directory to save any temporary files\n            (model packages, conda environments, test summaries).\n            Defaults to a temporary directory.\n    \"\"\"\n    if runtime_env == \"currently-active\":\n        rd = load_description_and_test(\n            source,\n            format_version=format_version,\n            weight_format=weight_format,\n            devices=devices,\n            determinism=determinism,\n            expected_type=expected_type,\n            sha256=sha256,\n            stop_early=stop_early,\n            **deprecated,\n        )\n        return rd.validation_summary\n\n    if runtime_env == \"as-described\":\n        conda_env = None\n    elif isinstance(runtime_env, (str, Path)):\n        conda_env = BioimageioCondaEnv.model_validate(read_yaml(Path(runtime_env)))\n    elif isinstance(runtime_env, BioimageioCondaEnv):\n        conda_env = runtime_env\n    else:\n        assert_never(runtime_env)\n\n    if run_command is not default_run_command:\n        try:\n            run_command([\"thiscommandshouldalwaysfail\", \"please\"])\n        except Exception:\n            pass\n        else:\n            raise RuntimeError(\n                \"given run_command does not raise an exception for a failing command\"\n            )\n\n    if working_dir is None:\n        td_kwargs: Dict[str, Any] = (\n            dict(ignore_cleanup_errors=True) if sys.version_info &gt;= (3, 10) else {}\n        )\n        working_dir_ctxt = TemporaryDirectory(**td_kwargs)\n    else:\n        working_dir_ctxt = nullcontext(working_dir)\n\n    with working_dir_ctxt as _d:\n        working_dir = Path(_d)\n\n        if isinstance(source, ResourceDescrBase):\n            descr = source\n        elif isinstance(source, dict):\n            context = get_validation_context().replace(\n                perform_io_checks=True  # make sure we perform io checks though\n            )\n\n            descr = build_description(source, context=context)\n        else:\n            descr = load_description(source, perform_io_checks=True)\n\n        if isinstance(descr, InvalidDescr):\n            return descr.validation_summary\n        elif isinstance(source, (dict, ResourceDescrBase)):\n            file_source = save_bioimageio_package(\n                descr, output_path=working_dir / \"package.zip\"\n            )\n        else:\n            file_source = source\n\n        _test_in_env(\n            file_source,\n            descr=descr,\n            working_dir=working_dir,\n            weight_format=weight_format,\n            conda_env=conda_env,\n            devices=devices,\n            determinism=determinism,\n            expected_type=expected_type,\n            sha256=sha256,\n            stop_early=stop_early,\n            run_command=run_command,\n            **deprecated,\n        )\n\n    return descr.validation_summary\n</code></pre>"},{"location":"api/#bioimageio.core.test_description(source)","title":"<code>source</code>","text":""},{"location":"api/#bioimageio.core.test_description(weight_format)","title":"<code>weight_format</code>","text":""},{"location":"api/#bioimageio.core.test_description(devices)","title":"<code>devices</code>","text":""},{"location":"api/#bioimageio.core.test_description(determinism)","title":"<code>determinism</code>","text":""},{"location":"api/#bioimageio.core.test_description(expected_type)","title":"<code>expected_type</code>","text":""},{"location":"api/#bioimageio.core.test_description(sha256)","title":"<code>sha256</code>","text":""},{"location":"api/#bioimageio.core.test_description(stop_early)","title":"<code>stop_early</code>","text":""},{"location":"api/#bioimageio.core.test_description(runtime_env)","title":"<code>runtime_env</code>","text":""},{"location":"api/#bioimageio.core.test_description(run_command)","title":"<code>run_command</code>","text":""},{"location":"api/#bioimageio.core.test_description(working_dir)","title":"<code>working_dir</code>","text":""},{"location":"api/#bioimageio.core.test_model","title":"test_model","text":"<pre><code>test_model(source: Union[v0_4.ModelDescr, v0_5.ModelDescr, PermissiveFileSource], weight_format: Optional[SupportedWeightsFormat] = None, devices: Optional[List[str]] = None, *, determinism: Literal['seed_only', 'full'] = 'seed_only', sha256: Optional[Sha256] = None, stop_early: bool = True, **deprecated: Unpack[DeprecatedKwargs]) -&gt; ValidationSummary\n</code></pre> <p>Test model inference</p> Source code in <code>src/bioimageio/core/_resource_tests.py</code> <pre><code>def test_model(\n    source: Union[v0_4.ModelDescr, v0_5.ModelDescr, PermissiveFileSource],\n    weight_format: Optional[SupportedWeightsFormat] = None,\n    devices: Optional[List[str]] = None,\n    *,\n    determinism: Literal[\"seed_only\", \"full\"] = \"seed_only\",\n    sha256: Optional[Sha256] = None,\n    stop_early: bool = True,\n    **deprecated: Unpack[DeprecatedKwargs],\n) -&gt; ValidationSummary:\n    \"\"\"Test model inference\"\"\"\n    return test_description(\n        source,\n        weight_format=weight_format,\n        devices=devices,\n        determinism=determinism,\n        expected_type=\"model\",\n        sha256=sha256,\n        stop_early=stop_early,\n        **deprecated,\n    )\n</code></pre>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>bioimageio.core</li> <li>bioimageio.core.axis</li> <li>bioimageio.core.backends</li> <li>bioimageio.core.block</li> <li>bioimageio.core.block_meta</li> <li>bioimageio.core.cli</li> <li>bioimageio.core.commands</li> <li>bioimageio.core.common</li> <li>bioimageio.core.dataset</li> <li>bioimageio.core.digest_spec</li> <li>bioimageio.core.io</li> <li>bioimageio.core.model_adapters</li> <li>bioimageio.core.prediction</li> <li>bioimageio.core.proc_ops</li> <li>bioimageio.core.proc_setup</li> <li>bioimageio.core.sample</li> <li>bioimageio.core.stat_calculators</li> <li>bioimageio.core.stat_measures</li> <li>bioimageio.core.tensor</li> <li>bioimageio.core.utils</li> <li>bioimageio.core.weight_converters</li> </ul>"},{"location":"api/bioimageio/core/axis/","title":"bioimageio.core.axis","text":""},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis","title":"axis","text":"Used by: <ul> <li> API Reference \u00a0core <ul> <li> \u00a0Axis </li> <li> \u00a0AxisId </li> </ul> </li> </ul> <p>Classes:</p> Name Description <code>Axis</code> <code>AxisDescrLike</code> <code>AxisInfo</code> <p>Attributes:</p> Name Type Description <code>AxisId</code> <p>An axis identifier, e.g. 'batch', 'channel', 'z', 'y', 'x'</p> <code>AxisLetter</code> <code>AxisLike</code> <code>BatchSize</code> <code>PerAxis</code> <code>S</code> <code>T</code>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisId","title":"AxisId  <code>module-attribute</code>","text":"<pre><code>AxisId = v0_5.AxisId\n</code></pre> <p>An axis identifier, e.g. 'batch', 'channel', 'z', 'y', 'x'</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0axis <ul> <li> <code></code>\u00a0PerAxis </li> <li> <code></code>\u00a0Axis </li> <li> <code></code>\u00a0AxisInfo </li> </ul> </li> <li> <code></code>\u00a0block_meta <code></code>\u00a0LinearAxisTransform </li> <li> <code></code>\u00a0common <code></code>\u00a0BlocksizeParameter </li> <li> <code></code>\u00a0core <code></code>\u00a0AxisId </li> <li> <code></code>\u00a0digest_spec <code></code>\u00a0get_io_sample_block_metas </li> <li> <code></code>\u00a0prediction <ul> <li> <code></code>\u00a0predict </li> <li> <code></code>\u00a0predict_many </li> </ul> </li> <li> <code></code>\u00a0proc_ops <ul> <li> <code></code>\u00a0Binarize </li> <li> <code></code>\u00a0ScaleMeanVariance </li> <li> <code></code>\u00a0Softmax </li> </ul> </li> <li> <code></code>\u00a0sample <code></code>\u00a0LinearSampleAxisTransform </li> <li> <code></code>\u00a0stat_calculators <ul> <li> <code></code>\u00a0CrickQuantilesCalculator </li> <li> <code></code>\u00a0MeanCalculator </li> <li> <code></code>\u00a0MeanQuantilesCalculator </li> <li> <code></code>\u00a0MeanVarStdCalculator </li> <li> <code></code>\u00a0SampleQuantilesCalculator </li> </ul> </li> <li> <code></code>\u00a0tensor <code></code>\u00a0Tensor </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisLetter","title":"AxisLetter  <code>module-attribute</code>","text":"<pre><code>AxisLetter = Literal['b', 'i', 't', 'c', 'z', 'y', 'x']\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisLike","title":"AxisLike  <code>module-attribute</code>","text":"<pre><code>AxisLike = Union[_AxisLikePlain, AxisDescrLike, v0_5.AnyAxis, 'Axis']\n</code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0digest_spec <code></code>\u00a0load_sample_for_model </li> <li> <code></code>\u00a0io <code></code>\u00a0load_tensor </li> <li> <code></code>\u00a0tensor <code></code>\u00a0Tensor </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.BatchSize","title":"BatchSize  <code>module-attribute</code>","text":"<pre><code>BatchSize = int\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.PerAxis","title":"PerAxis  <code>module-attribute</code>","text":"<pre><code>PerAxis = Mapping[AxisId, T]\n</code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0digest_spec <code></code>\u00a0get_block_transform </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <ul> <li> <code></code>\u00a0Block </li> <li> <code></code>\u00a0split_tensor_into_blocks </li> </ul> </li> <li> <code></code>\u00a0block_meta <ul> <li> <code></code>\u00a0BlockMeta </li> <li> <code></code>\u00a0split_multiple_shapes_into_blocks </li> <li> <code></code>\u00a0split_shape_into_blocks </li> </ul> </li> <li> <code></code>\u00a0digest_spec <ul> <li> <code></code>\u00a0get_input_halo </li> <li> <code></code>\u00a0get_io_sample_block_metas </li> </ul> </li> <li> <code></code>\u00a0sample <ul> <li> <code></code>\u00a0SampleBlock </li> <li> <code></code>\u00a0SampleBlockBase </li> <li> <code></code>\u00a0SampleBlockMeta </li> <li> <code></code>\u00a0SampleBlockWithOrigin </li> <li> <code></code>\u00a0sample_block_meta_generator </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.S","title":"S  <code>module-attribute</code>","text":"<pre><code>S = TypeVar('S', bound=str)\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0axis <code></code>\u00a0PerAxis </li> </ul>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.Axis","title":"Axis  <code>dataclass</code>","text":"<pre><code>Axis(id: AxisId, type: Literal['batch', 'channel', 'index', 'space', 'time'])\n</code></pre> Subclassed by: <ul> <li> API Reference <code></code>\u00a0axis <code></code>\u00a0AxisInfo </li> </ul> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0Axis </li> </ul> <p>Methods:</p> Name Description <code>__post_init__</code> <code>create</code> <p>Attributes:</p> Name Type Description <code>id</code> <code>AxisId</code> <code>type</code> <code>Literal['batch', 'channel', 'index', 'space', 'time']</code>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.Axis.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: AxisId\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.Axis.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['batch', 'channel', 'index', 'space', 'time']\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.Axis.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> Source code in <code>src/bioimageio/core/axis.py</code> <pre><code>def __post_init__(self):\n    if self.type == \"batch\":\n        self.id = AxisId(\"batch\")\n    elif self.type == \"channel\":\n        self.id = AxisId(\"channel\")\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.Axis.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(axis: AxisLike) -&gt; Axis\n</code></pre> Source code in <code>src/bioimageio/core/axis.py</code> <pre><code>@classmethod\ndef create(cls, axis: AxisLike) -&gt; Axis:\n    if isinstance(axis, cls):\n        return axis\n\n    if isinstance(axis, (AxisId, str)):\n        axis_id = axis\n        axis_type = _guess_axis_type(str(axis))\n    else:\n        if hasattr(axis, \"type\"):\n            axis_type = axis.type\n        else:\n            axis_type = _guess_axis_type(str(axis))\n\n        if hasattr(axis, \"id\"):\n            axis_id = axis.id\n        else:\n            axis_id = axis\n\n    return Axis(id=AxisId(axis_id), type=axis_type)\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisDescrLike","title":"AxisDescrLike","text":"<p>               Bases: <code>Protocol</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.axis.AxisDescrLike[AxisDescrLike]\n\n              \n\n              click bioimageio.core.axis.AxisDescrLike href \"\" \"bioimageio.core.axis.AxisDescrLike\"\n            </code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0axis <code></code>\u00a0AxisLike </li> </ul> <p>Attributes:</p> Name Type Description <code>id</code> <code>_AxisLikePlain</code> <code>type</code> <code>Literal['batch', 'channel', 'index', 'space', 'time']</code>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisDescrLike.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: _AxisLikePlain\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisDescrLike.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['batch', 'channel', 'index', 'space', 'time']\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisInfo","title":"AxisInfo  <code>dataclass</code>","text":"<pre><code>AxisInfo(id: AxisId, type: Literal['batch', 'channel', 'index', 'space', 'time'], maybe_singleton: bool)\n</code></pre> <p>               Bases: <code>Axis</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.axis.AxisInfo[AxisInfo]\n              bioimageio.core.axis.Axis[Axis]\n\n                              bioimageio.core.axis.Axis --&gt; bioimageio.core.axis.AxisInfo\n                \n\n\n              click bioimageio.core.axis.AxisInfo href \"\" \"bioimageio.core.axis.AxisInfo\"\n              click bioimageio.core.axis.Axis href \"\" \"bioimageio.core.axis.Axis\"\n            </code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0digest_spec <code></code>\u00a0get_axes_infos </li> </ul> <p>Methods:</p> Name Description <code>__post_init__</code> <code>create</code> <p>Attributes:</p> Name Type Description <code>id</code> <code>AxisId</code> <code>maybe_singleton</code> <code>bool</code> <code>type</code> <code>Literal['batch', 'channel', 'index', 'space', 'time']</code>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisInfo.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: AxisId\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisInfo.maybe_singleton","title":"maybe_singleton  <code>instance-attribute</code>","text":"<pre><code>maybe_singleton: bool\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisInfo.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['batch', 'channel', 'index', 'space', 'time']\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisInfo.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> Source code in <code>src/bioimageio/core/axis.py</code> <pre><code>def __post_init__(self):\n    if self.type == \"batch\":\n        self.id = AxisId(\"batch\")\n    elif self.type == \"channel\":\n        self.id = AxisId(\"channel\")\n</code></pre>"},{"location":"api/bioimageio/core/axis/#bioimageio.core.axis.AxisInfo.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(axis: AxisLike, maybe_singleton: Optional[bool] = None) -&gt; AxisInfo\n</code></pre> Source code in <code>src/bioimageio/core/axis.py</code> <pre><code>@classmethod\ndef create(cls, axis: AxisLike, maybe_singleton: Optional[bool] = None) -&gt; AxisInfo:\n    if isinstance(axis, AxisInfo):\n        return axis\n\n    axis_base = super().create(axis)\n    if maybe_singleton is None:\n        if not isinstance(axis, v0_5.AxisBase):\n            maybe_singleton = True\n        else:\n            if axis.size is None:\n                maybe_singleton = True\n            elif isinstance(axis.size, int):\n                maybe_singleton = axis.size == 1\n            elif isinstance(axis.size, v0_5.SizeReference):\n                maybe_singleton = (\n                    True  # TODO: check if singleton is ok for a `SizeReference`\n                )\n            elif isinstance(\n                axis.size, (v0_5.ParameterizedSize, v0_5.DataDependentSize)\n            ):\n                try:\n                    maybe_size_one = axis.size.validate_size(\n                        1\n                    )  # TODO: refactor validate_size() to have boolean func here\n                except ValueError:\n                    maybe_singleton = False\n                else:\n                    maybe_singleton = maybe_size_one == 1\n            else:\n                assert_never(axis.size)\n\n    return AxisInfo(\n        id=axis_base.id, type=axis_base.type, maybe_singleton=maybe_singleton\n    )\n</code></pre>"},{"location":"api/bioimageio/core/block/","title":"bioimageio.core.block","text":""},{"location":"api/bioimageio/core/block/#bioimageio.core.block","title":"block","text":"<p>Classes:</p> Name Description <code>Block</code> <p>A block/tile of a (larger) tensor</p> <p>Functions:</p> Name Description <code>split_tensor_into_blocks</code> <p>divide a sample tensor into tensor blocks.</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block","title":"Block  <code>dataclass</code>","text":"<pre><code>Block(sample_shape: PerAxis[int], inner_slice: PerAxis[SliceInfo], halo: PerAxis[Halo], block_index: BlockIndex, blocks_in_sample: TotalNumberOfBlocks, data: Tensor)\n</code></pre> <p>               Bases: <code>BlockMeta</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.block.Block[Block]\n              bioimageio.core.block_meta.BlockMeta[BlockMeta]\n\n                              bioimageio.core.block_meta.BlockMeta --&gt; bioimageio.core.block.Block\n                \n\n\n              click bioimageio.core.block.Block href \"\" \"bioimageio.core.block.Block\"\n              click bioimageio.core.block_meta.BlockMeta href \"\" \"bioimageio.core.block_meta.BlockMeta\"\n            </code></pre> <p>A block/tile of a (larger) tensor</p> Returned by: <ul> <li> API Reference <code></code>\u00a0block <code></code>\u00a0split_tensor_into_blocks </li> </ul> Subclassed by: <ul> <li> API Reference <code></code>\u00a0sample <code></code>\u00a0SampleBlock </li> </ul> Used by: <ul> <li> API Reference <code></code>\u00a0sample <code></code>\u00a0BlockT </li> </ul> <p>Methods:</p> Name Description <code>__post_init__</code> <code>from_meta</code> <code>from_sample_member</code> <code>get_transformed</code> <p>Attributes:</p> Name Type Description <code>block_index</code> <code>BlockIndex</code> <p>the i-th block of the sample</p> <code>blocks_in_sample</code> <code>TotalNumberOfBlocks</code> <p>total number of blocks in the sample</p> <code>data</code> <code>Tensor</code> <p>the block's tensor, e.g. a (padded) slice of some larger, original tensor</p> <code>dims</code> <code>Collection[AxisId]</code> <code>halo</code> <code>PerAxis[Halo]</code> <p>halo enlarging the inner region to the block's sizes</p> <code>inner_data</code> <code>inner_shape</code> <code>PerAxis[int]</code> <p>axis lengths of the inner region (without halo)</p> <code>inner_slice</code> <code>PerAxis[SliceInfo]</code> <p>inner region (without halo) wrt the sample</p> <code>inner_slice_wo_overlap</code> <code>PerAxis[SliceInfo]</code> <p>subslice of the inner slice, such that all <code>inner_slice_wo_overlap</code> can be</p> <code>local_slice</code> <code>PerAxis[SliceInfo]</code> <p>inner slice wrt the block, not the sample</p> <code>outer_slice</code> <code>PerAxis[SliceInfo]</code> <p>slice of the outer block (without padding) wrt the sample</p> <code>padding</code> <code>PerAxis[PadWidth]</code> <p>padding to realize the halo at the sample edge</p> <code>sample_shape</code> <code>PerAxis[int]</code> <p>the axis sizes of the whole (unblocked) sample</p> <code>shape</code> <code>PerAxis[int]</code> <p>axis lengths of the block</p> <code>tagged_shape</code> <code>PerAxis[int]</code> <p>alias for shape</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.block_index","title":"block_index  <code>instance-attribute</code>","text":"<pre><code>block_index: BlockIndex\n</code></pre> <p>the i-th block of the sample</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.blocks_in_sample","title":"blocks_in_sample  <code>instance-attribute</code>","text":"<pre><code>blocks_in_sample: TotalNumberOfBlocks\n</code></pre> <p>total number of blocks in the sample</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: Tensor\n</code></pre> <p>the block's tensor, e.g. a (padded) slice of some larger, original tensor</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: Collection[AxisId]\n</code></pre>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.halo","title":"halo  <code>instance-attribute</code>","text":"<pre><code>halo: PerAxis[Halo]\n</code></pre> <p>halo enlarging the inner region to the block's sizes</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.inner_data","title":"inner_data  <code>property</code>","text":"<pre><code>inner_data\n</code></pre>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.inner_shape","title":"inner_shape  <code>cached</code> <code>property</code>","text":"<pre><code>inner_shape: PerAxis[int]\n</code></pre> <p>axis lengths of the inner region (without halo)</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.inner_slice","title":"inner_slice  <code>instance-attribute</code>","text":"<pre><code>inner_slice: PerAxis[SliceInfo]\n</code></pre> <p>inner region (without halo) wrt the sample</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.inner_slice_wo_overlap","title":"inner_slice_wo_overlap  <code>property</code>","text":"<pre><code>inner_slice_wo_overlap: PerAxis[SliceInfo]\n</code></pre> <p>subslice of the inner slice, such that all <code>inner_slice_wo_overlap</code> can be stiched together trivially to form the original sample.</p> <p>This can also be used to calculate statistics without overrepresenting block edge regions.</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.local_slice","title":"local_slice  <code>cached</code> <code>property</code>","text":"<pre><code>local_slice: PerAxis[SliceInfo]\n</code></pre> <p>inner slice wrt the block, not the sample</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.outer_slice","title":"outer_slice  <code>cached</code> <code>property</code>","text":"<pre><code>outer_slice: PerAxis[SliceInfo]\n</code></pre> <p>slice of the outer block (without padding) wrt the sample</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.padding","title":"padding  <code>cached</code> <code>property</code>","text":"<pre><code>padding: PerAxis[PadWidth]\n</code></pre> <p>padding to realize the halo at the sample edge where we cannot simply enlarge the inner slice</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.sample_shape","title":"sample_shape  <code>instance-attribute</code>","text":"<pre><code>sample_shape: PerAxis[int]\n</code></pre> <p>the axis sizes of the whole (unblocked) sample</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.shape","title":"shape  <code>cached</code> <code>property</code>","text":"<pre><code>shape: PerAxis[int]\n</code></pre> <p>axis lengths of the block</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.tagged_shape","title":"tagged_shape  <code>property</code>","text":"<pre><code>tagged_shape: PerAxis[int]\n</code></pre> <p>alias for shape</p>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> Source code in <code>src/bioimageio/core/block.py</code> <pre><code>def __post_init__(self):\n    super().__post_init__()\n    assert not any(v == -1 for v in self.sample_shape.values()), self.sample_shape\n    for a, s in self.data.sizes.items():\n        slice_ = self.inner_slice[a]\n        halo = self.halo.get(a, Halo(0, 0))\n        assert s == halo.left + (slice_.stop - slice_.start) + halo.right, (\n            s,\n            slice_,\n            halo,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.from_meta","title":"from_meta  <code>classmethod</code>","text":"<pre><code>from_meta(meta: BlockMeta, data: Tensor) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/block.py</code> <pre><code>@classmethod\ndef from_meta(cls, meta: BlockMeta, data: Tensor) -&gt; Self:\n    return cls(\n        sample_shape={\n            k: data.tagged_shape[k] if v == -1 else v\n            for k, v in meta.sample_shape.items()\n        },\n        inner_slice={\n            k: (\n                SliceInfo(start=v.start, stop=data.tagged_shape[k])\n                if v.stop == -1\n                else v\n            )\n            for k, v in meta.inner_slice.items()\n        },\n        halo=meta.halo,\n        block_index=meta.block_index,\n        blocks_in_sample=meta.blocks_in_sample,\n        data=data,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.from_sample_member","title":"from_sample_member  <code>classmethod</code>","text":"<pre><code>from_sample_member(sample_member: Tensor, block: BlockMeta, *, pad_mode: PadMode) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/block.py</code> <pre><code>@classmethod\ndef from_sample_member(\n    cls,\n    sample_member: Tensor,\n    block: BlockMeta,\n    *,\n    pad_mode: PadMode,\n) -&gt; Self:\n    return cls(\n        data=sample_member[block.outer_slice].pad(block.padding, pad_mode),\n        sample_shape=sample_member.tagged_shape,\n        inner_slice=block.inner_slice,\n        halo=block.halo,\n        block_index=block.block_index,\n        blocks_in_sample=block.blocks_in_sample,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.Block.get_transformed","title":"get_transformed","text":"<pre><code>get_transformed(new_axes: PerAxis[Union[LinearAxisTransform, int]]) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/block.py</code> <pre><code>def get_transformed(\n    self, new_axes: PerAxis[Union[LinearAxisTransform, int]]\n) -&gt; Self:\n    raise NotImplementedError\n</code></pre>"},{"location":"api/bioimageio/core/block/#bioimageio.core.block.split_tensor_into_blocks","title":"split_tensor_into_blocks","text":"<pre><code>split_tensor_into_blocks(tensor: Tensor, block_shape: PerAxis[int], *, halo: PerAxis[HaloLike], stride: Optional[PerAxis[int]] = None, pad_mode: PadMode) -&gt; Tuple[TotalNumberOfBlocks, Generator[Block, Any, None]]\n</code></pre> <p>divide a sample tensor into tensor blocks.</p> Source code in <code>src/bioimageio/core/block.py</code> <pre><code>def split_tensor_into_blocks(\n    tensor: Tensor,\n    block_shape: PerAxis[int],\n    *,\n    halo: PerAxis[HaloLike],\n    stride: Optional[PerAxis[int]] = None,\n    pad_mode: PadMode,\n) -&gt; Tuple[TotalNumberOfBlocks, Generator[Block, Any, None]]:\n    \"\"\"divide a sample tensor into tensor blocks.\"\"\"\n    n_blocks, block_gen = split_shape_into_blocks(\n        tensor.tagged_shape, block_shape=block_shape, halo=halo, stride=stride\n    )\n    return n_blocks, _block_generator(tensor, block_gen, pad_mode=pad_mode)\n</code></pre>"},{"location":"api/bioimageio/core/block_meta/","title":"bioimageio.core.block_meta","text":""},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta","title":"block_meta","text":"Used by: <ul> <li> API Reference \u00a0core \u00a0BlockMeta </li> </ul> <p>Classes:</p> Name Description <code>BlockMeta</code> <p>Block meta data of a sample member (a tensor in a sample)</p> <code>LinearAxisTransform</code> <p>Functions:</p> Name Description <code>split_multiple_shapes_into_blocks</code> <code>split_shape_into_blocks</code>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta","title":"BlockMeta  <code>dataclass</code>","text":"<pre><code>BlockMeta(sample_shape: PerAxis[int], inner_slice: PerAxis[SliceInfo], halo: PerAxis[Halo], block_index: BlockIndex, blocks_in_sample: TotalNumberOfBlocks)\n</code></pre> <p>Block meta data of a sample member (a tensor in a sample)</p> <p>Figure for illustration: The first 2d block (dashed) of a sample member (bold). The inner slice (thin) is expanded by a halo in both dimensions on both sides. The outer slice reaches from the sample member origin (0, 0) to the right halo point.</p> <pre><code>first block (at the sample origin)\n\u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500\u2510\n\u2577 halo(left)                         \u2577\n\u2577         padding outside the sample \u2577\n\u2577  (0, 0)\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2794\n\u2577        \u2503                 \u2502         \u2577  sample member\n\u2577        \u2503      inner      \u2502  outer  \u2577\n\u2577        \u2503      region     \u2502  region \u2577\n\u2577        \u2503      /slice     \u2502  /slice \u2577\n\u2577        \u2503                 \u2502         \u2577\n\u2577        \u2523\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2577\n\u2577        \u2503   outer region/slice      \u2577\n\u2577        \u2503               halo(right) \u2577\n\u2514 \u2500 \u2500 \u2500 \u2500\u2503\u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500\u2518\n         \u2b07\n</code></pre> <p>Note: - Inner and outer slices are specified in sample member coordinates. - The outer_slice of a block at the sample edge may overlap by more than the     halo with the neighboring block (the inner slices will not overlap though).</p> Returned by: <ul> <li> API Reference <code></code>\u00a0block_meta <ul> <li> <code></code>\u00a0split_multiple_shapes_into_blocks </li> <li> <code></code>\u00a0split_shape_into_blocks </li> </ul> </li> </ul> Subclassed by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <code></code>\u00a0Block </li> <li> <code></code>\u00a0sample <code></code>\u00a0SampleBlockMeta </li> </ul> </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0core <code></code>\u00a0BlockMeta </li> <li> <code></code>\u00a0sample <ul> <li> <code></code>\u00a0BlockT </li> <li> <code></code>\u00a0sample_block_generator </li> <li> <code></code>\u00a0sample_block_meta_generator </li> </ul> </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__post_init__</code> <code>get_transformed</code> <p>Attributes:</p> Name Type Description <code>block_index</code> <code>BlockIndex</code> <p>the i-th block of the sample</p> <code>blocks_in_sample</code> <code>TotalNumberOfBlocks</code> <p>total number of blocks in the sample</p> <code>dims</code> <code>Collection[AxisId]</code> <code>halo</code> <code>PerAxis[Halo]</code> <p>halo enlarging the inner region to the block's sizes</p> <code>inner_shape</code> <code>PerAxis[int]</code> <p>axis lengths of the inner region (without halo)</p> <code>inner_slice</code> <code>PerAxis[SliceInfo]</code> <p>inner region (without halo) wrt the sample</p> <code>inner_slice_wo_overlap</code> <code>PerAxis[SliceInfo]</code> <p>subslice of the inner slice, such that all <code>inner_slice_wo_overlap</code> can be</p> <code>local_slice</code> <code>PerAxis[SliceInfo]</code> <p>inner slice wrt the block, not the sample</p> <code>outer_slice</code> <code>PerAxis[SliceInfo]</code> <p>slice of the outer block (without padding) wrt the sample</p> <code>padding</code> <code>PerAxis[PadWidth]</code> <p>padding to realize the halo at the sample edge</p> <code>sample_shape</code> <code>PerAxis[int]</code> <p>the axis sizes of the whole (unblocked) sample</p> <code>shape</code> <code>PerAxis[int]</code> <p>axis lengths of the block</p> <code>tagged_shape</code> <code>PerAxis[int]</code> <p>alias for shape</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.block_index","title":"block_index  <code>instance-attribute</code>","text":"<pre><code>block_index: BlockIndex\n</code></pre> <p>the i-th block of the sample</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.blocks_in_sample","title":"blocks_in_sample  <code>instance-attribute</code>","text":"<pre><code>blocks_in_sample: TotalNumberOfBlocks\n</code></pre> <p>total number of blocks in the sample</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: Collection[AxisId]\n</code></pre>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.halo","title":"halo  <code>instance-attribute</code>","text":"<pre><code>halo: PerAxis[Halo]\n</code></pre> <p>halo enlarging the inner region to the block's sizes</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.inner_shape","title":"inner_shape  <code>cached</code> <code>property</code>","text":"<pre><code>inner_shape: PerAxis[int]\n</code></pre> <p>axis lengths of the inner region (without halo)</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.inner_slice","title":"inner_slice  <code>instance-attribute</code>","text":"<pre><code>inner_slice: PerAxis[SliceInfo]\n</code></pre> <p>inner region (without halo) wrt the sample</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.inner_slice_wo_overlap","title":"inner_slice_wo_overlap  <code>property</code>","text":"<pre><code>inner_slice_wo_overlap: PerAxis[SliceInfo]\n</code></pre> <p>subslice of the inner slice, such that all <code>inner_slice_wo_overlap</code> can be stiched together trivially to form the original sample.</p> <p>This can also be used to calculate statistics without overrepresenting block edge regions.</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.local_slice","title":"local_slice  <code>cached</code> <code>property</code>","text":"<pre><code>local_slice: PerAxis[SliceInfo]\n</code></pre> <p>inner slice wrt the block, not the sample</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.outer_slice","title":"outer_slice  <code>cached</code> <code>property</code>","text":"<pre><code>outer_slice: PerAxis[SliceInfo]\n</code></pre> <p>slice of the outer block (without padding) wrt the sample</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.padding","title":"padding  <code>cached</code> <code>property</code>","text":"<pre><code>padding: PerAxis[PadWidth]\n</code></pre> <p>padding to realize the halo at the sample edge where we cannot simply enlarge the inner slice</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.sample_shape","title":"sample_shape  <code>instance-attribute</code>","text":"<pre><code>sample_shape: PerAxis[int]\n</code></pre> <p>the axis sizes of the whole (unblocked) sample</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.shape","title":"shape  <code>cached</code> <code>property</code>","text":"<pre><code>shape: PerAxis[int]\n</code></pre> <p>axis lengths of the block</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.tagged_shape","title":"tagged_shape  <code>property</code>","text":"<pre><code>tagged_shape: PerAxis[int]\n</code></pre> <p>alias for shape</p>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> Source code in <code>src/bioimageio/core/block_meta.py</code> <pre><code>def __post_init__(self):\n    # freeze mutable inputs\n    if not isinstance(self.sample_shape, Frozen):\n        object.__setattr__(self, \"sample_shape\", Frozen(self.sample_shape))\n\n    if not isinstance(self.inner_slice, Frozen):\n        object.__setattr__(self, \"inner_slice\", Frozen(self.inner_slice))\n\n    if not isinstance(self.halo, Frozen):\n        object.__setattr__(self, \"halo\", Frozen(self.halo))\n\n    assert all(a in self.sample_shape for a in self.inner_slice), (\n        \"block has axes not present in sample\"\n    )\n\n    assert all(a in self.inner_slice for a in self.halo), (\n        \"halo has axes not present in block\"\n    )\n\n    if any(s &gt; self.sample_shape[a] for a, s in self.shape.items()):\n        logger.warning(\n            \"block {} larger than sample {}\", self.shape, self.sample_shape\n        )\n</code></pre>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.BlockMeta.get_transformed","title":"get_transformed","text":"<pre><code>get_transformed(new_axes: PerAxis[Union[LinearAxisTransform, int]]) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/block_meta.py</code> <pre><code>def get_transformed(\n    self, new_axes: PerAxis[Union[LinearAxisTransform, int]]\n) -&gt; Self:\n    return self.__class__(\n        sample_shape={\n            a: (\n                trf\n                if isinstance(trf, int)\n                else trf.compute(self.sample_shape[trf.axis])\n            )\n            for a, trf in new_axes.items()\n        },\n        inner_slice={\n            a: (\n                SliceInfo(0, trf)\n                if isinstance(trf, int)\n                else SliceInfo(\n                    trf.compute(self.inner_slice[trf.axis].start),\n                    trf.compute(self.inner_slice[trf.axis].stop),\n                )\n            )\n            for a, trf in new_axes.items()\n        },\n        halo={\n            a: (\n                Halo(0, 0)\n                if isinstance(trf, int)\n                else Halo(self.halo[trf.axis].left, self.halo[trf.axis].right)\n            )\n            for a, trf in new_axes.items()\n        },\n        block_index=self.block_index,\n        blocks_in_sample=self.blocks_in_sample,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.LinearAxisTransform","title":"LinearAxisTransform  <code>dataclass</code>","text":"<pre><code>LinearAxisTransform(axis: AxisId, scale: float, offset: int)\n</code></pre> Subclassed by: <ul> <li> API Reference <code></code>\u00a0sample <code></code>\u00a0LinearSampleAxisTransform </li> </ul> <p>Methods:</p> Name Description <code>compute</code> <p>Attributes:</p> Name Type Description <code>axis</code> <code>AxisId</code> <code>offset</code> <code>int</code> <code>scale</code> <code>float</code>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.LinearAxisTransform.axis","title":"axis  <code>instance-attribute</code>","text":"<pre><code>axis: AxisId\n</code></pre>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.LinearAxisTransform.offset","title":"offset  <code>instance-attribute</code>","text":"<pre><code>offset: int\n</code></pre>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.LinearAxisTransform.scale","title":"scale  <code>instance-attribute</code>","text":"<pre><code>scale: float\n</code></pre>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.LinearAxisTransform.compute","title":"compute","text":"<pre><code>compute(s: int, round: Callable[[float], int] = floor) -&gt; int\n</code></pre> Source code in <code>src/bioimageio/core/block_meta.py</code> <pre><code>def compute(self, s: int, round: Callable[[float], int] = floor) -&gt; int:\n    return round(s * self.scale) + self.offset\n</code></pre>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.split_multiple_shapes_into_blocks","title":"split_multiple_shapes_into_blocks","text":"<pre><code>split_multiple_shapes_into_blocks(shapes: PerMember[PerAxis[int]], block_shapes: PerMember[PerAxis[int]], *, halo: PerMember[PerAxis[HaloLike]], strides: Optional[PerMember[PerAxis[int]]] = None, broadcast: bool = False) -&gt; Tuple[TotalNumberOfBlocks, Iterable[PerMember[BlockMeta]]]\n</code></pre> Source code in <code>src/bioimageio/core/block_meta.py</code> <pre><code>def split_multiple_shapes_into_blocks(\n    shapes: PerMember[PerAxis[int]],\n    block_shapes: PerMember[PerAxis[int]],\n    *,\n    halo: PerMember[PerAxis[HaloLike]],\n    strides: Optional[PerMember[PerAxis[int]]] = None,\n    broadcast: bool = False,\n) -&gt; Tuple[TotalNumberOfBlocks, Iterable[PerMember[BlockMeta]]]:\n    if unknown_blocks := [t for t in block_shapes if t not in shapes]:\n        raise ValueError(\n            f\"block shape specified for unknown tensors: {unknown_blocks}.\"\n        )\n\n    if not block_shapes:\n        block_shapes = shapes\n\n    if not broadcast and (\n        missing_blocks := [t for t in shapes if t not in block_shapes]\n    ):\n        raise ValueError(\n            f\"no block shape specified for {missing_blocks}.\"\n            + \" Set `broadcast` to True if these tensors should be repeated\"\n            + \" as a whole for each block.\"\n        )\n\n    if extra_halo := [t for t in halo if t not in block_shapes]:\n        raise ValueError(\n            f\"`halo` specified for tensors without block shape: {extra_halo}.\"\n        )\n\n    if strides is None:\n        strides = {}\n\n    assert not (unknown_block := [t for t in strides if t not in block_shapes]), (\n        f\"`stride` specified for tensors without block shape: {unknown_block}\"\n    )\n\n    blocks: Dict[MemberId, Iterable[BlockMeta]] = {}\n    n_blocks: Dict[MemberId, TotalNumberOfBlocks] = {}\n    for t in block_shapes:\n        n_blocks[t], blocks[t] = split_shape_into_blocks(\n            shape=shapes[t],\n            block_shape=block_shapes[t],\n            halo=halo.get(t, {}),\n            stride=strides.get(t),\n        )\n        assert n_blocks[t] &gt; 0, n_blocks\n\n    assert len(blocks) &gt; 0, blocks\n    assert len(n_blocks) &gt; 0, n_blocks\n    unique_n_blocks = set(n_blocks.values())\n    n = max(unique_n_blocks)\n    if len(unique_n_blocks) == 2 and 1 in unique_n_blocks:\n        if not broadcast:\n            raise ValueError(\n                \"Mismatch for total number of blocks due to unsplit (single block)\"\n                + f\" tensors: {n_blocks}. Set `broadcast` to True if you want to\"\n                + \" repeat unsplit (single block) tensors.\"\n            )\n\n        blocks = {\n            t: _repeat_single_block(block_gen, n) if n_blocks[t] == 1 else block_gen\n            for t, block_gen in blocks.items()\n        }\n    elif len(unique_n_blocks) != 1:\n        raise ValueError(f\"Mismatch for total number of blocks: {n_blocks}\")\n\n    return n, _aligned_blocks_generator(n, blocks)\n</code></pre>"},{"location":"api/bioimageio/core/block_meta/#bioimageio.core.block_meta.split_shape_into_blocks","title":"split_shape_into_blocks","text":"<pre><code>split_shape_into_blocks(shape: PerAxis[int], block_shape: PerAxis[int], halo: PerAxis[HaloLike], stride: Optional[PerAxis[int]] = None) -&gt; Tuple[TotalNumberOfBlocks, Generator[BlockMeta, Any, None]]\n</code></pre> Source code in <code>src/bioimageio/core/block_meta.py</code> <pre><code>def split_shape_into_blocks(\n    shape: PerAxis[int],\n    block_shape: PerAxis[int],\n    halo: PerAxis[HaloLike],\n    stride: Optional[PerAxis[int]] = None,\n) -&gt; Tuple[TotalNumberOfBlocks, Generator[BlockMeta, Any, None]]:\n    assert all(a in shape for a in block_shape), (\n        tuple(shape),\n        set(block_shape),\n    )\n    if any(shape[a] &lt; block_shape[a] for a in block_shape):\n        # TODO: allow larger blockshape\n        raise ValueError(f\"shape {shape} is smaller than block shape {block_shape}\")\n\n    assert all(a in shape for a in halo), (tuple(shape), set(halo))\n\n    # fill in default halo (0) and block axis length (from tensor shape)\n    halo = {a: Halo.create(halo.get(a, 0)) for a in shape}\n    block_shape = {a: block_shape.get(a, s) for a, s in shape.items()}\n    if stride is None:\n        stride = {}\n\n    inner_1d_slices: Dict[AxisId, List[SliceInfo]] = {}\n    for a, s in shape.items():\n        inner_size = block_shape[a] - sum(halo[a])\n        stride_1d = stride.get(a, inner_size)\n        inner_1d_slices[a] = [\n            SliceInfo(min(p, s - inner_size), min(p + inner_size, s))\n            for p in range(0, s, stride_1d)\n        ]\n\n    n_blocks = prod(map(len, inner_1d_slices.values()))\n\n    return n_blocks, _block_meta_generator(\n        shape,\n        blocks_in_sample=n_blocks,\n        inner_1d_slices=inner_1d_slices,\n        halo=halo,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/","title":"bioimageio.core.cli","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli","title":"cli","text":"<p>bioimageio CLI</p> Some docstrings use a hair space '\u200a' <p>to place the added '(default: ...)' on a new line.</p> <p>Classes:</p> Name Description <code>AddWeightsCmd</code> <p>Add additional weights to a model description by converting from available formats.</p> <code>ArgMixin</code> <code>Bioimageio</code> <p>bioimageio - CLI for bioimage.io resources \ud83e\udd92</p> <code>CmdBase</code> <code>PackageCmd</code> <p>Save a resource's metadata with its associated files.</p> <code>PredictCmd</code> <p>Run inference on your data with a bioimage.io model.</p> <code>TestCmd</code> <p>Test a bioimageio resource (beyond meta data formatting).</p> <code>UpdateCmdBase</code> <code>UpdateFormatCmd</code> <p>Update the metadata format to the latest format version.</p> <code>UpdateHashesCmd</code> <p>Create a bioimageio.yaml description with updated file hashes.</p> <code>ValidateFormatCmd</code> <p>Validate the meta data format of a bioimageio resource.</p> <code>WithSource</code> <code>WithSummaryLogging</code> <p>Attributes:</p> Name Type Description <code>JSON_FILE</code> <code>WEIGHT_FORMAT_ALIASES</code> <code>YAML_FILE</code>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.JSON_FILE","title":"JSON_FILE  <code>module-attribute</code>","text":"<pre><code>JSON_FILE = 'bioimageio-cli.json'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WEIGHT_FORMAT_ALIASES","title":"WEIGHT_FORMAT_ALIASES  <code>module-attribute</code>","text":"<pre><code>WEIGHT_FORMAT_ALIASES = AliasChoices('weight-format', 'weights-format', 'weight_format', 'weights_format')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.YAML_FILE","title":"YAML_FILE  <code>module-attribute</code>","text":"<pre><code>YAML_FILE = 'bioimageio-cli.yaml'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd","title":"AddWeightsCmd","text":"<pre><code>AddWeightsCmd(**data: Any)\n</code></pre> <p>               Bases: <code>CmdBase</code>, <code>WithSource</code>, <code>WithSummaryLogging</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.AddWeightsCmd[AddWeightsCmd]\n              bioimageio.core.cli.CmdBase[CmdBase]\n              bioimageio.core.cli.WithSource[WithSource]\n              bioimageio.core.cli.WithSummaryLogging[WithSummaryLogging]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.CmdBase --&gt; bioimageio.core.cli.AddWeightsCmd\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.CmdBase\n                \n\n                bioimageio.core.cli.WithSource --&gt; bioimageio.core.cli.AddWeightsCmd\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSource\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n                bioimageio.core.cli.WithSummaryLogging --&gt; bioimageio.core.cli.AddWeightsCmd\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSummaryLogging\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n\n              click bioimageio.core.cli.AddWeightsCmd href \"\" \"bioimageio.core.cli.AddWeightsCmd\"\n              click bioimageio.core.cli.CmdBase href \"\" \"bioimageio.core.cli.CmdBase\"\n              click bioimageio.core.cli.WithSource href \"\" \"bioimageio.core.cli.WithSource\"\n              click bioimageio.core.cli.WithSummaryLogging href \"\" \"bioimageio.core.cli.WithSummaryLogging\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Add additional weights to a model description by converting from available formats.</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>cli_cmd</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>log</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>descr</code> <code>descr_id</code> <code>str</code> <p>a more user-friendly description id</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>output</code> <code>CliPositionalArg[Path]</code> <p>The path to write the updated model package to.</p> <code>source</code> <code>CliPositionalArg[str]</code> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file</p> <code>source_format</code> <code>Optional[SupportedWeightsFormat]</code> <p>Exclusively use these weights to convert to other formats.</p> <code>summary</code> <code>List[Union[Literal['display'], Path]]</code> <p>Display the validation summary or save it as JSON, Markdown or HTML.</p> <code>target_format</code> <code>Optional[SupportedWeightsFormat]</code> <p>Exclusively add this weight format.</p> <code>tracing</code> <code>bool</code> <p>Allow tracing when converting pytorch_state_dict to torchscript</p> <code>verbose</code> <code>bool</code> <p>Log more (error) output.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.descr","title":"descr  <code>cached</code> <code>property</code>","text":"<pre><code>descr\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.descr_id","title":"descr_id  <code>property</code>","text":"<pre><code>descr_id: str\n</code></pre> <p>a more user-friendly description id (replacing legacy ids with their nicknames)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: CliPositionalArg[Path]\n</code></pre> <p>The path to write the updated model package to.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: CliPositionalArg[str]\n</code></pre> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file or a bioimage.io resource identifier, e.g. 'affable-shark'</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.source_format","title":"source_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_format: Optional[SupportedWeightsFormat] = Field(None, alias='source-format')\n</code></pre> <p>Exclusively use these weights to convert to other formats.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: List[Union[Literal['display'], Path]] = Field(default_factory=lambda: ['display'], examples=[Path('summary.md'), Path('bioimageio_summaries/'), ['display', Path('summary.md')]])\n</code></pre> <p>Display the validation summary or save it as JSON, Markdown or HTML. The format is chosen based on the suffix: <code>.json</code>, <code>.md</code>, <code>.html</code>. If a folder is given (path w/o suffix) the summary is saved in all formats. Choose/add <code>\"display\"</code> to render the validation summary to the terminal.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.target_format","title":"target_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>target_format: Optional[SupportedWeightsFormat] = Field(None, alias='target-format')\n</code></pre> <p>Exclusively add this weight format.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.tracing","title":"tracing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tracing: bool = True\n</code></pre> <p>Allow tracing when converting pytorch_state_dict to torchscript (still uses scripting if possible).</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.verbose","title":"verbose  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verbose: bool = False\n</code></pre> <p>Log more (error) output.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.cli_cmd","title":"cli_cmd","text":"<pre><code>cli_cmd()\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def cli_cmd(self):\n    model_descr = ensure_description_is_model(self.descr)\n    if isinstance(model_descr, v0_4.ModelDescr):\n        raise TypeError(\n            f\"model format {model_descr.format_version} not supported.\"\n            + \" Please update the model first.\"\n        )\n    updated_model_descr = add_weights(\n        model_descr,\n        output_path=self.output,\n        source_format=self.source_format,\n        target_format=self.target_format,\n        verbose=self.verbose,\n        allow_tracing=self.tracing,\n    )\n    self.log(updated_model_descr)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.log","title":"log","text":"<pre><code>log(descr: Union[ResourceDescr, InvalidDescr])\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def log(self, descr: Union[ResourceDescr, InvalidDescr]):\n    _ = descr.validation_summary.log(self.summary)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.AddWeightsCmd.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin","title":"ArgMixin","text":"<pre><code>ArgMixin(**data: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0cli <ul> <li> <code></code>\u00a0WithSource </li> <li> <code></code>\u00a0WithSummaryLogging </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ArgMixin.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio","title":"Bioimageio","text":"<p>               Bases: <code>BaseSettings</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.Bioimageio[Bioimageio]\n\n              \n\n              click bioimageio.core.cli.Bioimageio href \"\" \"bioimageio.core.cli.Bioimageio\"\n            </code></pre> <p>bioimageio - CLI for bioimage.io resources \ud83e\udd92</p> <p>Methods:</p> Name Description <code>cli_cmd</code> <code>settings_customise_sources</code> <p>Attributes:</p> Name Type Description <code>add_weights</code> <code>CliSubCommand[AddWeightsCmd]</code> <p>Add additional weights to a model description by converting from available formats.</p> <code>model_config</code> <code>package</code> <code>CliSubCommand[PackageCmd]</code> <p>Package a resource</p> <code>predict</code> <code>CliSubCommand[PredictCmd]</code> <p>Predict with a model resource</p> <code>test</code> <code>CliSubCommand[TestCmd]</code> <p>Test a bioimageio resource (beyond meta data formatting)</p> <code>update_format</code> <code>CliSubCommand[UpdateFormatCmd]</code> <p>Update the metadata format</p> <code>update_hashes</code> <code>CliSubCommand[UpdateHashesCmd]</code> <p>Create a bioimageio.yaml description with updated file hashes.</p> <code>validate_format</code> <code>CliSubCommand[ValidateFormatCmd]</code> <p>Check a resource's metadata format</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.add_weights","title":"add_weights  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>add_weights: CliSubCommand[AddWeightsCmd] = Field(alias='add-weights')\n</code></pre> <p>Add additional weights to a model description by converting from available formats.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(json_file=JSON_FILE, yaml_file=YAML_FILE)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.package","title":"package  <code>instance-attribute</code>","text":"<pre><code>package: CliSubCommand[PackageCmd]\n</code></pre> <p>Package a resource</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.predict","title":"predict  <code>instance-attribute</code>","text":"<pre><code>predict: CliSubCommand[PredictCmd]\n</code></pre> <p>Predict with a model resource</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.test","title":"test  <code>instance-attribute</code>","text":"<pre><code>test: CliSubCommand[TestCmd]\n</code></pre> <p>Test a bioimageio resource (beyond meta data formatting)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.update_format","title":"update_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>update_format: CliSubCommand[UpdateFormatCmd] = Field(alias='update-format')\n</code></pre> <p>Update the metadata format</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.update_hashes","title":"update_hashes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>update_hashes: CliSubCommand[UpdateHashesCmd] = Field(alias='update-hashes')\n</code></pre> <p>Create a bioimageio.yaml description with updated file hashes.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.validate_format","title":"validate_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>validate_format: CliSubCommand[ValidateFormatCmd] = Field(alias='validate-format')\n</code></pre> <p>Check a resource's metadata format</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.cli_cmd","title":"cli_cmd","text":"<pre><code>cli_cmd() -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def cli_cmd(self) -&gt; None:\n    logger.info(\n        \"executing CLI command:\\n{}\",\n        pformat({k: v for k, v in self.model_dump().items() if v is not None}),\n    )\n    _ = CliApp.run_subcommand(self)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.Bioimageio.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]:\n    cli: CliSettingsSource[BaseSettings] = CliSettingsSource(\n        settings_cls,\n        cli_parse_args=True,\n        formatter_class=RawTextHelpFormatter,\n    )\n    sys_args = pformat(sys.argv)\n    logger.info(\"starting CLI with arguments:\\n{}\", sys_args)\n    return (\n        cli,\n        init_settings,\n        YamlConfigSettingsSource(settings_cls),\n        JsonConfigSettingsSource(settings_cls),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase","title":"CmdBase","text":"<pre><code>CmdBase(**data: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.CmdBase[CmdBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              pydantic.main.BaseModel --&gt; bioimageio.core.cli.CmdBase\n                \n\n\n              click bioimageio.core.cli.CmdBase href \"\" \"bioimageio.core.cli.CmdBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0cli <ul> <li> <code></code>\u00a0AddWeightsCmd </li> <li> <code></code>\u00a0PackageCmd </li> <li> <code></code>\u00a0PredictCmd </li> <li> <code></code>\u00a0TestCmd </li> <li> <code></code>\u00a0UpdateCmdBase </li> <li> <code></code>\u00a0ValidateFormatCmd </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.CmdBase.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd","title":"PackageCmd","text":"<pre><code>PackageCmd(**data: Any)\n</code></pre> <p>               Bases: <code>CmdBase</code>, <code>WithSource</code>, <code>WithSummaryLogging</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.PackageCmd[PackageCmd]\n              bioimageio.core.cli.CmdBase[CmdBase]\n              bioimageio.core.cli.WithSource[WithSource]\n              bioimageio.core.cli.WithSummaryLogging[WithSummaryLogging]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.CmdBase --&gt; bioimageio.core.cli.PackageCmd\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.CmdBase\n                \n\n                bioimageio.core.cli.WithSource --&gt; bioimageio.core.cli.PackageCmd\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSource\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n                bioimageio.core.cli.WithSummaryLogging --&gt; bioimageio.core.cli.PackageCmd\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSummaryLogging\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n\n              click bioimageio.core.cli.PackageCmd href \"\" \"bioimageio.core.cli.PackageCmd\"\n              click bioimageio.core.cli.CmdBase href \"\" \"bioimageio.core.cli.CmdBase\"\n              click bioimageio.core.cli.WithSource href \"\" \"bioimageio.core.cli.WithSource\"\n              click bioimageio.core.cli.WithSummaryLogging href \"\" \"bioimageio.core.cli.WithSummaryLogging\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Save a resource's metadata with its associated files.</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>cli_cmd</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>log</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>descr</code> <code>descr_id</code> <code>str</code> <p>a more user-friendly description id</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>path</code> <code>CliPositionalArg[Path]</code> <p>The path to write the (zipped) package to.</p> <code>source</code> <code>CliPositionalArg[str]</code> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file</p> <code>summary</code> <code>List[Union[Literal['display'], Path]]</code> <p>Display the validation summary or save it as JSON, Markdown or HTML.</p> <code>weight_format</code> <code>WeightFormatArgAll</code> <p>The weight format to include in the package (for model descriptions only).</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.descr","title":"descr  <code>cached</code> <code>property</code>","text":"<pre><code>descr\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.descr_id","title":"descr_id  <code>property</code>","text":"<pre><code>descr_id: str\n</code></pre> <p>a more user-friendly description id (replacing legacy ids with their nicknames)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: CliPositionalArg[Path]\n</code></pre> <p>The path to write the (zipped) package to. If it does not have a <code>.zip</code> suffix this command will save the package as an unzipped folder instead.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: CliPositionalArg[str]\n</code></pre> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file or a bioimage.io resource identifier, e.g. 'affable-shark'</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: List[Union[Literal['display'], Path]] = Field(default_factory=lambda: ['display'], examples=[Path('summary.md'), Path('bioimageio_summaries/'), ['display', Path('summary.md')]])\n</code></pre> <p>Display the validation summary or save it as JSON, Markdown or HTML. The format is chosen based on the suffix: <code>.json</code>, <code>.md</code>, <code>.html</code>. If a folder is given (path w/o suffix) the summary is saved in all formats. Choose/add <code>\"display\"</code> to render the validation summary to the terminal.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.weight_format","title":"weight_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight_format: WeightFormatArgAll = Field('all', alias='weight-format', validation_alias=WEIGHT_FORMAT_ALIASES)\n</code></pre> <p>The weight format to include in the package (for model descriptions only).</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.cli_cmd","title":"cli_cmd","text":"<pre><code>cli_cmd()\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def cli_cmd(self):\n    if isinstance(self.descr, InvalidDescr):\n        self.log(self.descr)\n        raise ValueError(f\"Invalid {self.descr.type} description.\")\n\n    sys.exit(\n        package(\n            self.descr,\n            self.path,\n            weight_format=self.weight_format,\n        )\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.log","title":"log","text":"<pre><code>log(descr: Union[ResourceDescr, InvalidDescr])\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def log(self, descr: Union[ResourceDescr, InvalidDescr]):\n    _ = descr.validation_summary.log(self.summary)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PackageCmd.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd","title":"PredictCmd","text":"<pre><code>PredictCmd(**data: Any)\n</code></pre> <p>               Bases: <code>CmdBase</code>, <code>WithSource</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.PredictCmd[PredictCmd]\n              bioimageio.core.cli.CmdBase[CmdBase]\n              bioimageio.core.cli.WithSource[WithSource]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.CmdBase --&gt; bioimageio.core.cli.PredictCmd\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.CmdBase\n                \n\n                bioimageio.core.cli.WithSource --&gt; bioimageio.core.cli.PredictCmd\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSource\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n\n              click bioimageio.core.cli.PredictCmd href \"\" \"bioimageio.core.cli.PredictCmd\"\n              click bioimageio.core.cli.CmdBase href \"\" \"bioimageio.core.cli.CmdBase\"\n              click bioimageio.core.cli.WithSource href \"\" \"bioimageio.core.cli.WithSource\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Run inference on your data with a bioimage.io model.</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>cli_cmd</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>blockwise</code> <code>bool</code> <p>process inputs blockwise</p> <code>descr</code> <code>descr_id</code> <code>str</code> <p>a more user-friendly description id</p> <code>example</code> <code>bool</code> <p>generate and run an example</p> <code>inputs</code> <code>NotEmpty[List[Union[str, NotEmpty[List[str]]]]]</code> <p>Model input sample paths (for each input tensor)</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>outputs</code> <code>Union[str, NotEmpty[Tuple[str, ...]]]</code> <p>Model output path pattern (per output tensor)</p> <code>overwrite</code> <code>bool</code> <p>allow overwriting existing output files</p> <code>preview</code> <code>bool</code> <p>preview which files would be processed</p> <code>source</code> <code>CliPositionalArg[str]</code> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file</p> <code>stats</code> <code>Annotated[Path, WithJsonSchema({type: string}), PlainSerializer(lambda p: p.as_posix(), return_type=str)]</code> <p>path to dataset statistics</p> <code>weight_format</code> <code>WeightFormatArgAny</code> <p>The weight format to use.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.blockwise","title":"blockwise  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blockwise: bool = False\n</code></pre> <p>process inputs blockwise</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.descr","title":"descr  <code>cached</code> <code>property</code>","text":"<pre><code>descr\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.descr_id","title":"descr_id  <code>property</code>","text":"<pre><code>descr_id: str\n</code></pre> <p>a more user-friendly description id (replacing legacy ids with their nicknames)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.example","title":"example  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>example: bool = False\n</code></pre> <p>generate and run an example</p> <ol> <li>downloads example model inputs</li> <li>creates a <code>{model_id}_example</code> folder</li> <li>writes input arguments to <code>{model_id}_example/bioimageio-cli.yaml</code></li> <li>executes a preview dry-run</li> <li>executes prediction with example input</li> </ol>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.inputs","title":"inputs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inputs: NotEmpty[List[Union[str, NotEmpty[List[str]]]]] = Field(default_factory=lambda: ['{input_id}/001.tif'])\n</code></pre> <p>Model input sample paths (for each input tensor)</p> <p>The input paths are expected to have shape...  - (n_samples,) or (n_samples,1) for models expecting a single input tensor  - (n_samples,) containing the substring '{input_id}', or  - (n_samples, n_model_inputs) to provide each input tensor path explicitly.</p> <p>All substrings that are replaced by metadata from the model description: - '{model_id}' - '{input_id}'</p> <p>Example inputs to process sample 'a' and 'b' for a model expecting a 'raw' and a 'mask' input tensor: --inputs=\"[[\\\"a_raw.tif\\\",\\\"a_mask.tif\\\"],[\\\"b_raw.tif\\\",\\\"b_mask.tif\\\"]]\" (Note that JSON double quotes need to be escaped.)</p> <p>Alternatively a <code>bioimageio-cli.yaml</code> (or <code>bioimageio-cli.json</code>) file may provide the arguments, e.g.: <pre><code>inputs:\n- [a_raw.tif, a_mask.tif]\n- [b_raw.tif, b_mask.tif]\n</code></pre></p> <p><code>.npy</code> and any file extension supported by imageio are supported.  Aavailable formats are listed at https://imageio.readthedocs.io/en/stable/formats/index.html#all-formats. Some formats have additional dependencies.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.outputs","title":"outputs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outputs: Union[str, NotEmpty[Tuple[str, ...]]] = 'outputs_{model_id}/{output_id}/{sample_id}.tif'\n</code></pre> <p>Model output path pattern (per output tensor)</p> <p>All substrings that are replaced: - '{model_id}' (from model description) - '{output_id}' (from model description) - '{sample_id}' (extracted from input paths)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.overwrite","title":"overwrite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>overwrite: bool = False\n</code></pre> <p>allow overwriting existing output files</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.preview","title":"preview  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>preview: bool = False\n</code></pre> <p>preview which files would be processed and what outputs would be generated.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: CliPositionalArg[str]\n</code></pre> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file or a bioimage.io resource identifier, e.g. 'affable-shark'</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.stats","title":"stats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stats: Annotated[Path, WithJsonSchema({type: string}), PlainSerializer(lambda p: p.as_posix(), return_type=str)] = Path('dataset_statistics.json')\n</code></pre> <p>path to dataset statistics (will be written if it does not exist, but the model requires statistical dataset measures)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.weight_format","title":"weight_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight_format: WeightFormatArgAny = Field('any', alias='weight-format', validation_alias=WEIGHT_FORMAT_ALIASES)\n</code></pre> <p>The weight format to use.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.cli_cmd","title":"cli_cmd","text":"<pre><code>cli_cmd()\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def cli_cmd(self):\n    if self.example:\n        return self._example()\n\n    model_descr = ensure_description_is_model(self.descr)\n\n    input_ids = get_member_ids(model_descr.inputs)\n    output_ids = get_member_ids(model_descr.outputs)\n\n    minimum_input_ids = tuple(\n        str(ipt.id) if isinstance(ipt, v0_5.InputTensorDescr) else str(ipt.name)\n        for ipt in model_descr.inputs\n        if not isinstance(ipt, v0_5.InputTensorDescr) or not ipt.optional\n    )\n    maximum_input_ids = tuple(\n        str(ipt.id) if isinstance(ipt, v0_5.InputTensorDescr) else str(ipt.name)\n        for ipt in model_descr.inputs\n    )\n\n    def expand_inputs(i: int, ipt: Union[str, Sequence[str]]) -&gt; Tuple[str, ...]:\n        if isinstance(ipt, str):\n            ipts = tuple(\n                ipt.format(model_id=self.descr_id, input_id=t) for t in input_ids\n            )\n        else:\n            ipts = tuple(\n                p.format(model_id=self.descr_id, input_id=t)\n                for t, p in zip(input_ids, ipt)\n            )\n\n        if len(set(ipts)) &lt; len(ipts):\n            if len(minimum_input_ids) == len(maximum_input_ids):\n                n = len(minimum_input_ids)\n            else:\n                n = f\"{len(minimum_input_ids)}-{len(maximum_input_ids)}\"\n\n            raise ValueError(\n                f\"[input sample #{i}] Include '{{input_id}}' in path pattern or explicitly specify {n} distinct input paths (got {ipt})\"\n            )\n\n        if len(ipts) &lt; len(minimum_input_ids):\n            raise ValueError(\n                f\"[input sample #{i}] Expected at least {len(minimum_input_ids)} inputs {minimum_input_ids}, got {ipts}\"\n            )\n\n        if len(ipts) &gt; len(maximum_input_ids):\n            raise ValueError(\n                f\"Expected at most {len(maximum_input_ids)} inputs {maximum_input_ids}, got {ipts}\"\n            )\n\n        return ipts\n\n    inputs = [expand_inputs(i, ipt) for i, ipt in enumerate(self.inputs, start=1)]\n\n    sample_paths_in = [\n        {t: Path(p) for t, p in zip(input_ids, ipts)} for ipts in inputs\n    ]\n\n    sample_ids = _get_sample_ids(sample_paths_in)\n\n    def expand_outputs():\n        if isinstance(self.outputs, str):\n            outputs = [\n                tuple(\n                    Path(\n                        self.outputs.format(\n                            model_id=self.descr_id, output_id=t, sample_id=s\n                        )\n                    )\n                    for t in output_ids\n                )\n                for s in sample_ids\n            ]\n        else:\n            outputs = [\n                tuple(\n                    Path(p.format(model_id=self.descr_id, output_id=t, sample_id=s))\n                    for t, p in zip(output_ids, self.outputs)\n                )\n                for s in sample_ids\n            ]\n        # check for distinctness and correct number within each output sample\n        for i, out in enumerate(outputs, start=1):\n            if len(set(out)) &lt; len(out):\n                raise ValueError(\n                    f\"[output sample #{i}] Include '{{output_id}}' in path pattern or explicitly specify {len(output_ids)} distinct output paths (got {out})\"\n                )\n\n            if len(out) != len(output_ids):\n                raise ValueError(\n                    f\"[output sample #{i}] Expected {len(output_ids)} outputs {output_ids}, got {out}\"\n                )\n\n        # check for distinctness across all output samples\n        all_output_paths = [p for out in outputs for p in out]\n        if len(set(all_output_paths)) &lt; len(all_output_paths):\n            raise ValueError(\n                \"Output paths are not distinct across samples. \"\n                + f\"Make sure to include '{{sample_id}}' in the output path pattern.\"\n            )\n\n        return outputs\n\n    outputs = expand_outputs()\n\n    sample_paths_out = [\n        {MemberId(t): Path(p) for t, p in zip(output_ids, out)} for out in outputs\n    ]\n\n    if not self.overwrite:\n        for sample_paths in sample_paths_out:\n            for p in sample_paths.values():\n                if p.exists():\n                    raise FileExistsError(\n                        f\"{p} already exists. use --overwrite to (re-)write outputs anyway.\"\n                    )\n    if self.preview:\n        print(\"\ud83d\udec8 bioimageio prediction preview structure:\")\n        pprint(\n            {\n                \"{sample_id}\": dict(\n                    inputs={\"{input_id}\": \"&lt;input path&gt;\"},\n                    outputs={\"{output_id}\": \"&lt;output path&gt;\"},\n                )\n            }\n        )\n        print(\"\ud83d\udd0e bioimageio prediction preview output:\")\n        pprint(\n            {\n                s: dict(\n                    inputs={t: p.as_posix() for t, p in sp_in.items()},\n                    outputs={t: p.as_posix() for t, p in sp_out.items()},\n                )\n                for s, sp_in, sp_out in zip(\n                    sample_ids, sample_paths_in, sample_paths_out\n                )\n            }\n        )\n        return\n\n    def input_dataset(stat: Stat):\n        for s, sp_in in zip(sample_ids, sample_paths_in):\n            yield load_sample_for_model(\n                model=model_descr,\n                paths=sp_in,\n                stat=stat,\n                sample_id=s,\n            )\n\n    stat: Dict[Measure, MeasureValue] = dict(\n        _get_stat(\n            model_descr, input_dataset({}), len(sample_ids), self.stats\n        ).items()\n    )\n\n    pp = create_prediction_pipeline(\n        model_descr,\n        weight_format=None if self.weight_format == \"any\" else self.weight_format,\n    )\n    predict_method = (\n        pp.predict_sample_with_blocking\n        if self.blockwise\n        else pp.predict_sample_without_blocking\n    )\n\n    for sample_in, sp_out in tqdm(\n        zip(input_dataset(dict(stat)), sample_paths_out),\n        total=len(inputs),\n        desc=f\"predict with {self.descr_id}\",\n        unit=\"sample\",\n    ):\n        sample_out = predict_method(sample_in)\n        save_sample(sp_out, sample_out)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.PredictCmd.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd","title":"TestCmd","text":"<pre><code>TestCmd(**data: Any)\n</code></pre> <p>               Bases: <code>CmdBase</code>, <code>WithSource</code>, <code>WithSummaryLogging</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.TestCmd[TestCmd]\n              bioimageio.core.cli.CmdBase[CmdBase]\n              bioimageio.core.cli.WithSource[WithSource]\n              bioimageio.core.cli.WithSummaryLogging[WithSummaryLogging]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.CmdBase --&gt; bioimageio.core.cli.TestCmd\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.CmdBase\n                \n\n                bioimageio.core.cli.WithSource --&gt; bioimageio.core.cli.TestCmd\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSource\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n                bioimageio.core.cli.WithSummaryLogging --&gt; bioimageio.core.cli.TestCmd\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSummaryLogging\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n\n              click bioimageio.core.cli.TestCmd href \"\" \"bioimageio.core.cli.TestCmd\"\n              click bioimageio.core.cli.CmdBase href \"\" \"bioimageio.core.cli.CmdBase\"\n              click bioimageio.core.cli.WithSource href \"\" \"bioimageio.core.cli.WithSource\"\n              click bioimageio.core.cli.WithSummaryLogging href \"\" \"bioimageio.core.cli.WithSummaryLogging\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Test a bioimageio resource (beyond meta data formatting).</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Referenced by: <ul> <li> API Reference <code></code>\u00a0commands <code></code>\u00a0test </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>cli_cmd</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>log</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>descr</code> <code>descr_id</code> <code>str</code> <p>a more user-friendly description id</p> <code>determinism</code> <code>Literal['seed_only', 'full']</code> <p>Modes to improve reproducibility of test outputs.</p> <code>devices</code> <code>Optional[List[str]]</code> <p>Device(s) to use for testing</p> <code>format_version</code> <code>Union[FormatVersionPlaceholder, str]</code> <p>The format version to use for testing.</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>runtime_env</code> <code>Union[Literal['currently-active', 'as-described'], Path]</code> <p>The python environment to run the tests in</p> <code>source</code> <code>CliPositionalArg[str]</code> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file</p> <code>stop_early</code> <code>bool</code> <p>Do not run further subtests after a failed one.</p> <code>summary</code> <code>List[Union[Literal['display'], Path]]</code> <p>Display the validation summary or save it as JSON, Markdown or HTML.</p> <code>weight_format</code> <code>WeightFormatArgAll</code> <p>The weight format to limit testing to.</p> <code>working_dir</code> <code>Optional[Path]</code> <p>(for debugging) Directory to save any temporary files.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.descr","title":"descr  <code>cached</code> <code>property</code>","text":"<pre><code>descr\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.descr_id","title":"descr_id  <code>property</code>","text":"<pre><code>descr_id: str\n</code></pre> <p>a more user-friendly description id (replacing legacy ids with their nicknames)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.determinism","title":"determinism  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>determinism: Literal['seed_only', 'full'] = 'seed_only'\n</code></pre> <p>Modes to improve reproducibility of test outputs.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.devices","title":"devices  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>devices: Optional[List[str]] = None\n</code></pre> <p>Device(s) to use for testing</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.format_version","title":"format_version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format_version: Union[FormatVersionPlaceholder, str] = Field('discover', alias='format-version')\n</code></pre> <p>The format version to use for testing. - 'latest': Use the latest implemented format version for the given resource type (may trigger auto updating) - 'discover': Use the format version as described in the resource description - '0.4', '0.5', ...: Use the specified format version (may trigger auto updating)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.runtime_env","title":"runtime_env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>runtime_env: Union[Literal['currently-active', 'as-described'], Path] = Field('currently-active', alias='runtime-env')\n</code></pre> <p>The python environment to run the tests in - <code>\"currently-active\"</code>: use active Python interpreter - <code>\"as-described\"</code>: generate a conda environment YAML file based on the model     weights description. - A path to a conda environment YAML.   Note: The <code>bioimageio.core</code> dependency will be added automatically if not present.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: CliPositionalArg[str]\n</code></pre> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file or a bioimage.io resource identifier, e.g. 'affable-shark'</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.stop_early","title":"stop_early  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_early: bool = Field(False, alias='stop-early', validation_alias=AliasChoices('stop-early', 'x'))\n</code></pre> <p>Do not run further subtests after a failed one.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: List[Union[Literal['display'], Path]] = Field(default_factory=lambda: ['display'], examples=[Path('summary.md'), Path('bioimageio_summaries/'), ['display', Path('summary.md')]])\n</code></pre> <p>Display the validation summary or save it as JSON, Markdown or HTML. The format is chosen based on the suffix: <code>.json</code>, <code>.md</code>, <code>.html</code>. If a folder is given (path w/o suffix) the summary is saved in all formats. Choose/add <code>\"display\"</code> to render the validation summary to the terminal.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.weight_format","title":"weight_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight_format: WeightFormatArgAll = Field('all', alias='weight-format', validation_alias=WEIGHT_FORMAT_ALIASES)\n</code></pre> <p>The weight format to limit testing to.</p> <p>(only relevant for model resources)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.working_dir","title":"working_dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>working_dir: Optional[Path] = Field(None, alias='working-dir')\n</code></pre> <p>(for debugging) Directory to save any temporary files.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.cli_cmd","title":"cli_cmd","text":"<pre><code>cli_cmd()\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def cli_cmd(self):\n    sys.exit(\n        test(\n            self.descr,\n            weight_format=self.weight_format,\n            devices=self.devices,\n            summary=self.summary,\n            runtime_env=self.runtime_env,\n            determinism=self.determinism,\n            format_version=self.format_version,\n            working_dir=self.working_dir,\n        )\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.log","title":"log","text":"<pre><code>log(descr: Union[ResourceDescr, InvalidDescr])\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def log(self, descr: Union[ResourceDescr, InvalidDescr]):\n    _ = descr.validation_summary.log(self.summary)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.TestCmd.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase","title":"UpdateCmdBase","text":"<pre><code>UpdateCmdBase(**data: Any)\n</code></pre> <p>               Bases: <code>CmdBase</code>, <code>WithSource</code>, <code>ABC</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.UpdateCmdBase[UpdateCmdBase]\n              bioimageio.core.cli.CmdBase[CmdBase]\n              bioimageio.core.cli.WithSource[WithSource]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.CmdBase --&gt; bioimageio.core.cli.UpdateCmdBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.CmdBase\n                \n\n                bioimageio.core.cli.WithSource --&gt; bioimageio.core.cli.UpdateCmdBase\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSource\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n\n              click bioimageio.core.cli.UpdateCmdBase href \"\" \"bioimageio.core.cli.UpdateCmdBase\"\n              click bioimageio.core.cli.CmdBase href \"\" \"bioimageio.core.cli.CmdBase\"\n              click bioimageio.core.cli.WithSource href \"\" \"bioimageio.core.cli.WithSource\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0cli <ul> <li> <code></code>\u00a0UpdateFormatCmd </li> <li> <code></code>\u00a0UpdateHashesCmd </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>cli_cmd</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>descr</code> <code>descr_id</code> <code>str</code> <p>a more user-friendly description id</p> <code>diff</code> <code>Union[bool, Path]</code> <p>Output a diff of original and updated bioimageio.yaml.</p> <code>exclude_defaults</code> <code>bool</code> <p>Exclude fields that have the default value (even if set explicitly).</p> <code>exclude_unset</code> <code>bool</code> <p>Exclude fields that have not explicitly be set.</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>output</code> <code>Union[Literal['display', 'stdout'], Path]</code> <p>Output updated bioimageio.yaml to the terminal or write to a file.</p> <code>source</code> <code>CliPositionalArg[str]</code> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file</p> <code>updated</code> <code>Union[ResourceDescr, InvalidDescr]</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.descr","title":"descr  <code>cached</code> <code>property</code>","text":"<pre><code>descr\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.descr_id","title":"descr_id  <code>property</code>","text":"<pre><code>descr_id: str\n</code></pre> <p>a more user-friendly description id (replacing legacy ids with their nicknames)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.diff","title":"diff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>diff: Union[bool, Path] = Field(True, alias='diff')\n</code></pre> <p>Output a diff of original and updated bioimageio.yaml. If a given path has an <code>.html</code> extension, a standalone HTML file is written, otherwise the diff is saved in unified diff format (pure text).</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.exclude_defaults","title":"exclude_defaults  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude_defaults: bool = Field(False, alias='exclude-defaults')\n</code></pre> <p>Exclude fields that have the default value (even if set explicitly).</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.exclude_unset","title":"exclude_unset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude_unset: bool = Field(True, alias='exclude-unset')\n</code></pre> <p>Exclude fields that have not explicitly be set.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: Union[Literal['display', 'stdout'], Path] = 'display'\n</code></pre> <p>Output updated bioimageio.yaml to the terminal or write to a file. Notes: - <code>\"display\"</code>: Render to the terminal with syntax highlighting. - <code>\"stdout\"</code>: Write to sys.stdout without syntax highligthing.   (More convenient for copying the updated bioimageio.yaml from the terminal.)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: CliPositionalArg[str]\n</code></pre> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file or a bioimage.io resource identifier, e.g. 'affable-shark'</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.updated","title":"updated  <code>cached</code> <code>property</code>","text":"<pre><code>updated: Union[ResourceDescr, InvalidDescr]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.cli_cmd","title":"cli_cmd","text":"<pre><code>cli_cmd()\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def cli_cmd(self):\n    original_yaml = open_bioimageio_yaml(self.source).unparsed_content\n    assert isinstance(original_yaml, str)\n    stream = StringIO()\n\n    save_bioimageio_yaml_only(\n        self.updated,\n        stream,\n        exclude_unset=self.exclude_unset,\n        exclude_defaults=self.exclude_defaults,\n    )\n    updated_yaml = stream.getvalue()\n\n    diff = compare(\n        original_yaml.split(\"\\n\"),\n        updated_yaml.split(\"\\n\"),\n        diff_format=(\n            \"html\"\n            if isinstance(self.diff, Path) and self.diff.suffix == \".html\"\n            else \"unified\"\n        ),\n    )\n\n    if isinstance(self.diff, Path):\n        _ = self.diff.write_text(diff, encoding=\"utf-8\")\n    elif self.diff:\n        console = rich.console.Console()\n        diff_md = f\"## Diff\\n\\n````````diff\\n{diff}\\n````````\"\n        console.print(rich.markdown.Markdown(diff_md))\n\n    if isinstance(self.output, Path):\n        _ = self.output.write_text(updated_yaml, encoding=\"utf-8\")\n        logger.info(f\"written updated description to {self.output}\")\n    elif self.output == \"display\":\n        updated_md = f\"## Updated bioimageio.yaml\\n\\n```yaml\\n{updated_yaml}\\n```\"\n        rich.console.Console().print(rich.markdown.Markdown(updated_md))\n    elif self.output == \"stdout\":\n        print(updated_yaml)\n    else:\n        assert_never(self.output)\n\n    if isinstance(self.updated, InvalidDescr):\n        logger.warning(\"Update resulted in invalid description\")\n        _ = self.updated.validation_summary.display()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateCmdBase.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd","title":"UpdateFormatCmd","text":"<pre><code>UpdateFormatCmd(**data: Any)\n</code></pre> <p>               Bases: <code>UpdateCmdBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.UpdateFormatCmd[UpdateFormatCmd]\n              bioimageio.core.cli.UpdateCmdBase[UpdateCmdBase]\n              bioimageio.core.cli.CmdBase[CmdBase]\n              bioimageio.core.cli.WithSource[WithSource]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.UpdateCmdBase --&gt; bioimageio.core.cli.UpdateFormatCmd\n                                bioimageio.core.cli.CmdBase --&gt; bioimageio.core.cli.UpdateCmdBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.CmdBase\n                \n\n                bioimageio.core.cli.WithSource --&gt; bioimageio.core.cli.UpdateCmdBase\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSource\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n\n\n              click bioimageio.core.cli.UpdateFormatCmd href \"\" \"bioimageio.core.cli.UpdateFormatCmd\"\n              click bioimageio.core.cli.UpdateCmdBase href \"\" \"bioimageio.core.cli.UpdateCmdBase\"\n              click bioimageio.core.cli.CmdBase href \"\" \"bioimageio.core.cli.CmdBase\"\n              click bioimageio.core.cli.WithSource href \"\" \"bioimageio.core.cli.WithSource\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Update the metadata format to the latest format version.</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>cli_cmd</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>descr</code> <code>descr_id</code> <code>str</code> <p>a more user-friendly description id</p> <code>diff</code> <code>Union[bool, Path]</code> <p>Output a diff of original and updated bioimageio.yaml.</p> <code>exclude_defaults</code> <code>bool</code> <p>Exclude fields that have the default value (even if set explicitly).</p> <code>exclude_unset</code> <code>bool</code> <p>Exclude fields that have not explicitly be set.</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>output</code> <code>Union[Literal['display', 'stdout'], Path]</code> <p>Output updated bioimageio.yaml to the terminal or write to a file.</p> <code>perform_io_checks</code> <code>bool</code> <p>Wether or not to attempt validation that may require file download.</p> <code>source</code> <code>CliPositionalArg[str]</code> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file</p> <code>updated</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.descr","title":"descr  <code>cached</code> <code>property</code>","text":"<pre><code>descr\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.descr_id","title":"descr_id  <code>property</code>","text":"<pre><code>descr_id: str\n</code></pre> <p>a more user-friendly description id (replacing legacy ids with their nicknames)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.diff","title":"diff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>diff: Union[bool, Path] = Field(True, alias='diff')\n</code></pre> <p>Output a diff of original and updated bioimageio.yaml. If a given path has an <code>.html</code> extension, a standalone HTML file is written, otherwise the diff is saved in unified diff format (pure text).</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.exclude_defaults","title":"exclude_defaults  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude_defaults: bool = Field(True, alias='exclude-defaults')\n</code></pre> <p>Exclude fields that have the default value (even if set explicitly).</p> Note <p>The update process sets most unset fields explicitly with their default value.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.exclude_unset","title":"exclude_unset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude_unset: bool = Field(True, alias='exclude-unset')\n</code></pre> <p>Exclude fields that have not explicitly be set.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: Union[Literal['display', 'stdout'], Path] = 'display'\n</code></pre> <p>Output updated bioimageio.yaml to the terminal or write to a file. Notes: - <code>\"display\"</code>: Render to the terminal with syntax highlighting. - <code>\"stdout\"</code>: Write to sys.stdout without syntax highligthing.   (More convenient for copying the updated bioimageio.yaml from the terminal.)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.perform_io_checks","title":"perform_io_checks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>perform_io_checks: bool = Field(settings.perform_io_checks, alias='perform-io-checks')\n</code></pre> <p>Wether or not to attempt validation that may require file download. If <code>True</code> file hash values are added if not present.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: CliPositionalArg[str]\n</code></pre> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file or a bioimage.io resource identifier, e.g. 'affable-shark'</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.updated","title":"updated  <code>cached</code> <code>property</code>","text":"<pre><code>updated\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.cli_cmd","title":"cli_cmd","text":"<pre><code>cli_cmd()\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def cli_cmd(self):\n    original_yaml = open_bioimageio_yaml(self.source).unparsed_content\n    assert isinstance(original_yaml, str)\n    stream = StringIO()\n\n    save_bioimageio_yaml_only(\n        self.updated,\n        stream,\n        exclude_unset=self.exclude_unset,\n        exclude_defaults=self.exclude_defaults,\n    )\n    updated_yaml = stream.getvalue()\n\n    diff = compare(\n        original_yaml.split(\"\\n\"),\n        updated_yaml.split(\"\\n\"),\n        diff_format=(\n            \"html\"\n            if isinstance(self.diff, Path) and self.diff.suffix == \".html\"\n            else \"unified\"\n        ),\n    )\n\n    if isinstance(self.diff, Path):\n        _ = self.diff.write_text(diff, encoding=\"utf-8\")\n    elif self.diff:\n        console = rich.console.Console()\n        diff_md = f\"## Diff\\n\\n````````diff\\n{diff}\\n````````\"\n        console.print(rich.markdown.Markdown(diff_md))\n\n    if isinstance(self.output, Path):\n        _ = self.output.write_text(updated_yaml, encoding=\"utf-8\")\n        logger.info(f\"written updated description to {self.output}\")\n    elif self.output == \"display\":\n        updated_md = f\"## Updated bioimageio.yaml\\n\\n```yaml\\n{updated_yaml}\\n```\"\n        rich.console.Console().print(rich.markdown.Markdown(updated_md))\n    elif self.output == \"stdout\":\n        print(updated_yaml)\n    else:\n        assert_never(self.output)\n\n    if isinstance(self.updated, InvalidDescr):\n        logger.warning(\"Update resulted in invalid description\")\n        _ = self.updated.validation_summary.display()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateFormatCmd.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd","title":"UpdateHashesCmd","text":"<pre><code>UpdateHashesCmd(**data: Any)\n</code></pre> <p>               Bases: <code>UpdateCmdBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.UpdateHashesCmd[UpdateHashesCmd]\n              bioimageio.core.cli.UpdateCmdBase[UpdateCmdBase]\n              bioimageio.core.cli.CmdBase[CmdBase]\n              bioimageio.core.cli.WithSource[WithSource]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.UpdateCmdBase --&gt; bioimageio.core.cli.UpdateHashesCmd\n                                bioimageio.core.cli.CmdBase --&gt; bioimageio.core.cli.UpdateCmdBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.CmdBase\n                \n\n                bioimageio.core.cli.WithSource --&gt; bioimageio.core.cli.UpdateCmdBase\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSource\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n\n\n              click bioimageio.core.cli.UpdateHashesCmd href \"\" \"bioimageio.core.cli.UpdateHashesCmd\"\n              click bioimageio.core.cli.UpdateCmdBase href \"\" \"bioimageio.core.cli.UpdateCmdBase\"\n              click bioimageio.core.cli.CmdBase href \"\" \"bioimageio.core.cli.CmdBase\"\n              click bioimageio.core.cli.WithSource href \"\" \"bioimageio.core.cli.WithSource\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Create a bioimageio.yaml description with updated file hashes.</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>cli_cmd</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>descr</code> <code>descr_id</code> <code>str</code> <p>a more user-friendly description id</p> <code>diff</code> <code>Union[bool, Path]</code> <p>Output a diff of original and updated bioimageio.yaml.</p> <code>exclude_defaults</code> <code>bool</code> <p>Exclude fields that have the default value (even if set explicitly).</p> <code>exclude_unset</code> <code>bool</code> <p>Exclude fields that have not explicitly be set.</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>output</code> <code>Union[Literal['display', 'stdout'], Path]</code> <p>Output updated bioimageio.yaml to the terminal or write to a file.</p> <code>source</code> <code>CliPositionalArg[str]</code> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file</p> <code>updated</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.descr","title":"descr  <code>cached</code> <code>property</code>","text":"<pre><code>descr\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.descr_id","title":"descr_id  <code>property</code>","text":"<pre><code>descr_id: str\n</code></pre> <p>a more user-friendly description id (replacing legacy ids with their nicknames)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.diff","title":"diff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>diff: Union[bool, Path] = Field(True, alias='diff')\n</code></pre> <p>Output a diff of original and updated bioimageio.yaml. If a given path has an <code>.html</code> extension, a standalone HTML file is written, otherwise the diff is saved in unified diff format (pure text).</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.exclude_defaults","title":"exclude_defaults  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude_defaults: bool = Field(False, alias='exclude-defaults')\n</code></pre> <p>Exclude fields that have the default value (even if set explicitly).</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.exclude_unset","title":"exclude_unset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude_unset: bool = Field(True, alias='exclude-unset')\n</code></pre> <p>Exclude fields that have not explicitly be set.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: Union[Literal['display', 'stdout'], Path] = 'display'\n</code></pre> <p>Output updated bioimageio.yaml to the terminal or write to a file. Notes: - <code>\"display\"</code>: Render to the terminal with syntax highlighting. - <code>\"stdout\"</code>: Write to sys.stdout without syntax highligthing.   (More convenient for copying the updated bioimageio.yaml from the terminal.)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: CliPositionalArg[str]\n</code></pre> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file or a bioimage.io resource identifier, e.g. 'affable-shark'</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.updated","title":"updated  <code>cached</code> <code>property</code>","text":"<pre><code>updated\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.cli_cmd","title":"cli_cmd","text":"<pre><code>cli_cmd()\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def cli_cmd(self):\n    original_yaml = open_bioimageio_yaml(self.source).unparsed_content\n    assert isinstance(original_yaml, str)\n    stream = StringIO()\n\n    save_bioimageio_yaml_only(\n        self.updated,\n        stream,\n        exclude_unset=self.exclude_unset,\n        exclude_defaults=self.exclude_defaults,\n    )\n    updated_yaml = stream.getvalue()\n\n    diff = compare(\n        original_yaml.split(\"\\n\"),\n        updated_yaml.split(\"\\n\"),\n        diff_format=(\n            \"html\"\n            if isinstance(self.diff, Path) and self.diff.suffix == \".html\"\n            else \"unified\"\n        ),\n    )\n\n    if isinstance(self.diff, Path):\n        _ = self.diff.write_text(diff, encoding=\"utf-8\")\n    elif self.diff:\n        console = rich.console.Console()\n        diff_md = f\"## Diff\\n\\n````````diff\\n{diff}\\n````````\"\n        console.print(rich.markdown.Markdown(diff_md))\n\n    if isinstance(self.output, Path):\n        _ = self.output.write_text(updated_yaml, encoding=\"utf-8\")\n        logger.info(f\"written updated description to {self.output}\")\n    elif self.output == \"display\":\n        updated_md = f\"## Updated bioimageio.yaml\\n\\n```yaml\\n{updated_yaml}\\n```\"\n        rich.console.Console().print(rich.markdown.Markdown(updated_md))\n    elif self.output == \"stdout\":\n        print(updated_yaml)\n    else:\n        assert_never(self.output)\n\n    if isinstance(self.updated, InvalidDescr):\n        logger.warning(\"Update resulted in invalid description\")\n        _ = self.updated.validation_summary.display()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.UpdateHashesCmd.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd","title":"ValidateFormatCmd","text":"<pre><code>ValidateFormatCmd(**data: Any)\n</code></pre> <p>               Bases: <code>CmdBase</code>, <code>WithSource</code>, <code>WithSummaryLogging</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.ValidateFormatCmd[ValidateFormatCmd]\n              bioimageio.core.cli.CmdBase[CmdBase]\n              bioimageio.core.cli.WithSource[WithSource]\n              bioimageio.core.cli.WithSummaryLogging[WithSummaryLogging]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.CmdBase --&gt; bioimageio.core.cli.ValidateFormatCmd\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.CmdBase\n                \n\n                bioimageio.core.cli.WithSource --&gt; bioimageio.core.cli.ValidateFormatCmd\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSource\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n                bioimageio.core.cli.WithSummaryLogging --&gt; bioimageio.core.cli.ValidateFormatCmd\n                                bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSummaryLogging\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n\n              click bioimageio.core.cli.ValidateFormatCmd href \"\" \"bioimageio.core.cli.ValidateFormatCmd\"\n              click bioimageio.core.cli.CmdBase href \"\" \"bioimageio.core.cli.CmdBase\"\n              click bioimageio.core.cli.WithSource href \"\" \"bioimageio.core.cli.WithSource\"\n              click bioimageio.core.cli.WithSummaryLogging href \"\" \"bioimageio.core.cli.WithSummaryLogging\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Validate the meta data format of a bioimageio resource.</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>cli_cmd</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>log</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>descr</code> <code>descr_id</code> <code>str</code> <p>a more user-friendly description id</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>perform_io_checks</code> <code>bool</code> <p>Wether or not to perform validations that requires downloading remote files.</p> <code>source</code> <code>CliPositionalArg[str]</code> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file</p> <code>summary</code> <code>List[Union[Literal['display'], Path]]</code> <p>Display the validation summary or save it as JSON, Markdown or HTML.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.descr","title":"descr  <code>cached</code> <code>property</code>","text":"<pre><code>descr\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.descr_id","title":"descr_id  <code>property</code>","text":"<pre><code>descr_id: str\n</code></pre> <p>a more user-friendly description id (replacing legacy ids with their nicknames)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.perform_io_checks","title":"perform_io_checks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>perform_io_checks: bool = Field(settings.perform_io_checks, alias='perform-io-checks')\n</code></pre> <p>Wether or not to perform validations that requires downloading remote files. Note: Default value is set by <code>BIOIMAGEIO_PERFORM_IO_CHECKS</code> environment variable.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: CliPositionalArg[str]\n</code></pre> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file or a bioimage.io resource identifier, e.g. 'affable-shark'</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: List[Union[Literal['display'], Path]] = Field(default_factory=lambda: ['display'], examples=[Path('summary.md'), Path('bioimageio_summaries/'), ['display', Path('summary.md')]])\n</code></pre> <p>Display the validation summary or save it as JSON, Markdown or HTML. The format is chosen based on the suffix: <code>.json</code>, <code>.md</code>, <code>.html</code>. If a folder is given (path w/o suffix) the summary is saved in all formats. Choose/add <code>\"display\"</code> to render the validation summary to the terminal.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.cli_cmd","title":"cli_cmd","text":"<pre><code>cli_cmd()\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def cli_cmd(self):\n    self.log(self.descr)\n    sys.exit(\n        0\n        if self.descr.validation_summary.status in (\"valid-format\", \"passed\")\n        else 1\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.log","title":"log","text":"<pre><code>log(descr: Union[ResourceDescr, InvalidDescr])\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def log(self, descr: Union[ResourceDescr, InvalidDescr]):\n    _ = descr.validation_summary.log(self.summary)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.ValidateFormatCmd.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource","title":"WithSource","text":"<pre><code>WithSource(**data: Any)\n</code></pre> <p>               Bases: <code>ArgMixin</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.WithSource[WithSource]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSource\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n              click bioimageio.core.cli.WithSource href \"\" \"bioimageio.core.cli.WithSource\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0cli <ul> <li> <code></code>\u00a0AddWeightsCmd </li> <li> <code></code>\u00a0PackageCmd </li> <li> <code></code>\u00a0PredictCmd </li> <li> <code></code>\u00a0TestCmd </li> <li> <code></code>\u00a0UpdateCmdBase </li> <li> <code></code>\u00a0ValidateFormatCmd </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>descr</code> <code>descr_id</code> <code>str</code> <p>a more user-friendly description id</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>source</code> <code>CliPositionalArg[str]</code> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.descr","title":"descr  <code>cached</code> <code>property</code>","text":"<pre><code>descr\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.descr_id","title":"descr_id  <code>property</code>","text":"<pre><code>descr_id: str\n</code></pre> <p>a more user-friendly description id (replacing legacy ids with their nicknames)</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: CliPositionalArg[str]\n</code></pre> <p>Url/path to a (folder with a) bioimageio.yaml/rdf.yaml file or a bioimage.io resource identifier, e.g. 'affable-shark'</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSource.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging","title":"WithSummaryLogging","text":"<pre><code>WithSummaryLogging(**data: Any)\n</code></pre> <p>               Bases: <code>ArgMixin</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.cli.WithSummaryLogging[WithSummaryLogging]\n              bioimageio.core.cli.ArgMixin[ArgMixin]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.cli.ArgMixin --&gt; bioimageio.core.cli.WithSummaryLogging\n                                pydantic.main.BaseModel --&gt; bioimageio.core.cli.ArgMixin\n                \n\n\n\n              click bioimageio.core.cli.WithSummaryLogging href \"\" \"bioimageio.core.cli.WithSummaryLogging\"\n              click bioimageio.core.cli.ArgMixin href \"\" \"bioimageio.core.cli.ArgMixin\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0cli <ul> <li> <code></code>\u00a0AddWeightsCmd </li> <li> <code></code>\u00a0PackageCmd </li> <li> <code></code>\u00a0TestCmd </li> <li> <code></code>\u00a0ValidateFormatCmd </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>log</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>summary</code> <code>List[Union[Literal['display'], Path]]</code> <p>Display the validation summary or save it as JSON, Markdown or HTML.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: List[Union[Literal['display'], Path]] = Field(default_factory=lambda: ['display'], examples=[Path('summary.md'), Path('bioimageio_summaries/'), ['display', Path('summary.md')]])\n</code></pre> <p>Display the validation summary or save it as JSON, Markdown or HTML. The format is chosen based on the suffix: <code>.json</code>, <code>.md</code>, <code>.html</code>. If a folder is given (path w/o suffix) the summary is saved in all formats. Choose/add <code>\"display\"</code> to render the validation summary to the terminal.</p>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.log","title":"log","text":"<pre><code>log(descr: Union[ResourceDescr, InvalidDescr])\n</code></pre> Source code in <code>src/bioimageio/core/cli.py</code> <pre><code>def log(self, descr: Union[ResourceDescr, InvalidDescr]):\n    _ = descr.validation_summary.log(self.summary)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/cli/#bioimageio.core.cli.WithSummaryLogging.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/commands/","title":"bioimageio.core.commands","text":""},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands","title":"commands","text":"<p>These functions are used in the bioimageio command line interface defined in <code>bioimageio.core.cli</code>.</p> <p>Functions:</p> Name Description <code>package</code> <p>Save a resource's metadata with its associated files.</p> <code>test</code> <p>Test a bioimageio resource.</p> <code>validate_format</code> <p>DEPRECATED; Access the existing <code>validation_summary</code> attribute instead.</p> <p>Attributes:</p> Name Type Description <code>WeightFormatArgAll</code> <code>WeightFormatArgAny</code>"},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands.WeightFormatArgAll","title":"WeightFormatArgAll  <code>module-attribute</code>","text":"<pre><code>WeightFormatArgAll = Literal['keras_hdf5', 'onnx', 'pytorch_state_dict', 'tensorflow_saved_model_bundle', 'torchscript', 'all']\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0commands <ul> <li> <code></code>\u00a0package </li> <li> <code></code>\u00a0test </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands.WeightFormatArgAny","title":"WeightFormatArgAny  <code>module-attribute</code>","text":"<pre><code>WeightFormatArgAny = Literal['keras_hdf5', 'onnx', 'pytorch_state_dict', 'tensorflow_saved_model_bundle', 'torchscript', 'any']\n</code></pre>"},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands.package","title":"package","text":"<pre><code>package(descr: ResourceDescr, path: Path, *, weight_format: WeightFormatArgAll = 'all')\n</code></pre> <p>Save a resource's metadata with its associated files.</p> If <code>path</code> does not have a <code>.zip</code> suffix this command will save the <p>package as an unzipped folder instead.</p> <p>Parameters:</p> Name Type Description Default <code>ResourceDescr</code> <p>a bioimageio resource description</p> required <code>Path</code> <p>output path</p> required <code>WeightFormatArgAll</code> <p>include only this single weight-format (if not 'all').</p> <code>'all'</code> Source code in <code>src/bioimageio/core/commands.py</code> <pre><code>def package(\n    descr: ResourceDescr,\n    path: Path,\n    *,\n    weight_format: WeightFormatArgAll = \"all\",\n):\n    \"\"\"Save a resource's metadata with its associated files.\n\n    Note: If `path` does not have a `.zip` suffix this command will save the\n          package as an unzipped folder instead.\n\n    Args:\n        descr: a bioimageio resource description\n        path: output path\n        weight_format: include only this single weight-format (if not 'all').\n    \"\"\"\n    if isinstance(descr, InvalidDescr):\n        logged = descr.validation_summary.save()\n        msg = f\"Invalid {descr.type} description.\"\n        if logged:\n            msg += f\" Details saved to {logged}.\"\n\n        raise ValueError(msg)\n\n    if weight_format == \"all\":\n        weights_priority_order = None\n    else:\n        weights_priority_order = (weight_format,)\n\n    if path.suffix == \".zip\":\n        _ = save_bioimageio_package(\n            descr,\n            output_path=path,\n            weights_priority_order=weights_priority_order,\n        )\n    else:\n        _ = save_bioimageio_package_as_folder(\n            descr,\n            output_path=path,\n            weights_priority_order=weights_priority_order,\n        )\n    return 0\n</code></pre>"},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands.package(descr)","title":"<code>descr</code>","text":""},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands.package(path)","title":"<code>path</code>","text":""},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands.package(weight_format)","title":"<code>weight_format</code>","text":""},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands.test","title":"test","text":"<pre><code>test(descr: Union[ResourceDescr, InvalidDescr], *, weight_format: WeightFormatArgAll = 'all', devices: Optional[Union[str, Sequence[str]]] = None, summary: Union[Literal['display'], Path, Sequence[Union[Literal['display'], Path]]] = 'display', runtime_env: Union[Literal['currently-active', 'as-described'], Path] = 'currently-active', determinism: Literal['seed_only', 'full'] = 'seed_only', format_version: Union[FormatVersionPlaceholder, str] = 'discover', working_dir: Optional[Path] = None) -&gt; int\n</code></pre> <p>Test a bioimageio resource.</p> <p>Arguments as described in bioimageio.core.cli.TestCmd</p> Source code in <code>src/bioimageio/core/commands.py</code> <pre><code>def test(\n    descr: Union[ResourceDescr, InvalidDescr],\n    *,\n    weight_format: WeightFormatArgAll = \"all\",\n    devices: Optional[Union[str, Sequence[str]]] = None,\n    summary: Union[\n        Literal[\"display\"], Path, Sequence[Union[Literal[\"display\"], Path]]\n    ] = \"display\",\n    runtime_env: Union[\n        Literal[\"currently-active\", \"as-described\"], Path\n    ] = \"currently-active\",\n    determinism: Literal[\"seed_only\", \"full\"] = \"seed_only\",\n    format_version: Union[FormatVersionPlaceholder, str] = \"discover\",\n    working_dir: Optional[Path] = None,\n) -&gt; int:\n    \"\"\"Test a bioimageio resource.\n\n    Arguments as described in [bioimageio.core.cli.TestCmd][]\n    \"\"\"\n    if isinstance(descr, InvalidDescr):\n        test_summary = descr.validation_summary\n    else:\n        test_summary = test_description(\n            descr,\n            format_version=format_version,\n            weight_format=None if weight_format == \"all\" else weight_format,\n            devices=[devices] if isinstance(devices, str) else devices,\n            runtime_env=runtime_env,\n            determinism=determinism,\n            working_dir=working_dir,\n        )\n\n    _ = test_summary.log(summary)\n    return 0 if test_summary.status == \"passed\" else 1\n</code></pre>"},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands.validate_format","title":"validate_format","text":"<pre><code>validate_format(descr: Union[ResourceDescr, InvalidDescr], summary: Union[Path, Sequence[Path]] = ())\n</code></pre> <p>DEPRECATED; Access the existing <code>validation_summary</code> attribute instead. validate the meta data format of a bioimageio resource</p> <p>Parameters:</p> Name Type Description Default <code>Union[ResourceDescr, InvalidDescr]</code> <p>a bioimageio resource description</p> required Source code in <code>src/bioimageio/core/commands.py</code> <pre><code>def validate_format(\n    descr: Union[ResourceDescr, InvalidDescr],\n    summary: Union[Path, Sequence[Path]] = (),\n):\n    \"\"\"DEPRECATED; Access the existing `validation_summary` attribute instead.\n    validate the meta data format of a bioimageio resource\n\n    Args:\n        descr: a bioimageio resource description\n    \"\"\"\n    _ = descr.validation_summary.save(summary)\n    return 0 if descr.validation_summary.status in (\"valid-format\", \"passed\") else 1\n</code></pre>"},{"location":"api/bioimageio/core/commands/#bioimageio.core.commands.validate_format(descr)","title":"<code>descr</code>","text":""},{"location":"api/bioimageio/core/common/","title":"bioimageio.core.common","text":""},{"location":"api/bioimageio/core/common/#bioimageio.core.common","title":"common","text":"Used by: <ul> <li> API Reference \u00a0core \u00a0MemberId </li> </ul> <p>Classes:</p> Name Description <code>CropWidth</code> <code>Halo</code> <code>OverlapWidth</code> <code>PadWidth</code> <code>SliceInfo</code> <p>Attributes:</p> Name Type Description <code>BlockIndex</code> <code>BlocksizeParameter</code> <p>Parameter to determine a concrete size for paramtrized axis sizes defined by</p> <code>CropWhere</code> <code>CropWidthLike</code> <code>DTypeStr</code> <code>Frozen</code> <code>HaloLike</code> <code>K</code> <code>MemberId</code> <p>ID of a <code>Sample</code> member, see <code>bioimageio.core.sample.Sample</code></p> <code>PadMode</code> <code>PadWhere</code> <code>PadWidthLike</code> <code>PerMember</code> <code>QuantileMethod</code> <p>Methods to use when the desired quantile lies between two data points.</p> <code>SampleId</code> <p>ID of a sample, see <code>bioimageio.core.sample.Sample</code></p> <code>SupportedWeightsFormat</code> <code>T</code> <code>TotalNumberOfBlocks</code> <code>V</code>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.BlockIndex","title":"BlockIndex  <code>module-attribute</code>","text":"<pre><code>BlockIndex = int\n</code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <code></code>\u00a0Block </li> <li> <code></code>\u00a0block_meta <code></code>\u00a0BlockMeta </li> <li> <code></code>\u00a0sample <ul> <li> <code></code>\u00a0SampleBlock </li> <li> <code></code>\u00a0SampleBlockBase </li> <li> <code></code>\u00a0SampleBlockMeta </li> <li> <code></code>\u00a0SampleBlockWithOrigin </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.BlocksizeParameter","title":"BlocksizeParameter  <code>module-attribute</code>","text":"<pre><code>BlocksizeParameter = Union[v0_5.ParameterizedSize_N, Mapping[Tuple[MemberId, AxisId], v0_5.ParameterizedSize_N]]\n</code></pre> <p>Parameter to determine a concrete size for paramtrized axis sizes defined by <code>bioimageio.spec.model.v0_5.ParameterizedSize</code>.</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0core <ul> <li> <code></code>\u00a0PredictionPipeline </li> <li> <code></code>\u00a0create_prediction_pipeline </li> </ul> </li> <li> <code></code>\u00a0prediction <code></code>\u00a0predict </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.CropWhere","title":"CropWhere  <code>module-attribute</code>","text":"<pre><code>CropWhere = _Where\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.CropWidthLike","title":"CropWidthLike  <code>module-attribute</code>","text":"<pre><code>CropWidthLike = _LeftRightLike[CropWidth]\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.DTypeStr","title":"DTypeStr  <code>module-attribute</code>","text":"<pre><code>DTypeStr = Literal['bool', 'float32', 'float64', 'int8', 'int16', 'int32', 'int64', 'uint8', 'uint16', 'uint32', 'uint64']\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0EnsureDtype </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.Frozen","title":"Frozen  <code>module-attribute</code>","text":"<pre><code>Frozen = MappingProxyType\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.HaloLike","title":"HaloLike  <code>module-attribute</code>","text":"<pre><code>HaloLike = _LeftRightLike[Halo]\n</code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <code></code>\u00a0split_tensor_into_blocks </li> <li> <code></code>\u00a0block_meta <ul> <li> <code></code>\u00a0split_multiple_shapes_into_blocks </li> <li> <code></code>\u00a0split_shape_into_blocks </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.K","title":"K  <code>module-attribute</code>","text":"<pre><code>K = TypeVar('K', bound=Hashable)\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.MemberId","title":"MemberId  <code>module-attribute</code>","text":"<pre><code>MemberId = v0_5.TensorId\n</code></pre> <p>ID of a <code>Sample</code> member, see <code>bioimageio.core.sample.Sample</code></p> Returned by: <ul> <li> API Reference <code></code>\u00a0digest_spec <ul> <li> <code></code>\u00a0get_member_id </li> <li> <code></code>\u00a0get_member_ids </li> </ul> </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0common <ul> <li> <code></code>\u00a0BlocksizeParameter </li> <li> <code></code>\u00a0PerMember </li> </ul> </li> <li> <code></code>\u00a0core <code></code>\u00a0MemberId </li> <li> <code></code>\u00a0digest_spec <code></code>\u00a0get_io_sample_block_metas </li> <li> <code></code>\u00a0prediction <ul> <li> <code></code>\u00a0predict </li> <li> <code></code>\u00a0predict_many </li> </ul> </li> <li> <code></code>\u00a0proc_ops <ul> <li> <code></code>\u00a0Binarize </li> <li> <code></code>\u00a0Clip </li> <li> <code></code>\u00a0EnsureDtype </li> <li> <code></code>\u00a0FixedZeroMeanUnitVariance </li> <li> <code></code>\u00a0ScaleLinear </li> <li> <code></code>\u00a0ScaleMeanVariance </li> <li> <code></code>\u00a0ScaleRange </li> <li> <code></code>\u00a0Sigmoid </li> <li> <code></code>\u00a0Softmax </li> <li> <code></code>\u00a0ZeroMeanUnitVariance </li> </ul> </li> <li> <code></code>\u00a0sample <ul> <li> <code></code>\u00a0LinearSampleAxisTransform </li> <li> <code></code>\u00a0Sample </li> <li> <code></code>\u00a0SampleBlock </li> <li> <code></code>\u00a0SampleBlockBase </li> <li> <code></code>\u00a0SampleBlockMeta </li> <li> <code></code>\u00a0SampleBlockWithOrigin </li> </ul> </li> <li> <code></code>\u00a0stat_calculators <ul> <li> <code></code>\u00a0CrickQuantilesCalculator </li> <li> <code></code>\u00a0MeanCalculator </li> <li> <code></code>\u00a0MeanQuantilesCalculator </li> <li> <code></code>\u00a0MeanVarStdCalculator </li> <li> <code></code>\u00a0NaiveSampleMeasureCalculator </li> <li> <code></code>\u00a0SampleQuantilesCalculator </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.PadMode","title":"PadMode  <code>module-attribute</code>","text":"<pre><code>PadMode = Literal['edge', 'reflect', 'symmetric']\n</code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <code></code>\u00a0split_tensor_into_blocks </li> <li> <code></code>\u00a0sample <code></code>\u00a0sample_block_generator </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.PadWhere","title":"PadWhere  <code>module-attribute</code>","text":"<pre><code>PadWhere = _Where\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.PadWidthLike","title":"PadWidthLike  <code>module-attribute</code>","text":"<pre><code>PadWidthLike = _LeftRightLike[PadWidth]\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.PerMember","title":"PerMember  <code>module-attribute</code>","text":"<pre><code>PerMember = Mapping[MemberId, T]\n</code></pre> Returned by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block_meta <code></code>\u00a0split_multiple_shapes_into_blocks </li> <li> <code></code>\u00a0digest_spec <code></code>\u00a0get_block_transform </li> </ul> </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block_meta <code></code>\u00a0split_multiple_shapes_into_blocks </li> <li> <code></code>\u00a0digest_spec <ul> <li> <code></code>\u00a0create_sample_for_model </li> <li> <code></code>\u00a0get_input_halo </li> <li> <code></code>\u00a0get_io_sample_block_metas </li> <li> <code></code>\u00a0load_sample_for_model </li> </ul> </li> <li> <code></code>\u00a0io <code></code>\u00a0save_sample </li> <li> <code></code>\u00a0prediction <ul> <li> <code></code>\u00a0predict </li> <li> <code></code>\u00a0predict_many </li> </ul> </li> <li> <code></code>\u00a0sample <ul> <li> <code></code>\u00a0SampleBlock </li> <li> <code></code>\u00a0SampleBlockBase </li> <li> <code></code>\u00a0SampleBlockMeta </li> <li> <code></code>\u00a0SampleBlockWithOrigin </li> <li> <code></code>\u00a0sample_block_generator </li> <li> <code></code>\u00a0sample_block_meta_generator </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.QuantileMethod","title":"QuantileMethod  <code>module-attribute</code>","text":"<pre><code>QuantileMethod = Literal['inverted_cdf', 'linear']\n</code></pre> <p>Methods to use when the desired quantile lies between two data points. See https://numpy.org/devdocs/reference/generated/numpy.quantile.html#numpy-quantile for details.</p> Note <p>Only relevant for <code>SampleQuantile</code> measures, as <code>DatasetQuantile</code> measures computed by [bioimageio.core.stat_calculators.][] are approximations (and use the \"linear\" method for each sample quantiles)</p> <p>Warning</p> <p>Limited choices to map more easily to bioimageio.spec descriptions. Current implementations: - bioimageio.spec.model.v0_5.ClipKwargs implies \"inverted_cdf\" for sample quantiles and \"linear\" (numpy's default) for dataset quantiles. - bioimageio.spec.model.v0_5.ScaleRangeKwargs implies \"linear\" (numpy's default)</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0SampleQuantilesCalculator </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.SampleId","title":"SampleId  <code>module-attribute</code>","text":"<pre><code>SampleId = Hashable\n</code></pre> <p>ID of a sample, see <code>bioimageio.core.sample.Sample</code></p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0digest_spec <ul> <li> <code></code>\u00a0create_sample_for_model </li> <li> <code></code>\u00a0load_sample_for_model </li> </ul> </li> <li> <code></code>\u00a0sample <ul> <li> <code></code>\u00a0Sample </li> <li> <code></code>\u00a0SampleBlock </li> <li> <code></code>\u00a0SampleBlockBase </li> <li> <code></code>\u00a0SampleBlockMeta </li> <li> <code></code>\u00a0SampleBlockWithOrigin </li> <li> <code></code>\u00a0sample_block_meta_generator </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.SupportedWeightsFormat","title":"SupportedWeightsFormat  <code>module-attribute</code>","text":"<pre><code>SupportedWeightsFormat = Literal['keras_hdf5', 'onnx', 'pytorch_state_dict', 'tensorflow_saved_model_bundle', 'torchscript']\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0core <ul> <li> <code></code>\u00a0create_prediction_pipeline </li> <li> <code></code>\u00a0enable_determinism </li> <li> <code></code>\u00a0load_description_and_test </li> <li> <code></code>\u00a0test_description </li> <li> <code></code>\u00a0test_model </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0common <code></code>\u00a0PerMember </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.TotalNumberOfBlocks","title":"TotalNumberOfBlocks  <code>module-attribute</code>","text":"<pre><code>TotalNumberOfBlocks = int\n</code></pre> Returned by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <code></code>\u00a0split_tensor_into_blocks </li> <li> <code></code>\u00a0block_meta <ul> <li> <code></code>\u00a0split_multiple_shapes_into_blocks </li> <li> <code></code>\u00a0split_shape_into_blocks </li> </ul> </li> <li> <code></code>\u00a0digest_spec <code></code>\u00a0get_io_sample_block_metas </li> </ul> </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <code></code>\u00a0Block </li> <li> <code></code>\u00a0block_meta <code></code>\u00a0BlockMeta </li> <li> <code></code>\u00a0sample <ul> <li> <code></code>\u00a0SampleBlock </li> <li> <code></code>\u00a0SampleBlockBase </li> <li> <code></code>\u00a0SampleBlockMeta </li> <li> <code></code>\u00a0SampleBlockWithOrigin </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.V","title":"V  <code>module-attribute</code>","text":"<pre><code>V = TypeVar('V')\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.CropWidth","title":"CropWidth","text":"<p>               Bases: <code>_LeftRight</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.common.CropWidth[CropWidth]\n              bioimageio.core.common._LeftRight[_LeftRight]\n\n                              bioimageio.core.common._LeftRight --&gt; bioimageio.core.common.CropWidth\n                \n\n\n              click bioimageio.core.common.CropWidth href \"\" \"bioimageio.core.common.CropWidth\"\n              click bioimageio.core.common._LeftRight href \"\" \"bioimageio.core.common._LeftRight\"\n            </code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0common <code></code>\u00a0CropWidthLike </li> </ul> <p>Methods:</p> Name Description <code>create</code> <p>Attributes:</p> Name Type Description <code>left</code> <code>int</code> <code>right</code> <code>int</code>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.CropWidth.left","title":"left  <code>instance-attribute</code>","text":"<pre><code>left: int\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.CropWidth.right","title":"right  <code>instance-attribute</code>","text":"<pre><code>right: int\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.CropWidth.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(like: _LeftRightLike[Self]) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/common.py</code> <pre><code>@classmethod\ndef create(cls, like: _LeftRightLike[Self]) -&gt; Self:\n    if isinstance(like, cls):\n        return like\n    elif isinstance(like, tuple):\n        return cls(*like)\n    elif isinstance(like, int):\n        return cls(like, like)\n    else:\n        assert_never(like)\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.Halo","title":"Halo","text":"<p>               Bases: <code>_LeftRight</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.common.Halo[Halo]\n              bioimageio.core.common._LeftRight[_LeftRight]\n\n                              bioimageio.core.common._LeftRight --&gt; bioimageio.core.common.Halo\n                \n\n\n              click bioimageio.core.common.Halo href \"\" \"bioimageio.core.common.Halo\"\n              click bioimageio.core.common._LeftRight href \"\" \"bioimageio.core.common._LeftRight\"\n            </code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <code></code>\u00a0Block </li> <li> <code></code>\u00a0block_meta <code></code>\u00a0BlockMeta </li> <li> <code></code>\u00a0common <code></code>\u00a0HaloLike </li> <li> <code></code>\u00a0digest_spec <code></code>\u00a0get_input_halo </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>create</code> <p>Attributes:</p> Name Type Description <code>left</code> <code>int</code> <code>right</code> <code>int</code>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.Halo.left","title":"left  <code>instance-attribute</code>","text":"<pre><code>left: int\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.Halo.right","title":"right  <code>instance-attribute</code>","text":"<pre><code>right: int\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.Halo.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(like: _LeftRightLike[Self]) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/common.py</code> <pre><code>@classmethod\ndef create(cls, like: _LeftRightLike[Self]) -&gt; Self:\n    if isinstance(like, cls):\n        return like\n    elif isinstance(like, tuple):\n        return cls(*like)\n    elif isinstance(like, int):\n        return cls(like, like)\n    else:\n        assert_never(like)\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.OverlapWidth","title":"OverlapWidth","text":"<p>               Bases: <code>_LeftRight</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.common.OverlapWidth[OverlapWidth]\n              bioimageio.core.common._LeftRight[_LeftRight]\n\n                              bioimageio.core.common._LeftRight --&gt; bioimageio.core.common.OverlapWidth\n                \n\n\n              click bioimageio.core.common.OverlapWidth href \"\" \"bioimageio.core.common.OverlapWidth\"\n              click bioimageio.core.common._LeftRight href \"\" \"bioimageio.core.common._LeftRight\"\n            </code></pre> <p>Methods:</p> Name Description <code>create</code> <p>Attributes:</p> Name Type Description <code>left</code> <code>int</code> <code>right</code> <code>int</code>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.OverlapWidth.left","title":"left  <code>instance-attribute</code>","text":"<pre><code>left: int\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.OverlapWidth.right","title":"right  <code>instance-attribute</code>","text":"<pre><code>right: int\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.OverlapWidth.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(like: _LeftRightLike[Self]) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/common.py</code> <pre><code>@classmethod\ndef create(cls, like: _LeftRightLike[Self]) -&gt; Self:\n    if isinstance(like, cls):\n        return like\n    elif isinstance(like, tuple):\n        return cls(*like)\n    elif isinstance(like, int):\n        return cls(like, like)\n    else:\n        assert_never(like)\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.PadWidth","title":"PadWidth","text":"<p>               Bases: <code>_LeftRight</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.common.PadWidth[PadWidth]\n              bioimageio.core.common._LeftRight[_LeftRight]\n\n                              bioimageio.core.common._LeftRight --&gt; bioimageio.core.common.PadWidth\n                \n\n\n              click bioimageio.core.common.PadWidth href \"\" \"bioimageio.core.common.PadWidth\"\n              click bioimageio.core.common._LeftRight href \"\" \"bioimageio.core.common._LeftRight\"\n            </code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0common <code></code>\u00a0PadWidthLike </li> </ul> <p>Methods:</p> Name Description <code>create</code> <p>Attributes:</p> Name Type Description <code>left</code> <code>int</code> <code>right</code> <code>int</code>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.PadWidth.left","title":"left  <code>instance-attribute</code>","text":"<pre><code>left: int\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.PadWidth.right","title":"right  <code>instance-attribute</code>","text":"<pre><code>right: int\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.PadWidth.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(like: _LeftRightLike[Self]) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/common.py</code> <pre><code>@classmethod\ndef create(cls, like: _LeftRightLike[Self]) -&gt; Self:\n    if isinstance(like, cls):\n        return like\n    elif isinstance(like, tuple):\n        return cls(*like)\n    elif isinstance(like, int):\n        return cls(like, like)\n    else:\n        assert_never(like)\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.SliceInfo","title":"SliceInfo","text":"<p>               Bases: <code>NamedTuple</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.common.SliceInfo[SliceInfo]\n\n              \n\n              click bioimageio.core.common.SliceInfo href \"\" \"bioimageio.core.common.SliceInfo\"\n            </code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <code></code>\u00a0Block </li> <li> <code></code>\u00a0block_meta <code></code>\u00a0BlockMeta </li> </ul> </li> </ul> <p>Attributes:</p> Name Type Description <code>start</code> <code>int</code> <code>stop</code> <code>int</code>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.SliceInfo.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: int\n</code></pre>"},{"location":"api/bioimageio/core/common/#bioimageio.core.common.SliceInfo.stop","title":"stop  <code>instance-attribute</code>","text":"<pre><code>stop: int\n</code></pre>"},{"location":"api/bioimageio/core/dataset/","title":"bioimageio.core.dataset","text":""},{"location":"api/bioimageio/core/dataset/#bioimageio.core.dataset","title":"dataset","text":"<p>Attributes:</p> Name Type Description <code>Dataset</code>"},{"location":"api/bioimageio/core/dataset/#bioimageio.core.dataset.Dataset","title":"Dataset  <code>module-attribute</code>","text":"<pre><code>Dataset = Iterable[Sample]\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/","title":"bioimageio.core.digest_spec","text":""},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec","title":"digest_spec","text":"<p>Classes:</p> Name Description <code>IO_SampleBlockMeta</code> <p>Functions:</p> Name Description <code>create_sample_for_model</code> <p>Create a sample from a single set of input(s) for a specific bioimage.io model</p> <code>get_axes_infos</code> <p>get a unified, simplified axis representation from spec axes</p> <code>get_block_transform</code> <p>returns how a model's output tensor shapes relates to its input shapes</p> <code>get_input_halo</code> <p>returns which halo input tensors need to be divided into blocks with, such that</p> <code>get_io_sample_block_metas</code> <p>returns an iterable yielding meta data for corresponding input and output samples</p> <code>get_member_id</code> <p>get the normalized tensor ID, usable as a sample member ID</p> <code>get_member_ids</code> <p>get normalized tensor IDs to be used as sample member IDs</p> <code>get_tensor</code> <p>helper to cast/load various tensor sources</p> <code>get_test_input_sample</code> <code>get_test_output_sample</code> <p>returns a model's test output sample</p> <code>import_callable</code> <p>import a callable (e.g. a torch.nn.Module) from a spec node describing it</p> <code>load_sample_for_model</code> <p>load a single sample from <code>paths</code> that can be processed by <code>model</code></p> <p>Attributes:</p> Name Type Description <code>TensorSource</code> <code>get_test_inputs</code> <p>Deprecated</p> <p>use <code>get_test_input_sample</code> instead</p> <code>get_test_outputs</code> <p>Deprecated</p> <p>use <code>get_test_input_sample</code> instead</p> <code>tmp_dirs_in_use</code> <code>List[TemporaryDirectory[str]]</code> <p>keep global reference to temporary directories created during import to delay cleanup</p>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.TensorSource","title":"TensorSource  <code>module-attribute</code>","text":"<pre><code>TensorSource = Union[Tensor, xr.DataArray, NDArray[Any], Path]\n</code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0digest_spec <ul> <li> <code></code>\u00a0create_sample_for_model </li> <li> <code></code>\u00a0get_tensor </li> </ul> </li> <li> <code></code>\u00a0prediction <ul> <li> <code></code>\u00a0predict </li> <li> <code></code>\u00a0predict_many </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_test_inputs","title":"get_test_inputs  <code>module-attribute</code>","text":"<pre><code>get_test_inputs = get_test_input_sample\n</code></pre> <p>Deprecated</p> <p>use <code>get_test_input_sample</code> instead</p>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_test_outputs","title":"get_test_outputs  <code>module-attribute</code>","text":"<pre><code>get_test_outputs = get_test_output_sample\n</code></pre> <p>Deprecated</p> <p>use <code>get_test_input_sample</code> instead</p>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.tmp_dirs_in_use","title":"tmp_dirs_in_use  <code>module-attribute</code>","text":"<pre><code>tmp_dirs_in_use: List[TemporaryDirectory[str]] = []\n</code></pre> <p>keep global reference to temporary directories created during import to delay cleanup</p>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.IO_SampleBlockMeta","title":"IO_SampleBlockMeta","text":"<p>               Bases: <code>NamedTuple</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.digest_spec.IO_SampleBlockMeta[IO_SampleBlockMeta]\n\n              \n\n              click bioimageio.core.digest_spec.IO_SampleBlockMeta href \"\" \"bioimageio.core.digest_spec.IO_SampleBlockMeta\"\n            </code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0digest_spec <code></code>\u00a0get_io_sample_block_metas </li> </ul> <p>Attributes:</p> Name Type Description <code>input</code> <code>SampleBlockMeta</code> <code>output</code> <code>SampleBlockMeta</code>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.IO_SampleBlockMeta.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: SampleBlockMeta\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.IO_SampleBlockMeta.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: SampleBlockMeta\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.create_sample_for_model","title":"create_sample_for_model","text":"<pre><code>create_sample_for_model(model: AnyModelDescr, *, stat: Optional[Stat] = None, sample_id: SampleId = None, inputs: Union[PerMember[TensorSource], TensorSource]) -&gt; Sample\n</code></pre> <p>Create a sample from a single set of input(s) for a specific bioimage.io model</p> <p>Parameters:</p> Name Type Description Default <code>AnyModelDescr</code> <p>a bioimage.io model description</p> required <code>Optional[Stat]</code> <p>dictionary with sample and dataset statistics (may be updated in-place!)</p> <code>None</code> <code>Union[PerMember[TensorSource], TensorSource]</code> <p>the input(s) constituting a single sample.</p> required Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def create_sample_for_model(\n    model: AnyModelDescr,\n    *,\n    stat: Optional[Stat] = None,\n    sample_id: SampleId = None,\n    inputs: Union[PerMember[TensorSource], TensorSource],\n) -&gt; Sample:\n    \"\"\"Create a sample from a single set of input(s) for a specific bioimage.io model\n\n    Args:\n        model: a bioimage.io model description\n        stat: dictionary with sample and dataset statistics (may be updated in-place!)\n        inputs: the input(s) constituting a single sample.\n    \"\"\"\n\n    model_inputs = {get_member_id(d): d for d in model.inputs}\n    if isinstance(inputs, collections.abc.Mapping):\n        inputs = {MemberId(k): v for k, v in inputs.items()}\n    elif len(model_inputs) == 1:\n        inputs = {list(model_inputs)[0]: inputs}\n    else:\n        raise TypeError(\n            f\"Expected `inputs` to be a mapping with keys {tuple(model_inputs)}\"\n        )\n\n    if unknown := {k for k in inputs if k not in model_inputs}:\n        raise ValueError(f\"Got unexpected inputs: {unknown}\")\n\n    if missing := {\n        k\n        for k, v in model_inputs.items()\n        if k not in inputs and not (isinstance(v, v0_5.InputTensorDescr) and v.optional)\n    }:\n        raise ValueError(f\"Missing non-optional model inputs: {missing}\")\n\n    return Sample(\n        members={\n            m: get_tensor(inputs[m], ipt)\n            for m, ipt in model_inputs.items()\n            if m in inputs\n        },\n        stat={} if stat is None else stat,\n        id=sample_id,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.create_sample_for_model(model)","title":"<code>model</code>","text":""},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.create_sample_for_model(stat)","title":"<code>stat</code>","text":""},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.create_sample_for_model(inputs)","title":"<code>inputs</code>","text":""},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_axes_infos","title":"get_axes_infos","text":"<pre><code>get_axes_infos(io_descr: Union[v0_4.InputTensorDescr, v0_4.OutputTensorDescr, v0_5.InputTensorDescr, v0_5.OutputTensorDescr]) -&gt; List[AxisInfo]\n</code></pre> <p>get a unified, simplified axis representation from spec axes</p> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def get_axes_infos(\n    io_descr: Union[\n        v0_4.InputTensorDescr,\n        v0_4.OutputTensorDescr,\n        v0_5.InputTensorDescr,\n        v0_5.OutputTensorDescr,\n    ],\n) -&gt; List[AxisInfo]:\n    \"\"\"get a unified, simplified axis representation from spec axes\"\"\"\n    ret: List[AxisInfo] = []\n    for a in io_descr.axes:\n        if isinstance(a, v0_5.AxisBase):\n            ret.append(AxisInfo.create(Axis(id=a.id, type=a.type)))\n        else:\n            assert a in (\"b\", \"i\", \"t\", \"c\", \"z\", \"y\", \"x\")\n            ret.append(AxisInfo.create(a))\n\n    return ret\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_block_transform","title":"get_block_transform","text":"<pre><code>get_block_transform(model: v0_5.ModelDescr) -&gt; PerMember[PerAxis[Union[LinearSampleAxisTransform, int]]]\n</code></pre> <p>returns how a model's output tensor shapes relates to its input shapes</p> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def get_block_transform(\n    model: v0_5.ModelDescr,\n) -&gt; PerMember[PerAxis[Union[LinearSampleAxisTransform, int]]]:\n    \"\"\"returns how a model's output tensor shapes relates to its input shapes\"\"\"\n    ret: Dict[MemberId, Dict[AxisId, Union[LinearSampleAxisTransform, int]]] = {}\n    batch_axis_trf = None\n    for ipt in model.inputs:\n        for a in ipt.axes:\n            if a.type == \"batch\":\n                batch_axis_trf = LinearSampleAxisTransform(\n                    axis=a.id, scale=1, offset=0, member=ipt.id\n                )\n                break\n        if batch_axis_trf is not None:\n            break\n    axis_scales = {\n        t.id: {a.id: a.scale for a in t.axes}\n        for t in chain(model.inputs, model.outputs)\n    }\n    for out in model.outputs:\n        new_axes: Dict[AxisId, Union[LinearSampleAxisTransform, int]] = {}\n        for a in out.axes:\n            if a.size is None:\n                assert a.type == \"batch\"\n                if batch_axis_trf is None:\n                    raise ValueError(\n                        \"no batch axis found in any input tensor, but output tensor\"\n                        + f\" '{out.id}' has one.\"\n                    )\n                s = batch_axis_trf\n            elif isinstance(a.size, int):\n                s = a.size\n            elif isinstance(a.size, v0_5.DataDependentSize):\n                s = -1\n            elif isinstance(a.size, v0_5.SizeReference):\n                s = LinearSampleAxisTransform(\n                    axis=a.size.axis_id,\n                    scale=axis_scales[a.size.tensor_id][a.size.axis_id] / a.scale,\n                    offset=a.size.offset,\n                    member=a.size.tensor_id,\n                )\n            else:\n                assert_never(a.size)\n\n            new_axes[a.id] = s\n\n        ret[out.id] = new_axes\n\n    return ret\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_input_halo","title":"get_input_halo","text":"<pre><code>get_input_halo(model: v0_5.ModelDescr, output_halo: PerMember[PerAxis[Halo]])\n</code></pre> <p>returns which halo input tensors need to be divided into blocks with, such that <code>output_halo</code> can be cropped from their outputs without introducing gaps.</p> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def get_input_halo(model: v0_5.ModelDescr, output_halo: PerMember[PerAxis[Halo]]):\n    \"\"\"returns which halo input tensors need to be divided into blocks with, such that\n    `output_halo` can be cropped from their outputs without introducing gaps.\"\"\"\n    input_halo: Dict[MemberId, Dict[AxisId, Halo]] = {}\n    outputs = {t.id: t for t in model.outputs}\n    all_tensors = {**{t.id: t for t in model.inputs}, **outputs}\n\n    for t, th in output_halo.items():\n        axes = {a.id: a for a in outputs[t].axes}\n\n        for a, ah in th.items():\n            s = axes[a].size\n            if not isinstance(s, v0_5.SizeReference):\n                raise ValueError(\n                    f\"Unable to map output halo for {t}.{a} to an input axis\"\n                )\n\n            axis = axes[a]\n            ref_axis = {a.id: a for a in all_tensors[s.tensor_id].axes}[s.axis_id]\n\n            input_halo_left = ah.left * axis.scale / ref_axis.scale\n            input_halo_right = ah.right * axis.scale / ref_axis.scale\n            assert input_halo_left == int(input_halo_left), f\"{input_halo_left} not int\"\n            assert input_halo_right == int(input_halo_right), (\n                f\"{input_halo_right} not int\"\n            )\n\n            input_halo.setdefault(s.tensor_id, {})[a] = Halo(\n                int(input_halo_left), int(input_halo_right)\n            )\n\n    return input_halo\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_io_sample_block_metas","title":"get_io_sample_block_metas","text":"<pre><code>get_io_sample_block_metas(model: v0_5.ModelDescr, input_sample_shape: PerMember[PerAxis[int]], ns: Mapping[Tuple[MemberId, AxisId], ParameterizedSize_N], batch_size: int = 1) -&gt; Tuple[TotalNumberOfBlocks, Iterable[IO_SampleBlockMeta]]\n</code></pre> <p>returns an iterable yielding meta data for corresponding input and output samples</p> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def get_io_sample_block_metas(\n    model: v0_5.ModelDescr,\n    input_sample_shape: PerMember[PerAxis[int]],\n    ns: Mapping[Tuple[MemberId, AxisId], ParameterizedSize_N],\n    batch_size: int = 1,\n) -&gt; Tuple[TotalNumberOfBlocks, Iterable[IO_SampleBlockMeta]]:\n    \"\"\"returns an iterable yielding meta data for corresponding input and output samples\"\"\"\n    if not isinstance(model, v0_5.ModelDescr):\n        raise TypeError(f\"get_block_meta() not implemented for {type(model)}\")\n\n    block_axis_sizes = model.get_axis_sizes(ns=ns, batch_size=batch_size)\n    input_block_shape = {\n        t: {aa: s for (tt, aa), s in block_axis_sizes.inputs.items() if tt == t}\n        for t in {tt for tt, _ in block_axis_sizes.inputs}\n    }\n    output_halo = {\n        t.id: {\n            a.id: Halo(a.halo, a.halo) for a in t.axes if isinstance(a, v0_5.WithHalo)\n        }\n        for t in model.outputs\n    }\n    input_halo = get_input_halo(model, output_halo)\n\n    n_input_blocks, input_blocks = split_multiple_shapes_into_blocks(\n        input_sample_shape, input_block_shape, halo=input_halo\n    )\n    block_transform = get_block_transform(model)\n    return n_input_blocks, (\n        IO_SampleBlockMeta(ipt, ipt.get_transformed(block_transform))\n        for ipt in sample_block_meta_generator(\n            input_blocks, sample_shape=input_sample_shape, sample_id=None\n        )\n    )\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_member_id","title":"get_member_id","text":"<pre><code>get_member_id(tensor_description: Union[v0_4.InputTensorDescr, v0_4.OutputTensorDescr, v0_5.InputTensorDescr, v0_5.OutputTensorDescr]) -&gt; MemberId\n</code></pre> <p>get the normalized tensor ID, usable as a sample member ID</p> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def get_member_id(\n    tensor_description: Union[\n        v0_4.InputTensorDescr,\n        v0_4.OutputTensorDescr,\n        v0_5.InputTensorDescr,\n        v0_5.OutputTensorDescr,\n    ],\n) -&gt; MemberId:\n    \"\"\"get the normalized tensor ID, usable as a sample member ID\"\"\"\n\n    if isinstance(tensor_description, (v0_4.InputTensorDescr, v0_4.OutputTensorDescr)):\n        return MemberId(tensor_description.name)\n    elif isinstance(\n        tensor_description, (v0_5.InputTensorDescr, v0_5.OutputTensorDescr)\n    ):\n        return tensor_description.id\n    else:\n        assert_never(tensor_description)\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_member_ids","title":"get_member_ids","text":"<pre><code>get_member_ids(tensor_descriptions: Sequence[Union[v0_4.InputTensorDescr, v0_4.OutputTensorDescr, v0_5.InputTensorDescr, v0_5.OutputTensorDescr]]) -&gt; List[MemberId]\n</code></pre> <p>get normalized tensor IDs to be used as sample member IDs</p> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def get_member_ids(\n    tensor_descriptions: Sequence[\n        Union[\n            v0_4.InputTensorDescr,\n            v0_4.OutputTensorDescr,\n            v0_5.InputTensorDescr,\n            v0_5.OutputTensorDescr,\n        ]\n    ],\n) -&gt; List[MemberId]:\n    \"\"\"get normalized tensor IDs to be used as sample member IDs\"\"\"\n    return [get_member_id(descr) for descr in tensor_descriptions]\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_tensor","title":"get_tensor","text":"<pre><code>get_tensor(src: Union[ZipPath, TensorSource], ipt: Union[v0_4.InputTensorDescr, v0_5.InputTensorDescr])\n</code></pre> <p>helper to cast/load various tensor sources</p> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def get_tensor(\n    src: Union[ZipPath, TensorSource],\n    ipt: Union[v0_4.InputTensorDescr, v0_5.InputTensorDescr],\n):\n    \"\"\"helper to cast/load various tensor sources\"\"\"\n\n    if isinstance(src, Tensor):\n        return src\n    elif isinstance(src, xr.DataArray):\n        return Tensor.from_xarray(src)\n    elif isinstance(src, np.ndarray):\n        return Tensor.from_numpy(src, dims=get_axes_infos(ipt))\n    else:\n        return load_tensor(src, axes=get_axes_infos(ipt))\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_test_input_sample","title":"get_test_input_sample","text":"<pre><code>get_test_input_sample(model: AnyModelDescr) -&gt; Sample\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0digest_spec <code></code>\u00a0get_test_inputs </li> </ul> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def get_test_input_sample(model: AnyModelDescr) -&gt; Sample:\n    return _get_test_sample(\n        model.inputs,\n        model.test_inputs if isinstance(model, v0_4.ModelDescr) else model.inputs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.get_test_output_sample","title":"get_test_output_sample","text":"<pre><code>get_test_output_sample(model: AnyModelDescr) -&gt; Sample\n</code></pre> <p>returns a model's test output sample</p> Used by: <ul> <li> API Reference <code></code>\u00a0digest_spec <code></code>\u00a0get_test_outputs </li> </ul> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def get_test_output_sample(model: AnyModelDescr) -&gt; Sample:\n    \"\"\"returns a model's test output sample\"\"\"\n    return _get_test_sample(\n        model.outputs,\n        model.test_outputs if isinstance(model, v0_4.ModelDescr) else model.outputs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.import_callable","title":"import_callable","text":"<pre><code>import_callable(node: Union[ArchitectureFromFileDescr, ArchitectureFromLibraryDescr, CallableFromDepencency, CallableFromFile], /, **kwargs: Unpack[HashKwargs]) -&gt; Callable[..., Any]\n</code></pre> <p>import a callable (e.g. a torch.nn.Module) from a spec node describing it</p> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def import_callable(\n    node: Union[\n        ArchitectureFromFileDescr,\n        ArchitectureFromLibraryDescr,\n        CallableFromDepencency,\n        CallableFromFile,\n    ],\n    /,\n    **kwargs: Unpack[HashKwargs],\n) -&gt; Callable[..., Any]:\n    \"\"\"import a callable (e.g. a torch.nn.Module) from a spec node describing it\"\"\"\n    if isinstance(node, CallableFromDepencency):\n        module = importlib.import_module(node.module_name)\n        c = getattr(module, str(node.callable_name))\n    elif isinstance(node, ArchitectureFromLibraryDescr):\n        module = importlib.import_module(node.import_from)\n        c = getattr(module, str(node.callable))\n    elif isinstance(node, CallableFromFile):\n        c = _import_from_file_impl(node.source_file, str(node.callable_name), **kwargs)\n    elif isinstance(node, ArchitectureFromFileDescr):\n        c = _import_from_file_impl(node.source, str(node.callable), sha256=node.sha256)\n    else:\n        assert_never(node)\n\n    if not callable(c):\n        raise ValueError(f\"{node} (imported: {c}) is not callable\")\n\n    return c\n</code></pre>"},{"location":"api/bioimageio/core/digest_spec/#bioimageio.core.digest_spec.load_sample_for_model","title":"load_sample_for_model","text":"<pre><code>load_sample_for_model(*, model: AnyModelDescr, paths: PerMember[Path], axes: Optional[PerMember[Sequence[AxisLike]]] = None, stat: Optional[Stat] = None, sample_id: Optional[SampleId] = None)\n</code></pre> <p>load a single sample from <code>paths</code> that can be processed by <code>model</code></p> Source code in <code>src/bioimageio/core/digest_spec.py</code> <pre><code>def load_sample_for_model(\n    *,\n    model: AnyModelDescr,\n    paths: PerMember[Path],\n    axes: Optional[PerMember[Sequence[AxisLike]]] = None,\n    stat: Optional[Stat] = None,\n    sample_id: Optional[SampleId] = None,\n):\n    \"\"\"load a single sample from `paths` that can be processed by `model`\"\"\"\n\n    if axes is None:\n        axes = {}\n\n    # make sure members are keyed by MemberId, not string\n    paths = {MemberId(k): v for k, v in paths.items()}\n    axes = {MemberId(k): v for k, v in axes.items()}\n\n    model_inputs = {get_member_id(d): d for d in model.inputs}\n\n    if unknown := {k for k in paths if k not in model_inputs}:\n        raise ValueError(f\"Got unexpected paths for {unknown}\")\n\n    if unknown := {k for k in axes if k not in model_inputs}:\n        raise ValueError(f\"Got unexpected axes hints for: {unknown}\")\n\n    members: Dict[MemberId, Tensor] = {}\n    for m, p in paths.items():\n        if m not in axes:\n            axes[m] = get_axes_infos(model_inputs[m])\n            logger.debug(\n                \"loading '{}' from {} with default input axes {} \",\n                m,\n                p,\n                axes[m],\n            )\n        members[m] = load_tensor(p, axes[m])\n\n    return Sample(\n        members=members,\n        stat={} if stat is None else stat,\n        id=sample_id or tuple(sorted(paths.values())),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/io/","title":"bioimageio.core.io","text":""},{"location":"api/bioimageio/core/io/#bioimageio.core.io","title":"io","text":"<p>Functions:</p> Name Description <code>ensure_unzipped</code> <p>unzip a (downloaded) source to a file in folder if source is a zip archive</p> <code>get_suffix</code> <p>Deprecated</p> <p>use source.suffix instead.</p> <code>load_dataset_stat</code> <code>load_image</code> <p>load a single image as numpy array</p> <code>load_tensor</code> <code>save_dataset_stat</code> <code>save_sample</code> <p>Save a sample to a path pattern</p> <code>save_tensor</code> <p>Attributes:</p> Name Type Description <code>Suffix</code>"},{"location":"api/bioimageio/core/io/#bioimageio.core.io.Suffix","title":"Suffix  <code>module-attribute</code>","text":"<pre><code>Suffix = str\n</code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0io <code></code>\u00a0get_suffix </li> </ul>"},{"location":"api/bioimageio/core/io/#bioimageio.core.io.ensure_unzipped","title":"ensure_unzipped","text":"<pre><code>ensure_unzipped(source: Union[PermissiveFileSource, ZipPath, BytesReader], folder: Path)\n</code></pre> <p>unzip a (downloaded) source to a file in folder if source is a zip archive otherwise copy source to a file in folder.</p> Source code in <code>src/bioimageio/core/io.py</code> <pre><code>def ensure_unzipped(\n    source: Union[PermissiveFileSource, ZipPath, BytesReader], folder: Path\n):\n    \"\"\"unzip a (downloaded) **source** to a file in **folder** if source is a zip archive\n    otherwise copy **source** to a file in **folder**.\"\"\"\n    if isinstance(source, BytesReader):\n        weights_reader = source\n    else:\n        weights_reader = get_reader(source)\n\n    out_path = folder / (\n        weights_reader.original_file_name or f\"file{weights_reader.suffix}\"\n    )\n\n    if zipfile.is_zipfile(weights_reader):\n        out_path = out_path.with_name(out_path.name + \".unzipped\")\n        out_path.parent.mkdir(exist_ok=True, parents=True)\n        # source itself is a zipfile\n        with zipfile.ZipFile(weights_reader, \"r\") as f:\n            f.extractall(out_path)\n\n    else:\n        out_path.parent.mkdir(exist_ok=True, parents=True)\n        with out_path.open(\"wb\") as f:\n            copyfileobj(weights_reader, f)\n\n    return out_path\n</code></pre>"},{"location":"api/bioimageio/core/io/#bioimageio.core.io.get_suffix","title":"get_suffix","text":"<pre><code>get_suffix(source: Union[ZipPath, FileSource]) -&gt; Suffix\n</code></pre> <p>Deprecated</p> <p>use source.suffix instead.</p> Source code in <code>src/bioimageio/core/io.py</code> <pre><code>def get_suffix(source: Union[ZipPath, FileSource]) -&gt; Suffix:\n    \"\"\"DEPRECATED: use source.suffix instead.\"\"\"\n    return source.suffix\n</code></pre>"},{"location":"api/bioimageio/core/io/#bioimageio.core.io.load_dataset_stat","title":"load_dataset_stat","text":"<pre><code>load_dataset_stat(path: Path)\n</code></pre> Source code in <code>src/bioimageio/core/io.py</code> <pre><code>def load_dataset_stat(path: Path):\n    seq = _stat_adapter.validate_json(path.read_bytes())\n    return {e.measure: e.value for e in seq}\n</code></pre>"},{"location":"api/bioimageio/core/io/#bioimageio.core.io.load_image","title":"load_image","text":"<pre><code>load_image(source: Union[ZipPath, PermissiveFileSource], is_volume: Optional[bool] = None) -&gt; NDArray[Any]\n</code></pre> <p>load a single image as numpy array</p> <p>Parameters:</p> Name Type Description Default <code>Union[ZipPath, PermissiveFileSource]</code> <p>image source</p> required <code>Optional[bool]</code> <p>deprecated</p> <code>None</code> Source code in <code>src/bioimageio/core/io.py</code> <pre><code>def load_image(\n    source: Union[ZipPath, PermissiveFileSource], is_volume: Optional[bool] = None\n) -&gt; NDArray[Any]:\n    \"\"\"load a single image as numpy array\n\n    Args:\n        source: image source\n        is_volume: deprecated\n    \"\"\"\n    if is_volume is not None:\n        warnings.warn(\"**is_volume** is deprecated and will be removed soon.\")\n\n    if isinstance(source, ZipPath):\n        parsed_source = source\n    else:\n        parsed_source = interprete_file_source(source)\n\n    if isinstance(parsed_source, RelativeFilePath):\n        parsed_source = parsed_source.absolute()\n\n    if parsed_source.suffix == \".npy\":\n        image = load_array(parsed_source)\n    else:\n        reader = download(parsed_source)\n        image = imread(  # pyright: ignore[reportUnknownVariableType]\n            reader.read(), extension=parsed_source.suffix\n        )\n\n    assert is_ndarray(image)\n    return image\n</code></pre>"},{"location":"api/bioimageio/core/io/#bioimageio.core.io.load_image(source)","title":"<code>source</code>","text":""},{"location":"api/bioimageio/core/io/#bioimageio.core.io.load_image(is_volume)","title":"<code>is_volume</code>","text":""},{"location":"api/bioimageio/core/io/#bioimageio.core.io.load_tensor","title":"load_tensor","text":"<pre><code>load_tensor(path: Union[ZipPath, Path, str], axes: Optional[Sequence[AxisLike]] = None) -&gt; Tensor\n</code></pre> Source code in <code>src/bioimageio/core/io.py</code> <pre><code>def load_tensor(\n    path: Union[ZipPath, Path, str], axes: Optional[Sequence[AxisLike]] = None\n) -&gt; Tensor:\n    # TODO: load axis meta data\n    array = load_image(path)\n\n    return Tensor.from_numpy(array, dims=axes)\n</code></pre>"},{"location":"api/bioimageio/core/io/#bioimageio.core.io.save_dataset_stat","title":"save_dataset_stat","text":"<pre><code>save_dataset_stat(stat: Mapping[DatasetMeasure, MeasureValue], path: Path)\n</code></pre> Source code in <code>src/bioimageio/core/io.py</code> <pre><code>def save_dataset_stat(stat: Mapping[DatasetMeasure, MeasureValue], path: Path):\n    serializable = [\n        _SerializedDatasetStatsEntry(measure=k, value=v) for k, v in stat.items()\n    ]\n    _ = path.write_bytes(_stat_adapter.dump_json(serializable))\n</code></pre>"},{"location":"api/bioimageio/core/io/#bioimageio.core.io.save_sample","title":"save_sample","text":"<pre><code>save_sample(path: Union[Path, str, PerMember[Union[Path, str]]], sample: Sample) -&gt; None\n</code></pre> <p>Save a sample to a path pattern or all sample members in the path mapping.</p> <p>If path is a pathlib.Path or a string and the sample has multiple members, path it must contain <code>{member_id}</code> (or <code>{input_id}</code> or <code>{output_id}</code>).</p> <p>(Each) path may contain <code>{sample_id}</code> to be formatted with the sample object.</p> Source code in <code>src/bioimageio/core/io.py</code> <pre><code>def save_sample(\n    path: Union[Path, str, PerMember[Union[Path, str]]], sample: Sample\n) -&gt; None:\n    \"\"\"Save a **sample** to a **path** pattern\n    or all sample members in the **path** mapping.\n\n    If **path** is a pathlib.Path or a string and the **sample** has multiple members,\n    **path** it must contain `{member_id}` (or `{input_id}` or `{output_id}`).\n\n    (Each) **path** may contain `{sample_id}` to be formatted with the **sample** object.\n    \"\"\"\n    if not isinstance(path, collections.abc.Mapping):\n        if len(sample.members) &lt; 2 or any(\n            m in str(path) for m in (\"{member_id}\", \"{input_id}\", \"{output_id}\")\n        ):\n            path = {m: path for m in sample.members}\n        else:\n            raise ValueError(\n                f\"path {path} must contain '{{member_id}}' for sample with multiple members {list(sample.members)}.\"\n            )\n\n    for m, p in path.items():\n        t = sample.members[m]\n        p_formatted = Path(\n            str(p).format(sample_id=sample.id, member_id=m, input_id=m, output_id=m)\n        )\n        save_tensor(p_formatted, t)\n</code></pre>"},{"location":"api/bioimageio/core/io/#bioimageio.core.io.save_tensor","title":"save_tensor","text":"<pre><code>save_tensor(path: Union[Path, str], tensor: Tensor) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/io.py</code> <pre><code>def save_tensor(path: Union[Path, str], tensor: Tensor) -&gt; None:\n    # TODO: save axis meta data\n\n    data: NDArray[Any] = (  # pyright: ignore[reportUnknownVariableType]\n        tensor.data.to_numpy()\n    )\n    assert is_ndarray(data)\n    path = Path(path)\n    if not path.suffix:\n        raise ValueError(f\"No suffix (needed to decide file format) found in {path}\")\n\n    extension = path.suffix.lower()\n    path.parent.mkdir(exist_ok=True, parents=True)\n    if extension == \".npy\":\n        save_array(path, data)\n    elif extension in (\".h5\", \".hdf\", \".hdf5\"):\n        raise NotImplementedError(\"Saving to h5 with dataset path is not implemented.\")\n    else:\n        if (\n            extension in (\".tif\", \".tiff\")\n            and tensor.tagged_shape.get(ba := AxisId(\"batch\")) == 1\n        ):\n            # remove singleton batch axis for saving\n            tensor = tensor[{ba: 0}]\n            singleton_axes_msg = f\"(without singleton batch axes) \"\n        else:\n            singleton_axes_msg = \"\"\n\n        logger.debug(\n            \"writing tensor {} {}to {}\",\n            dict(tensor.tagged_shape),\n            singleton_axes_msg,\n            path,\n        )\n        imwrite(path, data, extension=extension)\n</code></pre>"},{"location":"api/bioimageio/core/model_adapters/","title":"bioimageio.core.model_adapters","text":""},{"location":"api/bioimageio/core/model_adapters/#bioimageio.core.model_adapters","title":"model_adapters","text":"<p>DEPRECATED</p> <p>Classes:</p> Name Description <code>ModelAdapter</code> <p>Represents model without any preprocessing or postprocessing.</p> <p>Functions:</p> Name Description <code>get_weight_formats</code> <p>Return list of supported weight types</p> <p>Attributes:</p> Name Type Description <code>create_model_adapter</code>"},{"location":"api/bioimageio/core/model_adapters/#bioimageio.core.model_adapters.create_model_adapter","title":"create_model_adapter  <code>module-attribute</code>","text":"<pre><code>create_model_adapter = ModelAdapter.create\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0create_model_adapter </li> </ul>"},{"location":"api/bioimageio/core/model_adapters/#bioimageio.core.model_adapters.ModelAdapter","title":"ModelAdapter","text":"<pre><code>ModelAdapter(model_description: AnyModelDescr)\n</code></pre> <p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.model_adapters.ModelAdapter[ModelAdapter]\n\n              \n\n              click bioimageio.core.model_adapters.ModelAdapter href \"\" \"bioimageio.core.model_adapters.ModelAdapter\"\n            </code></pre> <p>Represents model without any preprocessing or postprocessing.</p> <pre><code>from bioimageio.core import load_description\n\nmodel = load_description(...)\n\n# option 1:\nadapter = ModelAdapter.create(model)\nadapter.forward(...)\nadapter.unload()\n\n# option 2:\nwith ModelAdapter.create(model) as adapter:\n    adapter.forward(...)\n</code></pre> Subclassed by: <ul> <li> <code></code>\u00a0keras_backend <code></code>\u00a0KerasModelAdapter </li> <li> <code></code>\u00a0onnx_backend <code></code>\u00a0ONNXModelAdapter </li> <li> <code></code>\u00a0pytorch_backend <code></code>\u00a0PytorchModelAdapter </li> <li> <code></code>\u00a0tensorflow_backend <ul> <li> <code></code>\u00a0KerasModelAdapter </li> <li> <code></code>\u00a0TensorflowModelAdapter </li> </ul> </li> <li> <code></code>\u00a0torchscript_backend <code></code>\u00a0TorchscriptModelAdapter </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0backends <code></code>\u00a0create_model_adapter </li> <li> <code></code>\u00a0core <ul> <li> <code></code>\u00a0PredictionPipeline </li> <li> <code></code>\u00a0create_prediction_pipeline </li> </ul> </li> <li> <code></code>\u00a0model_adapters <code></code>\u00a0create_model_adapter </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>create</code> <p>Creates model adapter based on the passed spec</p> <code>forward</code> <p>Run forward pass of model to get model predictions</p> <code>load</code> <code>unload</code> <p>Unload model from any devices, freeing their memory.</p> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>def __init__(self, model_description: AnyModelDescr):\n    super().__init__()\n    self._model_descr = model_description\n    self._input_ids = get_member_ids(model_description.inputs)\n    self._output_ids = get_member_ids(model_description.outputs)\n    self._input_axes = [\n        tuple(a.id for a in get_axes_infos(t)) for t in model_description.inputs\n    ]\n    self._output_axes = [\n        tuple(a.id for a in get_axes_infos(t)) for t in model_description.outputs\n    ]\n    if isinstance(model_description, v0_4.ModelDescr):\n        self._input_is_optional = [False] * len(model_description.inputs)\n    else:\n        self._input_is_optional = [ipt.optional for ipt in model_description.inputs]\n</code></pre>"},{"location":"api/bioimageio/core/model_adapters/#bioimageio.core.model_adapters.ModelAdapter.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], *, devices: Optional[Sequence[str]] = None, weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None)\n</code></pre> <p>Creates model adapter based on the passed spec Note: All specific adapters should happen inside this function to prevent different framework initializations interfering with each other</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0backends <code></code>\u00a0create_model_adapter </li> <li> <code></code>\u00a0model_adapters <code></code>\u00a0create_model_adapter </li> </ul> </li> </ul> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\n@classmethod\ndef create(\n    cls,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    *,\n    devices: Optional[Sequence[str]] = None,\n    weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None,\n):\n    \"\"\"\n    Creates model adapter based on the passed spec\n    Note: All specific adapters should happen inside this function to prevent different framework\n    initializations interfering with each other\n    \"\"\"\n    if not isinstance(model_description, (v0_4.ModelDescr, v0_5.ModelDescr)):\n        raise TypeError(\n            f\"expected v0_4.ModelDescr or v0_5.ModelDescr, but got {type(model_description)}\"\n        )\n\n    weights = model_description.weights\n    errors: List[Exception] = []\n    weight_format_priority_order = (\n        DEFAULT_WEIGHT_FORMAT_PRIORITY_ORDER\n        if weight_format_priority_order is None\n        else weight_format_priority_order\n    )\n    # limit weight formats to the ones present\n    weight_format_priority_order_present: Sequence[SupportedWeightsFormat] = [\n        w for w in weight_format_priority_order if getattr(weights, w) is not None\n    ]\n    if not weight_format_priority_order_present:\n        raise ValueError(\n            f\"None of the specified weight formats ({weight_format_priority_order}) is present ({weight_format_priority_order_present})\"\n        )\n\n    for wf in weight_format_priority_order_present:\n        if wf == \"pytorch_state_dict\":\n            assert weights.pytorch_state_dict is not None\n            try:\n                from .pytorch_backend import PytorchModelAdapter\n\n                return PytorchModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"tensorflow_saved_model_bundle\":\n            assert weights.tensorflow_saved_model_bundle is not None\n            try:\n                from .tensorflow_backend import create_tf_model_adapter\n\n                return create_tf_model_adapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"onnx\":\n            assert weights.onnx is not None\n            try:\n                from .onnx_backend import ONNXModelAdapter\n\n                return ONNXModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"torchscript\":\n            assert weights.torchscript is not None\n            try:\n                from .torchscript_backend import TorchscriptModelAdapter\n\n                return TorchscriptModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"keras_hdf5\":\n            assert weights.keras_hdf5 is not None\n            # keras can either be installed as a separate package or used as part of tensorflow\n            # we try to first import the keras model adapter using the separate package and,\n            # if it is not available, try to load the one using tf\n            try:\n                try:\n                    from .keras_backend import KerasModelAdapter\n                except Exception:\n                    from .tensorflow_backend import KerasModelAdapter\n\n                return KerasModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        else:\n            assert_never(wf)\n\n    assert errors\n    if len(weight_format_priority_order) == 1:\n        assert len(errors) == 1\n        raise errors[0]\n\n    else:\n        msg = (\n            \"None of the weight format specific model adapters could be created\"\n            + \" in this environment.\"\n        )\n        raise ExceptionGroup(msg, errors)\n</code></pre>"},{"location":"api/bioimageio/core/model_adapters/#bioimageio.core.model_adapters.ModelAdapter.forward","title":"forward","text":"<pre><code>forward(input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]) -&gt; Sample\n</code></pre> <p>Run forward pass of model to get model predictions</p> <p>Note: sample id and stample stat attributes are passed through</p> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>def forward(\n    self, input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]\n) -&gt; Sample:\n    \"\"\"\n    Run forward pass of model to get model predictions\n\n    Note: sample id and stample stat attributes are passed through\n    \"\"\"\n    unexpected = [mid for mid in input_sample.members if mid not in self._input_ids]\n    if unexpected:\n        warnings.warn(f\"Got unexpected input tensor IDs: {unexpected}\")\n\n    input_arrays = [\n        (\n            None\n            if (a := input_sample.members.get(in_id)) is None\n            else a.transpose(in_order).data.data\n        )\n        for in_id, in_order in zip(self._input_ids, self._input_axes)\n    ]\n    output_arrays = self._forward_impl(input_arrays)\n    assert len(output_arrays) &lt;= len(self._output_ids)\n    output_tensors = [\n        None if a is None else Tensor(a, dims=d)\n        for a, d in zip(output_arrays, self._output_axes)\n    ]\n    return Sample(\n        members={\n            tid: out\n            for tid, out in zip(\n                self._output_ids,\n                output_tensors,\n            )\n            if out is not None\n        },\n        stat=input_sample.stat,\n        id=(\n            input_sample.id\n            if isinstance(input_sample, Sample)\n            else input_sample.sample_id\n        ),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/model_adapters/#bioimageio.core.model_adapters.ModelAdapter.load","title":"load","text":"<pre><code>load(*, devices: Optional[Sequence[str]] = None) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\ndef load(self, *, devices: Optional[Sequence[str]] = None) -&gt; None:\n    warnings.warn(\"Deprecated. ModelAdapter is loaded on initialization\")\n</code></pre>"},{"location":"api/bioimageio/core/model_adapters/#bioimageio.core.model_adapters.ModelAdapter.unload","title":"unload  <code>abstractmethod</code>","text":"<pre><code>unload()\n</code></pre> <p>Unload model from any devices, freeing their memory. The moder adapter should be considered unusable afterwards.</p> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@abstractmethod\ndef unload(self):\n    \"\"\"\n    Unload model from any devices, freeing their memory.\n    The moder adapter should be considered unusable afterwards.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/model_adapters/#bioimageio.core.model_adapters.get_weight_formats","title":"get_weight_formats","text":"<pre><code>get_weight_formats() -&gt; List[str]\n</code></pre> <p>Return list of supported weight types</p> Source code in <code>src/bioimageio/core/model_adapters.py</code> <pre><code>def get_weight_formats() -&gt; List[str]:\n    \"\"\"\n    Return list of supported weight types\n    \"\"\"\n    return list(DEFAULT_WEIGHT_FORMAT_PRIORITY_ORDER)\n</code></pre>"},{"location":"api/bioimageio/core/prediction/","title":"bioimageio.core.prediction","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction","title":"prediction","text":"Used by: <ul> <li> API Reference \u00a0core <ul> <li> \u00a0predict </li> <li> \u00a0predict_many </li> </ul> </li> </ul> <p>Functions:</p> Name Description <code>predict</code> <p>Run prediction for a single set of input(s) with a bioimage.io model</p> <code>predict_many</code> <p>Run prediction for a multiple sets of inputs with a bioimage.io model</p>"},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict","title":"predict","text":"<pre><code>predict(*, model: Union[PermissiveFileSource, v0_4.ModelDescr, v0_5.ModelDescr, PredictionPipeline], inputs: Union[Sample, PerMember[TensorSource], TensorSource], sample_id: Hashable = 'sample', blocksize_parameter: Optional[BlocksizeParameter] = None, input_block_shape: Optional[Mapping[MemberId, Mapping[AxisId, int]]] = None, skip_preprocessing: bool = False, skip_postprocessing: bool = False, save_output_path: Optional[Union[Path, str]] = None) -&gt; Sample\n</code></pre> <p>Run prediction for a single set of input(s) with a bioimage.io model</p> <p>Parameters:</p> Name Type Description Default <code>Union[PermissiveFileSource, v0_4.ModelDescr, v0_5.ModelDescr, PredictionPipeline]</code> <p>Model to predict with. May be given as RDF source, model description or prediction pipeline.</p> required <code>Union[Sample, PerMember[TensorSource], TensorSource]</code> <p>the input sample or the named input(s) for this model as a dictionary</p> required <code>Hashable</code> <p>the sample id. The sample_id is used to format save_output_path and to distinguish sample specific log messages.</p> <code>'sample'</code> <code>Optional[BlocksizeParameter]</code> <p>(optional) Tile the input into blocks parametrized by blocksize_parameter according to any parametrized axis sizes defined by the model. See <code>bioimageio.spec.model.v0_5.ParameterizedSize</code> for details. Note: For a predetermined, fixed block shape use input_block_shape.</p> <code>None</code> <code>Optional[Mapping[MemberId, Mapping[AxisId, int]]]</code> <p>(optional) Tile the input sample tensors into blocks. Note: Use blocksize_parameter for a parameterized block shape to     run prediction independent of the exact block shape.</p> <code>None</code> <code>bool</code> <p>Flag to skip the model's preprocessing.</p> <code>False</code> <code>bool</code> <p>Flag to skip the model's postprocessing.</p> <code>False</code> <code>Optional[Union[Path, str]]</code> <p>A path with to save the output to. M Must contain: - <code>{output_id}</code> (or <code>{member_id}</code>) if the model has multiple output tensors May contain: - <code>{sample_id}</code> to avoid overwriting recurrent calls</p> <code>None</code> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0predict </li> </ul> Source code in <code>src/bioimageio/core/prediction.py</code> <pre><code>def predict(\n    *,\n    model: Union[\n        PermissiveFileSource, v0_4.ModelDescr, v0_5.ModelDescr, PredictionPipeline\n    ],\n    inputs: Union[Sample, PerMember[TensorSource], TensorSource],\n    sample_id: Hashable = \"sample\",\n    blocksize_parameter: Optional[BlocksizeParameter] = None,\n    input_block_shape: Optional[Mapping[MemberId, Mapping[AxisId, int]]] = None,\n    skip_preprocessing: bool = False,\n    skip_postprocessing: bool = False,\n    save_output_path: Optional[Union[Path, str]] = None,\n) -&gt; Sample:\n    \"\"\"Run prediction for a single set of input(s) with a bioimage.io model\n\n    Args:\n        model: Model to predict with.\n            May be given as RDF source, model description or prediction pipeline.\n        inputs: the input sample or the named input(s) for this model as a dictionary\n        sample_id: the sample id.\n            The **sample_id** is used to format **save_output_path**\n            and to distinguish sample specific log messages.\n        blocksize_parameter: (optional) Tile the input into blocks parametrized by\n            **blocksize_parameter** according to any parametrized axis sizes defined\n            by the **model**.\n            See `bioimageio.spec.model.v0_5.ParameterizedSize` for details.\n            Note: For a predetermined, fixed block shape use **input_block_shape**.\n        input_block_shape: (optional) Tile the input sample tensors into blocks.\n            Note: Use **blocksize_parameter** for a parameterized block shape to\n                run prediction independent of the exact block shape.\n        skip_preprocessing: Flag to skip the model's preprocessing.\n        skip_postprocessing: Flag to skip the model's postprocessing.\n        save_output_path: A path with to save the output to. M\n            Must contain:\n            - `{output_id}` (or `{member_id}`) if the model has multiple output tensors\n            May contain:\n            - `{sample_id}` to avoid overwriting recurrent calls\n    \"\"\"\n    if isinstance(model, PredictionPipeline):\n        pp = model\n        model = pp.model_description\n    else:\n        if not isinstance(model, (v0_4.ModelDescr, v0_5.ModelDescr)):\n            loaded = load_description(model)\n            if not isinstance(loaded, (v0_4.ModelDescr, v0_5.ModelDescr)):\n                raise ValueError(f\"expected model description, but got {loaded}\")\n            model = loaded\n\n        pp = create_prediction_pipeline(model)\n\n    if save_output_path is not None:\n        if (\n            \"{output_id}\" not in str(save_output_path)\n            and \"{member_id}\" not in str(save_output_path)\n            and len(model.outputs) &gt; 1\n        ):\n            raise ValueError(\n                f\"Missing `{{output_id}}` in save_output_path={save_output_path} to \"\n                + \"distinguish model outputs \"\n                + str([get_member_id(d) for d in model.outputs])\n            )\n\n    if isinstance(inputs, Sample):\n        sample = inputs\n    else:\n        sample = create_sample_for_model(\n            pp.model_description, inputs=inputs, sample_id=sample_id\n        )\n\n    if input_block_shape is not None:\n        if blocksize_parameter is not None:\n            logger.warning(\n                \"ignoring blocksize_parameter={} in favor of input_block_shape={}\",\n                blocksize_parameter,\n                input_block_shape,\n            )\n\n        output = pp.predict_sample_with_fixed_blocking(\n            sample,\n            input_block_shape=input_block_shape,\n            skip_preprocessing=skip_preprocessing,\n            skip_postprocessing=skip_postprocessing,\n        )\n    elif blocksize_parameter is not None:\n        output = pp.predict_sample_with_blocking(\n            sample,\n            skip_preprocessing=skip_preprocessing,\n            skip_postprocessing=skip_postprocessing,\n            ns=blocksize_parameter,\n        )\n    else:\n        output = pp.predict_sample_without_blocking(\n            sample,\n            skip_preprocessing=skip_preprocessing,\n            skip_postprocessing=skip_postprocessing,\n        )\n    if save_output_path:\n        save_sample(save_output_path, output)\n\n    return output\n</code></pre>"},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict(model)","title":"<code>model</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict(inputs)","title":"<code>inputs</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict(sample_id)","title":"<code>sample_id</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict(blocksize_parameter)","title":"<code>blocksize_parameter</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict(input_block_shape)","title":"<code>input_block_shape</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict(skip_preprocessing)","title":"<code>skip_preprocessing</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict(skip_postprocessing)","title":"<code>skip_postprocessing</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict(save_output_path)","title":"<code>save_output_path</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict_many","title":"predict_many","text":"<pre><code>predict_many(*, model: Union[PermissiveFileSource, v0_4.ModelDescr, v0_5.ModelDescr, PredictionPipeline], inputs: Union[Iterable[PerMember[TensorSource]], Iterable[TensorSource]], sample_id: str = 'sample{i:03}', blocksize_parameter: Optional[Union[v0_5.ParameterizedSize_N, Mapping[Tuple[MemberId, AxisId], v0_5.ParameterizedSize_N]]] = None, skip_preprocessing: bool = False, skip_postprocessing: bool = False, save_output_path: Optional[Union[Path, str]] = None) -&gt; Iterator[Sample]\n</code></pre> <p>Run prediction for a multiple sets of inputs with a bioimage.io model</p> <p>Parameters:</p> Name Type Description Default <code>Union[PermissiveFileSource, v0_4.ModelDescr, v0_5.ModelDescr, PredictionPipeline]</code> <p>Model to predict with. May be given as RDF source, model description or prediction pipeline.</p> required <code>Union[Iterable[PerMember[TensorSource]], Iterable[TensorSource]]</code> <p>An iterable of the named input(s) for this model as a dictionary.</p> required <code>str</code> <p>The sample id. note: <code>{i}</code> will be formatted as the i-th sample. If <code>{i}</code> (or <code>{i:</code>) is not present and <code>inputs</code> is not an iterable <code>{i:03}</code> is appended.</p> <code>'sample{i:03}'</code> <code>Optional[Union[v0_5.ParameterizedSize_N, Mapping[Tuple[MemberId, AxisId], v0_5.ParameterizedSize_N]]]</code> <p>(optional) Tile the input into blocks parametrized by blocksize according to any parametrized axis sizes defined in the model RDF.</p> <code>None</code> <code>bool</code> <p>Flag to skip the model's preprocessing.</p> <code>False</code> <code>bool</code> <p>Flag to skip the model's postprocessing.</p> <code>False</code> <code>Optional[Union[Path, str]]</code> <p>A path to save the output to. Must contain: - <code>{sample_id}</code> to differentiate predicted samples - <code>{output_id}</code> (or <code>{member_id}</code>) if the model has multiple outputs</p> <code>None</code> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0predict_many </li> </ul> Source code in <code>src/bioimageio/core/prediction.py</code> <pre><code>def predict_many(\n    *,\n    model: Union[\n        PermissiveFileSource, v0_4.ModelDescr, v0_5.ModelDescr, PredictionPipeline\n    ],\n    inputs: Union[Iterable[PerMember[TensorSource]], Iterable[TensorSource]],\n    sample_id: str = \"sample{i:03}\",\n    blocksize_parameter: Optional[\n        Union[\n            v0_5.ParameterizedSize_N,\n            Mapping[Tuple[MemberId, AxisId], v0_5.ParameterizedSize_N],\n        ]\n    ] = None,\n    skip_preprocessing: bool = False,\n    skip_postprocessing: bool = False,\n    save_output_path: Optional[Union[Path, str]] = None,\n) -&gt; Iterator[Sample]:\n    \"\"\"Run prediction for a multiple sets of inputs with a bioimage.io model\n\n    Args:\n        model: Model to predict with.\n            May be given as RDF source, model description or prediction pipeline.\n        inputs: An iterable of the named input(s) for this model as a dictionary.\n        sample_id: The sample id.\n            note: `{i}` will be formatted as the i-th sample.\n            If `{i}` (or `{i:`) is not present and `inputs` is not an iterable `{i:03}`\n            is appended.\n        blocksize_parameter: (optional) Tile the input into blocks parametrized by\n            blocksize according to any parametrized axis sizes defined in the model RDF.\n        skip_preprocessing: Flag to skip the model's preprocessing.\n        skip_postprocessing: Flag to skip the model's postprocessing.\n        save_output_path: A path to save the output to.\n            Must contain:\n            - `{sample_id}` to differentiate predicted samples\n            - `{output_id}` (or `{member_id}`) if the model has multiple outputs\n    \"\"\"\n    if save_output_path is not None and \"{sample_id}\" not in str(save_output_path):\n        raise ValueError(\n            f\"Missing `{{sample_id}}` in save_output_path={save_output_path}\"\n            + \" to differentiate predicted samples.\"\n        )\n\n    if isinstance(model, PredictionPipeline):\n        pp = model\n    else:\n        if not isinstance(model, (v0_4.ModelDescr, v0_5.ModelDescr)):\n            loaded = load_description(model)\n            if not isinstance(loaded, (v0_4.ModelDescr, v0_5.ModelDescr)):\n                raise ValueError(f\"expected model description, but got {loaded}\")\n            model = loaded\n\n        pp = create_prediction_pipeline(model)\n\n    if not isinstance(inputs, collections.abc.Mapping):\n        if \"{i}\" not in sample_id and \"{i:\" not in sample_id:\n            sample_id += \"{i:03}\"\n\n        total = len(inputs) if isinstance(inputs, collections.abc.Sized) else None\n\n        for i, ipts in tqdm(enumerate(inputs), total=total):\n            yield predict(\n                model=pp,\n                inputs=ipts,\n                sample_id=sample_id.format(i=i),\n                blocksize_parameter=blocksize_parameter,\n                skip_preprocessing=skip_preprocessing,\n                skip_postprocessing=skip_postprocessing,\n                save_output_path=save_output_path,\n            )\n</code></pre>"},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict_many(model)","title":"<code>model</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict_many(inputs)","title":"<code>inputs</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict_many(sample_id)","title":"<code>sample_id</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict_many(blocksize_parameter)","title":"<code>blocksize_parameter</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict_many(skip_preprocessing)","title":"<code>skip_preprocessing</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict_many(skip_postprocessing)","title":"<code>skip_postprocessing</code>","text":""},{"location":"api/bioimageio/core/prediction/#bioimageio.core.prediction.predict_many(save_output_path)","title":"<code>save_output_path</code>","text":""},{"location":"api/bioimageio/core/proc_ops/","title":"bioimageio.core.proc_ops","text":""},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops","title":"proc_ops","text":"<p>Classes:</p> Name Description <code>AddKnownDatasetStats</code> <code>Binarize</code> <p>'output = tensor &gt; threshold'.</p> <code>Clip</code> <code>EnsureDtype</code> <code>FixedZeroMeanUnitVariance</code> <p>normalize to zero mean, unit variance with precomputed values.</p> <code>ScaleLinear</code> <code>ScaleMeanVariance</code> <code>ScaleRange</code> <code>Sigmoid</code> <p>1 / (1 + e^(-input)).</p> <code>Softmax</code> <p>Softmax activation function.</p> <code>UpdateStats</code> <p>Calculates sample and/or dataset measures</p> <code>ZeroMeanUnitVariance</code> <p>normalize to zero mean, unit variance.</p> <p>Functions:</p> Name Description <code>get_proc</code> <p>Attributes:</p> Name Type Description <code>ProcDescr</code> <code>Processing</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ProcDescr","title":"ProcDescr  <code>module-attribute</code>","text":"<pre><code>ProcDescr = Union[v0_4.PreprocessingDescr, v0_4.PostprocessingDescr, v0_5.PreprocessingDescr, v0_5.PostprocessingDescr]\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0get_proc </li> </ul>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Processing","title":"Processing  <code>module-attribute</code>","text":"<pre><code>Processing = Union[AddKnownDatasetStats, Binarize, Clip, EnsureDtype, FixedZeroMeanUnitVariance, ScaleLinear, ScaleMeanVariance, ScaleRange, Sigmoid, Softmax, UpdateStats, ZeroMeanUnitVariance]\n</code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0get_proc </li> </ul> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0PredictionPipeline </li> </ul>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.AddKnownDatasetStats","title":"AddKnownDatasetStats  <code>dataclass</code>","text":"<pre><code>AddKnownDatasetStats(dataset_stats: Mapping[DatasetMeasure, MeasureValue])\n</code></pre> <p>               Bases: <code>BlockedOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.AddKnownDatasetStats[AddKnownDatasetStats]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops.AddKnownDatasetStats\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n              click bioimageio.core.proc_ops.AddKnownDatasetStats href \"\" \"bioimageio.core.proc_ops.AddKnownDatasetStats\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <p>Attributes:</p> Name Type Description <code>dataset_stats</code> <code>Mapping[DatasetMeasure, MeasureValue]</code> <code>required_measures</code> <code>Set[Measure]</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.AddKnownDatasetStats.dataset_stats","title":"dataset_stats  <code>instance-attribute</code>","text":"<pre><code>dataset_stats: Mapping[DatasetMeasure, MeasureValue]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.AddKnownDatasetStats.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures: Set[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.AddKnownDatasetStats.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    sample.stat.update(self.dataset_stats.items())\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Binarize","title":"Binarize  <code>dataclass</code>","text":"<pre><code>Binarize(input: MemberId, output: MemberId, threshold: Union[float, Sequence[float]], axis: Optional[AxisId] = None)\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.Binarize[Binarize]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.Binarize\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.Binarize href \"\" \"bioimageio.core.proc_ops.Binarize\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> <p>'output = tensor &gt; threshold'.</p> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>from_proc_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>axis</code> <code>Optional[AxisId]</code> <code>input</code> <code>MemberId</code> <code>output</code> <code>MemberId</code> <code>required_measures</code> <code>Collection[Measure]</code> <code>threshold</code> <code>Union[float, Sequence[float]]</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Binarize.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axis: Optional[AxisId] = None\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Binarize.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Binarize.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Binarize.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures: Collection[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Binarize.threshold","title":"threshold  <code>instance-attribute</code>","text":"<pre><code>threshold: Union[float, Sequence[float]]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Binarize.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Binarize.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: Union[v0_4.BinarizeDescr, v0_5.BinarizeDescr], member_id: MemberId) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(\n    cls, descr: Union[v0_4.BinarizeDescr, v0_5.BinarizeDescr], member_id: MemberId\n) -&gt; Self:\n    if isinstance(descr.kwargs, (v0_4.BinarizeKwargs, v0_5.BinarizeKwargs)):\n        return cls(\n            input=member_id, output=member_id, threshold=descr.kwargs.threshold\n        )\n    elif isinstance(descr.kwargs, v0_5.BinarizeAlongAxisKwargs):\n        return cls(\n            input=member_id,\n            output=member_id,\n            threshold=descr.kwargs.threshold,\n            axis=descr.kwargs.axis,\n        )\n    else:\n        assert_never(descr.kwargs)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Binarize.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip","title":"Clip  <code>dataclass</code>","text":"<pre><code>Clip(input: MemberId, output: MemberId, min: Optional[Union[float, SampleQuantile, DatasetQuantile]] = None, max: Optional[Union[float, SampleQuantile, DatasetQuantile]] = None)\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.Clip[Clip]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.Clip\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.Clip href \"\" \"bioimageio.core.proc_ops.Clip\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>__post_init__</code> <code>from_proc_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>input</code> <code>MemberId</code> <code>max</code> <code>Optional[Union[float, SampleQuantile, DatasetQuantile]]</code> <p>maximum value for clipping</p> <code>min</code> <code>Optional[Union[float, SampleQuantile, DatasetQuantile]]</code> <p>minimum value for clipping</p> <code>output</code> <code>MemberId</code> <code>required_measures</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip.max","title":"max  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max: Optional[Union[float, SampleQuantile, DatasetQuantile]] = None\n</code></pre> <p>maximum value for clipping</p>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip.min","title":"min  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min: Optional[Union[float, SampleQuantile, DatasetQuantile]] = None\n</code></pre> <p>minimum value for clipping</p>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __post_init__(self):\n    if self.min is None and self.max is None:\n        raise ValueError(\"missing min or max value\")\n\n    if (\n        isinstance(self.min, float)\n        and isinstance(self.max, float)\n        and self.min &gt;= self.max\n    ):\n        raise ValueError(f\"expected min &lt; max, but {self.min} &gt;= {self.max}\")\n\n    if isinstance(self.min, (SampleQuantile, DatasetQuantile)) and isinstance(\n        self.max, (SampleQuantile, DatasetQuantile)\n    ):\n        if self.min.axes != self.max.axes:\n            raise NotImplementedError(\n                f\"expected min and max quantiles with same axes, but got {self.min.axes} and {self.max.axes}\"\n            )\n        if self.min.q &gt;= self.max.q:\n            raise ValueError(\n                f\"expected min quantile &lt; max quantile, but {self.min.q} &gt;= {self.max.q}\"\n            )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: Union[v0_4.ClipDescr, v0_5.ClipDescr], member_id: MemberId) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(\n    cls, descr: Union[v0_4.ClipDescr, v0_5.ClipDescr], member_id: MemberId\n) -&gt; Self:\n    if isinstance(descr, v0_5.ClipDescr):\n        dataset_mode, axes = _get_axes(descr.kwargs)\n        if dataset_mode:\n            Quantile = DatasetQuantile\n        else:\n            Quantile = partial(SampleQuantile, method=\"inverted_cdf\")\n\n        if descr.kwargs.min is not None:\n            min_arg = descr.kwargs.min\n        elif descr.kwargs.min_percentile is not None:\n            min_arg = Quantile(\n                q=descr.kwargs.min_percentile / 100,\n                axes=axes,\n                member_id=member_id,\n            )\n        else:\n            min_arg = None\n\n        if descr.kwargs.max is not None:\n            max_arg = descr.kwargs.max\n        elif descr.kwargs.max_percentile is not None:\n            max_arg = Quantile(\n                q=descr.kwargs.max_percentile / 100,\n                axes=axes,\n                member_id=member_id,\n            )\n        else:\n            max_arg = None\n\n    elif isinstance(descr, v0_4.ClipDescr):\n        min_arg = descr.kwargs.min\n        max_arg = descr.kwargs.max\n    else:\n        assert_never(descr)\n\n    return cls(\n        input=member_id,\n        output=member_id,\n        min=min_arg,\n        max=max_arg,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Clip.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.EnsureDtype","title":"EnsureDtype  <code>dataclass</code>","text":"<pre><code>EnsureDtype(input: MemberId, output: MemberId, dtype: DTypeStr)\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.EnsureDtype[EnsureDtype]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.EnsureDtype\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.EnsureDtype href \"\" \"bioimageio.core.proc_ops.EnsureDtype\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>from_proc_descr</code> <code>get_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>dtype</code> <code>DTypeStr</code> <code>input</code> <code>MemberId</code> <code>output</code> <code>MemberId</code> <code>required_measures</code> <code>Collection[Measure]</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.EnsureDtype.dtype","title":"dtype  <code>instance-attribute</code>","text":"<pre><code>dtype: DTypeStr\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.EnsureDtype.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.EnsureDtype.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.EnsureDtype.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures: Collection[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.EnsureDtype.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.EnsureDtype.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: v0_5.EnsureDtypeDescr, member_id: MemberId)\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(cls, descr: v0_5.EnsureDtypeDescr, member_id: MemberId):\n    return cls(input=member_id, output=member_id, dtype=descr.kwargs.dtype)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.EnsureDtype.get_descr","title":"get_descr","text":"<pre><code>get_descr()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_descr(self):\n    return v0_5.EnsureDtypeDescr(kwargs=v0_5.EnsureDtypeKwargs(dtype=self.dtype))\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.EnsureDtype.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance","title":"FixedZeroMeanUnitVariance  <code>dataclass</code>","text":"<pre><code>FixedZeroMeanUnitVariance(input: MemberId, output: MemberId, mean: Union[float, xr.DataArray], std: Union[float, xr.DataArray], eps: float = 1e-06)\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.FixedZeroMeanUnitVariance[FixedZeroMeanUnitVariance]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.FixedZeroMeanUnitVariance\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.FixedZeroMeanUnitVariance href \"\" \"bioimageio.core.proc_ops.FixedZeroMeanUnitVariance\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> <p>normalize to zero mean, unit variance with precomputed values.</p> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>__post_init__</code> <code>from_proc_descr</code> <code>get_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>eps</code> <code>float</code> <code>input</code> <code>MemberId</code> <code>mean</code> <code>Union[float, xr.DataArray]</code> <code>output</code> <code>MemberId</code> <code>required_measures</code> <code>Collection[Measure]</code> <code>std</code> <code>Union[float, xr.DataArray]</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.eps","title":"eps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eps: float = 1e-06\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.mean","title":"mean  <code>instance-attribute</code>","text":"<pre><code>mean: Union[float, xr.DataArray]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures: Collection[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.std","title":"std  <code>instance-attribute</code>","text":"<pre><code>std: Union[float, xr.DataArray]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __post_init__(self):\n    assert (\n        isinstance(self.mean, (int, float))\n        or isinstance(self.std, (int, float))\n        or self.mean.dims == self.std.dims\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: v0_5.FixedZeroMeanUnitVarianceDescr, member_id: MemberId) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(\n    cls,\n    descr: v0_5.FixedZeroMeanUnitVarianceDescr,\n    member_id: MemberId,\n) -&gt; Self:\n    if isinstance(descr.kwargs, v0_5.FixedZeroMeanUnitVarianceKwargs):\n        dims = None\n    elif isinstance(descr.kwargs, v0_5.FixedZeroMeanUnitVarianceAlongAxisKwargs):\n        dims = (AxisId(descr.kwargs.axis),)\n    else:\n        assert_never(descr.kwargs)\n\n    return cls(\n        input=member_id,\n        output=member_id,\n        mean=xr.DataArray(descr.kwargs.mean, dims=dims),\n        std=xr.DataArray(descr.kwargs.std, dims=dims),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.get_descr","title":"get_descr","text":"<pre><code>get_descr()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_descr(self):\n    if isinstance(self.mean, (int, float)):\n        assert isinstance(self.std, (int, float))\n        kwargs = v0_5.FixedZeroMeanUnitVarianceKwargs(mean=self.mean, std=self.std)\n    else:\n        assert isinstance(self.std, xr.DataArray)\n        assert len(self.mean.dims) == 1\n        kwargs = v0_5.FixedZeroMeanUnitVarianceAlongAxisKwargs(\n            axis=AxisId(str(self.mean.dims[0])),\n            mean=list(self.mean),\n            std=list(self.std),\n        )\n\n    return v0_5.FixedZeroMeanUnitVarianceDescr(kwargs=kwargs)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.FixedZeroMeanUnitVariance.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleLinear","title":"ScaleLinear  <code>dataclass</code>","text":"<pre><code>ScaleLinear(input: MemberId, output: MemberId, gain: Union[float, xr.DataArray] = 1.0, offset: Union[float, xr.DataArray] = 0.0)\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.ScaleLinear[ScaleLinear]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.ScaleLinear\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.ScaleLinear href \"\" \"bioimageio.core.proc_ops.ScaleLinear\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>from_proc_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>gain</code> <code>Union[float, xr.DataArray]</code> <p>multiplicative factor</p> <code>input</code> <code>MemberId</code> <code>offset</code> <code>Union[float, xr.DataArray]</code> <p>additive term</p> <code>output</code> <code>MemberId</code> <code>required_measures</code> <code>Collection[Measure]</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleLinear.gain","title":"gain  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gain: Union[float, xr.DataArray] = 1.0\n</code></pre> <p>multiplicative factor</p>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleLinear.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleLinear.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>offset: Union[float, xr.DataArray] = 0.0\n</code></pre> <p>additive term</p>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleLinear.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleLinear.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures: Collection[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleLinear.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleLinear.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: Union[v0_4.ScaleLinearDescr, v0_5.ScaleLinearDescr], member_id: MemberId) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(\n    cls,\n    descr: Union[v0_4.ScaleLinearDescr, v0_5.ScaleLinearDescr],\n    member_id: MemberId,\n) -&gt; Self:\n    kwargs = descr.kwargs\n    if isinstance(kwargs, v0_5.ScaleLinearKwargs):\n        axis = None\n    elif isinstance(kwargs, v0_5.ScaleLinearAlongAxisKwargs):\n        axis = kwargs.axis\n    elif isinstance(kwargs, v0_4.ScaleLinearKwargs):\n        if kwargs.axes is not None:\n            raise NotImplementedError(\n                \"model.v0_4.ScaleLinearKwargs with axes not implemented, please consider updating the model to v0_5.\"\n            )\n        axis = None\n    else:\n        assert_never(kwargs)\n\n    if axis:\n        gain = xr.DataArray(np.atleast_1d(kwargs.gain), dims=axis)\n        offset = xr.DataArray(np.atleast_1d(kwargs.offset), dims=axis)\n    else:\n        assert isinstance(kwargs.gain, (float, int)) or len(kwargs.gain) == 1, (\n            kwargs.gain\n        )\n        gain = (\n            kwargs.gain if isinstance(kwargs.gain, (float, int)) else kwargs.gain[0]\n        )\n        assert isinstance(kwargs.offset, (float, int)) or len(kwargs.offset) == 1\n        offset = (\n            kwargs.offset\n            if isinstance(kwargs.offset, (float, int))\n            else kwargs.offset[0]\n        )\n\n    return cls(input=member_id, output=member_id, gain=gain, offset=offset)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleLinear.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance","title":"ScaleMeanVariance  <code>dataclass</code>","text":"<pre><code>ScaleMeanVariance(input: MemberId, output: MemberId, axes: Optional[Sequence[AxisId]] = None, reference_tensor: Optional[MemberId] = None, eps: float = 1e-06)\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.ScaleMeanVariance[ScaleMeanVariance]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.ScaleMeanVariance\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.ScaleMeanVariance href \"\" \"bioimageio.core.proc_ops.ScaleMeanVariance\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>__post_init__</code> <code>from_proc_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>axes</code> <code>Optional[Sequence[AxisId]]</code> <code>eps</code> <code>float</code> <code>input</code> <code>MemberId</code> <code>mean</code> <code>Union[SampleMean, DatasetMean]</code> <code>output</code> <code>MemberId</code> <code>ref_mean</code> <code>Union[SampleMean, DatasetMean]</code> <code>ref_std</code> <code>Union[SampleStd, DatasetStd]</code> <code>reference_tensor</code> <code>Optional[MemberId]</code> <code>required_measures</code> <code>std</code> <code>Union[SampleStd, DatasetStd]</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.axes","title":"axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axes: Optional[Sequence[AxisId]] = None\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.eps","title":"eps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eps: float = 1e-06\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.mean","title":"mean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mean: Union[SampleMean, DatasetMean] = field(init=False)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.ref_mean","title":"ref_mean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ref_mean: Union[SampleMean, DatasetMean] = field(init=False)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.ref_std","title":"ref_std  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ref_std: Union[SampleStd, DatasetStd] = field(init=False)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.reference_tensor","title":"reference_tensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reference_tensor: Optional[MemberId] = None\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.std","title":"std  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>std: Union[SampleStd, DatasetStd] = field(init=False)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __post_init__(self):\n    axes = None if self.axes is None else tuple(self.axes)\n    ref_tensor = self.reference_tensor or self.input\n    if axes is None or AxisId(\"batch\") not in axes:\n        Mean = SampleMean\n        Std = SampleStd\n    else:\n        Mean = DatasetMean\n        Std = DatasetStd\n\n    self.mean = Mean(member_id=self.input, axes=axes)\n    self.std = Std(member_id=self.input, axes=axes)\n    self.ref_mean = Mean(member_id=ref_tensor, axes=axes)\n    self.ref_std = Std(member_id=ref_tensor, axes=axes)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: Union[v0_4.ScaleMeanVarianceDescr, v0_5.ScaleMeanVarianceDescr], member_id: MemberId) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(\n    cls,\n    descr: Union[v0_4.ScaleMeanVarianceDescr, v0_5.ScaleMeanVarianceDescr],\n    member_id: MemberId,\n) -&gt; Self:\n    kwargs = descr.kwargs\n    _, axes = _get_axes(descr.kwargs)\n\n    return cls(\n        input=member_id,\n        output=member_id,\n        reference_tensor=MemberId(str(kwargs.reference_tensor)),\n        axes=axes,\n        eps=kwargs.eps,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleMeanVariance.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange","title":"ScaleRange  <code>dataclass</code>","text":"<pre><code>ScaleRange(input: MemberId, output: MemberId, lower_quantile: InitVar[Optional[Union[SampleQuantile, DatasetQuantile]]] = None, upper_quantile: InitVar[Optional[Union[SampleQuantile, DatasetQuantile]]] = None, eps: float = 1e-06)\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.ScaleRange[ScaleRange]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.ScaleRange\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.ScaleRange href \"\" \"bioimageio.core.proc_ops.ScaleRange\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>__post_init__</code> <code>from_proc_descr</code> <code>get_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>eps</code> <code>float</code> <code>input</code> <code>MemberId</code> <code>lower</code> <code>Union[SampleQuantile, DatasetQuantile]</code> <code>output</code> <code>MemberId</code> <code>required_measures</code> <code>upper</code> <code>Union[SampleQuantile, DatasetQuantile]</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.eps","title":"eps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eps: float = 1e-06\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.lower","title":"lower  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower: Union[SampleQuantile, DatasetQuantile] = field(init=False)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.upper","title":"upper  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper: Union[SampleQuantile, DatasetQuantile] = field(init=False)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__(lower_quantile: Optional[Union[SampleQuantile, DatasetQuantile]], upper_quantile: Optional[Union[SampleQuantile, DatasetQuantile]])\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __post_init__(\n    self,\n    lower_quantile: Optional[Union[SampleQuantile, DatasetQuantile]],\n    upper_quantile: Optional[Union[SampleQuantile, DatasetQuantile]],\n):\n    if lower_quantile is None:\n        tid = self.input if upper_quantile is None else upper_quantile.member_id\n        self.lower = DatasetQuantile(q=0.0, member_id=tid)\n    else:\n        self.lower = lower_quantile\n\n    if upper_quantile is None:\n        self.upper = DatasetQuantile(q=1.0, member_id=self.lower.member_id)\n    else:\n        self.upper = upper_quantile\n\n    assert self.lower.member_id == self.upper.member_id\n    assert self.lower.q &lt; self.upper.q\n    assert self.lower.axes == self.upper.axes\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: Union[v0_4.ScaleRangeDescr, v0_5.ScaleRangeDescr], member_id: MemberId)\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(\n    cls,\n    descr: Union[v0_4.ScaleRangeDescr, v0_5.ScaleRangeDescr],\n    member_id: MemberId,\n):\n    kwargs = descr.kwargs\n    ref_tensor = (\n        member_id\n        if kwargs.reference_tensor is None\n        else MemberId(str(kwargs.reference_tensor))\n    )\n    dataset_mode, axes = _get_axes(descr.kwargs)\n    if dataset_mode:\n        Quantile = DatasetQuantile\n    else:\n        Quantile = partial(SampleQuantile, method=\"linear\")\n\n    return cls(\n        input=member_id,\n        output=member_id,\n        lower_quantile=Quantile(\n            q=kwargs.min_percentile / 100,\n            axes=axes,\n            member_id=ref_tensor,\n        ),\n        upper_quantile=Quantile(\n            q=kwargs.max_percentile / 100,\n            axes=axes,\n            member_id=ref_tensor,\n        ),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.get_descr","title":"get_descr","text":"<pre><code>get_descr()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_descr(self):\n    assert self.lower.axes == self.upper.axes\n    assert self.lower.member_id == self.upper.member_id\n\n    return v0_5.ScaleRangeDescr(\n        kwargs=v0_5.ScaleRangeKwargs(\n            axes=self.lower.axes,\n            min_percentile=self.lower.q * 100,\n            max_percentile=self.upper.q * 100,\n            eps=self.eps,\n            reference_tensor=self.lower.member_id,\n        )\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ScaleRange.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Sigmoid","title":"Sigmoid  <code>dataclass</code>","text":"<pre><code>Sigmoid(input: MemberId, output: MemberId)\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.Sigmoid[Sigmoid]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.Sigmoid\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.Sigmoid href \"\" \"bioimageio.core.proc_ops.Sigmoid\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> <p>1 / (1 + e^(-input)).</p> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>from_proc_descr</code> <code>get_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>input</code> <code>MemberId</code> <code>output</code> <code>MemberId</code> <code>required_measures</code> <code>Collection[Measure]</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Sigmoid.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Sigmoid.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Sigmoid.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures: Collection[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Sigmoid.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Sigmoid.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: Union[v0_4.SigmoidDescr, v0_5.SigmoidDescr], member_id: MemberId) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(\n    cls, descr: Union[v0_4.SigmoidDescr, v0_5.SigmoidDescr], member_id: MemberId\n) -&gt; Self:\n    assert isinstance(descr, (v0_4.SigmoidDescr, v0_5.SigmoidDescr))\n    return cls(input=member_id, output=member_id)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Sigmoid.get_descr","title":"get_descr","text":"<pre><code>get_descr()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_descr(self):\n    return v0_5.SigmoidDescr()\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Sigmoid.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Softmax","title":"Softmax  <code>dataclass</code>","text":"<pre><code>Softmax(input: MemberId, output: MemberId, axis: AxisId = AxisId('channel'))\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.Softmax[Softmax]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.Softmax\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.Softmax href \"\" \"bioimageio.core.proc_ops.Softmax\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> <p>Softmax activation function.</p> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>from_proc_descr</code> <code>get_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>axis</code> <code>AxisId</code> <code>input</code> <code>MemberId</code> <code>output</code> <code>MemberId</code> <code>required_measures</code> <code>Collection[Measure]</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Softmax.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axis: AxisId = AxisId('channel')\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Softmax.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Softmax.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Softmax.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures: Collection[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Softmax.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Softmax.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: v0_5.SoftmaxDescr, member_id: MemberId) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(cls, descr: v0_5.SoftmaxDescr, member_id: MemberId) -&gt; Self:\n    assert isinstance(descr, v0_5.SoftmaxDescr)\n    return cls(input=member_id, output=member_id, axis=descr.kwargs.axis)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Softmax.get_descr","title":"get_descr","text":"<pre><code>get_descr()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_descr(self):\n    return v0_5.SoftmaxDescr(kwargs=v0_5.SoftmaxKwargs(axis=self.axis))\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.Softmax.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.UpdateStats","title":"UpdateStats  <code>dataclass</code>","text":"<pre><code>UpdateStats(stats_calculator: StatsCalculator, keep_updating_initial_dataset_stats: bool = False)\n</code></pre> <p>               Bases: <code>Operator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.UpdateStats[UpdateStats]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core._op_base.Operator --&gt; bioimageio.core.proc_ops.UpdateStats\n                \n\n\n              click bioimageio.core.proc_ops.UpdateStats href \"\" \"bioimageio.core.proc_ops.UpdateStats\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> <p>Calculates sample and/or dataset measures</p> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>__post_init__</code> <p>Attributes:</p> Name Type Description <code>keep_updating_initial_dataset_stats</code> <code>bool</code> <p>indicates if operator calls should keep updating initial dataset statistics or not;</p> <code>required_measures</code> <code>Set[Measure]</code> <code>stats_calculator</code> <code>StatsCalculator</code> <p><code>StatsCalculator</code> to be used by this operator.</p>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.UpdateStats.keep_updating_initial_dataset_stats","title":"keep_updating_initial_dataset_stats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keep_updating_initial_dataset_stats: bool = False\n</code></pre> <p>indicates if operator calls should keep updating initial dataset statistics or not; if the <code>stats_calculator</code> was not provided with any initial dataset statistics, these are always updated with every new sample.</p>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.UpdateStats.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures: Set[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.UpdateStats.stats_calculator","title":"stats_calculator  <code>instance-attribute</code>","text":"<pre><code>stats_calculator: StatsCalculator\n</code></pre> <p><code>StatsCalculator</code> to be used by this operator.</p>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.UpdateStats.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlockWithOrigin]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlockWithOrigin]) -&gt; None:\n    if isinstance(sample, SampleBlockWithOrigin):\n        # update stats with whole sample on first block\n        if sample.block_index != 0:\n            return\n\n        origin = sample.origin\n    else:\n        origin = sample\n\n    if self._keep_updating_dataset_stats:\n        sample.stat.update(self.stats_calculator.update_and_get_all(origin))\n    else:\n        sample.stat.update(self.stats_calculator.skip_update_and_get_all(origin))\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.UpdateStats.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __post_init__(self):\n    self._keep_updating_dataset_stats = (\n        self.keep_updating_initial_dataset_stats\n        or not self.stats_calculator.has_dataset_measures\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance","title":"ZeroMeanUnitVariance  <code>dataclass</code>","text":"<pre><code>ZeroMeanUnitVariance(input: MemberId, output: MemberId, mean: MeanMeasure, std: StdMeasure, eps: float = 1e-06)\n</code></pre> <p>               Bases: <code>_SimpleOperator</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_ops.ZeroMeanUnitVariance[ZeroMeanUnitVariance]\n              bioimageio.core.proc_ops._SimpleOperator[_SimpleOperator]\n              bioimageio.core._op_base.BlockedOperator[BlockedOperator]\n              bioimageio.core._op_base.Operator[Operator]\n\n                              bioimageio.core.proc_ops._SimpleOperator --&gt; bioimageio.core.proc_ops.ZeroMeanUnitVariance\n                                bioimageio.core._op_base.BlockedOperator --&gt; bioimageio.core.proc_ops._SimpleOperator\n                                bioimageio.core._op_base.Operator --&gt; bioimageio.core._op_base.BlockedOperator\n                \n\n\n\n\n              click bioimageio.core.proc_ops.ZeroMeanUnitVariance href \"\" \"bioimageio.core.proc_ops.ZeroMeanUnitVariance\"\n              click bioimageio.core.proc_ops._SimpleOperator href \"\" \"bioimageio.core.proc_ops._SimpleOperator\"\n              click bioimageio.core._op_base.BlockedOperator href \"\" \"bioimageio.core._op_base.BlockedOperator\"\n              click bioimageio.core._op_base.Operator href \"\" \"bioimageio.core._op_base.Operator\"\n            </code></pre> <p>normalize to zero mean, unit variance.</p> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0Processing </li> </ul> <p>Methods:</p> Name Description <code>__call__</code> <code>__post_init__</code> <code>from_proc_descr</code> <code>get_descr</code> <code>get_output_shape</code> <p>Attributes:</p> Name Type Description <code>eps</code> <code>float</code> <code>input</code> <code>MemberId</code> <code>mean</code> <code>MeanMeasure</code> <code>output</code> <code>MemberId</code> <code>required_measures</code> <code>Set[Union[MeanMeasure, StdMeasure]]</code> <code>std</code> <code>StdMeasure</code>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.eps","title":"eps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eps: float = 1e-06\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.mean","title":"mean  <code>instance-attribute</code>","text":"<pre><code>mean: MeanMeasure\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.required_measures","title":"required_measures  <code>property</code>","text":"<pre><code>required_measures: Set[Union[MeanMeasure, StdMeasure]]\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.std","title":"std  <code>instance-attribute</code>","text":"<pre><code>std: StdMeasure\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.__call__","title":"__call__","text":"<pre><code>__call__(sample: Union[Sample, SampleBlock]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __call__(self, sample: Union[Sample, SampleBlock]) -&gt; None:\n    if self.input not in sample.members:\n        return\n\n    input_tensor = sample.members[self.input]\n    output_tensor = self._apply(input_tensor, sample.stat)\n\n    if self.output in sample.members:\n        assert (\n            sample.members[self.output].tagged_shape == output_tensor.tagged_shape\n        )\n\n    if isinstance(sample, Sample):\n        sample.members[self.output] = output_tensor\n    elif isinstance(sample, SampleBlock):\n        b = sample.blocks[self.input]\n        sample.blocks[self.output] = Block(\n            sample_shape=self.get_output_shape(sample.shape[self.input]),\n            data=output_tensor,\n            inner_slice=b.inner_slice,\n            halo=b.halo,\n            block_index=b.block_index,\n            blocks_in_sample=b.blocks_in_sample,\n        )\n    else:\n        assert_never(sample)\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def __post_init__(self):\n    assert self.mean.axes == self.std.axes\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.from_proc_descr","title":"from_proc_descr  <code>classmethod</code>","text":"<pre><code>from_proc_descr(descr: Union[v0_4.ZeroMeanUnitVarianceDescr, v0_5.ZeroMeanUnitVarianceDescr], member_id: MemberId)\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>@classmethod\ndef from_proc_descr(\n    cls,\n    descr: Union[v0_4.ZeroMeanUnitVarianceDescr, v0_5.ZeroMeanUnitVarianceDescr],\n    member_id: MemberId,\n):\n    dataset_mode, axes = _get_axes(descr.kwargs)\n\n    if dataset_mode:\n        Mean = DatasetMean\n        Std = DatasetStd\n    else:\n        Mean = SampleMean\n        Std = SampleStd\n\n    return cls(\n        input=member_id,\n        output=member_id,\n        mean=Mean(axes=axes, member_id=member_id),\n        std=Std(axes=axes, member_id=member_id),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.get_descr","title":"get_descr","text":"<pre><code>get_descr()\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_descr(self):\n    return v0_5.ZeroMeanUnitVarianceDescr(\n        kwargs=v0_5.ZeroMeanUnitVarianceKwargs(axes=self.mean.axes, eps=self.eps)\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.ZeroMeanUnitVariance.get_output_shape","title":"get_output_shape","text":"<pre><code>get_output_shape(input_shape: Mapping[AxisId, int]) -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_output_shape(\n    self, input_shape: Mapping[AxisId, int]\n) -&gt; Mapping[AxisId, int]:\n    return input_shape\n</code></pre>"},{"location":"api/bioimageio/core/proc_ops/#bioimageio.core.proc_ops.get_proc","title":"get_proc","text":"<pre><code>get_proc(proc_descr: ProcDescr, tensor_descr: Union[v0_4.InputTensorDescr, v0_4.OutputTensorDescr, v0_5.InputTensorDescr, v0_5.OutputTensorDescr]) -&gt; Processing\n</code></pre> Source code in <code>src/bioimageio/core/proc_ops.py</code> <pre><code>def get_proc(\n    proc_descr: ProcDescr,\n    tensor_descr: Union[\n        v0_4.InputTensorDescr,\n        v0_4.OutputTensorDescr,\n        v0_5.InputTensorDescr,\n        v0_5.OutputTensorDescr,\n    ],\n) -&gt; Processing:\n    member_id = get_member_id(tensor_descr)\n\n    if isinstance(proc_descr, (v0_4.BinarizeDescr, v0_5.BinarizeDescr)):\n        return Binarize.from_proc_descr(proc_descr, member_id)\n    elif isinstance(proc_descr, (v0_4.ClipDescr, v0_5.ClipDescr)):\n        return Clip.from_proc_descr(proc_descr, member_id)\n    elif isinstance(proc_descr, v0_5.EnsureDtypeDescr):\n        return EnsureDtype.from_proc_descr(proc_descr, member_id)\n    elif isinstance(proc_descr, v0_5.FixedZeroMeanUnitVarianceDescr):\n        return FixedZeroMeanUnitVariance.from_proc_descr(proc_descr, member_id)\n    elif isinstance(proc_descr, (v0_4.ScaleLinearDescr, v0_5.ScaleLinearDescr)):\n        return ScaleLinear.from_proc_descr(proc_descr, member_id)\n    elif isinstance(\n        proc_descr, (v0_4.ScaleMeanVarianceDescr, v0_5.ScaleMeanVarianceDescr)\n    ):\n        return ScaleMeanVariance.from_proc_descr(proc_descr, member_id)\n    elif isinstance(proc_descr, (v0_4.ScaleRangeDescr, v0_5.ScaleRangeDescr)):\n        return ScaleRange.from_proc_descr(proc_descr, member_id)\n    elif isinstance(proc_descr, (v0_4.SigmoidDescr, v0_5.SigmoidDescr)):\n        return Sigmoid.from_proc_descr(proc_descr, member_id)\n    elif (\n        isinstance(proc_descr, v0_4.ZeroMeanUnitVarianceDescr)\n        and proc_descr.kwargs.mode == \"fixed\"\n    ):\n        if not isinstance(\n            tensor_descr, (v0_4.InputTensorDescr, v0_4.OutputTensorDescr)\n        ):\n            raise TypeError(\n                \"Expected v0_4 tensor description for v0_4 processing description\"\n            )\n\n        v5_proc_descr = _convert_proc(proc_descr, tensor_descr.axes)\n        assert isinstance(v5_proc_descr, v0_5.FixedZeroMeanUnitVarianceDescr)\n        return FixedZeroMeanUnitVariance.from_proc_descr(v5_proc_descr, member_id)\n    elif isinstance(\n        proc_descr,\n        (v0_4.ZeroMeanUnitVarianceDescr, v0_5.ZeroMeanUnitVarianceDescr),\n    ):\n        return ZeroMeanUnitVariance.from_proc_descr(proc_descr, member_id)\n    elif isinstance(proc_descr, v0_5.SoftmaxDescr):\n        return Softmax.from_proc_descr(proc_descr, member_id)\n    else:\n        assert_never(proc_descr)\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/","title":"bioimageio.core.proc_setup","text":""},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup","title":"proc_setup","text":"<p>Classes:</p> Name Description <code>PreAndPostprocessing</code> <code>RequiredDatasetMeasures</code> <code>RequiredMeasures</code> <code>RequiredSampleMeasures</code> <p>Functions:</p> Name Description <code>get_pre_and_postprocessing</code> <p>Creates callables to apply pre- and postprocessing in-place to a sample</p> <code>get_required_dataset_measures</code> <code>get_requried_measures</code> <code>get_requried_sample_measures</code> <code>setup_pre_and_postprocessing</code> <p>Get pre- and postprocessing operators for a <code>model</code> description.</p> <p>Attributes:</p> Name Type Description <code>TensorDescr</code>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.TensorDescr","title":"TensorDescr  <code>module-attribute</code>","text":"<pre><code>TensorDescr = Union[v0_4.InputTensorDescr, v0_4.OutputTensorDescr, v0_5.InputTensorDescr, v0_5.OutputTensorDescr]\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.PreAndPostprocessing","title":"PreAndPostprocessing","text":"<p>               Bases: <code>NamedTuple</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_setup.PreAndPostprocessing[PreAndPostprocessing]\n\n              \n\n              click bioimageio.core.proc_setup.PreAndPostprocessing href \"\" \"bioimageio.core.proc_setup.PreAndPostprocessing\"\n            </code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0proc_setup <code></code>\u00a0setup_pre_and_postprocessing </li> </ul> <p>Attributes:</p> Name Type Description <code>post</code> <code>List[Processing]</code> <code>pre</code> <code>List[Processing]</code>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.PreAndPostprocessing.post","title":"post  <code>instance-attribute</code>","text":"<pre><code>post: List[Processing]\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.PreAndPostprocessing.pre","title":"pre  <code>instance-attribute</code>","text":"<pre><code>pre: List[Processing]\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.RequiredDatasetMeasures","title":"RequiredDatasetMeasures","text":"<p>               Bases: <code>NamedTuple</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_setup.RequiredDatasetMeasures[RequiredDatasetMeasures]\n\n              \n\n              click bioimageio.core.proc_setup.RequiredDatasetMeasures href \"\" \"bioimageio.core.proc_setup.RequiredDatasetMeasures\"\n            </code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0proc_setup <code></code>\u00a0get_required_dataset_measures </li> </ul> <p>Attributes:</p> Name Type Description <code>post</code> <code>Set[DatasetMeasure]</code> <code>pre</code> <code>Set[DatasetMeasure]</code>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.RequiredDatasetMeasures.post","title":"post  <code>instance-attribute</code>","text":"<pre><code>post: Set[DatasetMeasure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.RequiredDatasetMeasures.pre","title":"pre  <code>instance-attribute</code>","text":"<pre><code>pre: Set[DatasetMeasure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.RequiredMeasures","title":"RequiredMeasures","text":"<p>               Bases: <code>NamedTuple</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_setup.RequiredMeasures[RequiredMeasures]\n\n              \n\n              click bioimageio.core.proc_setup.RequiredMeasures href \"\" \"bioimageio.core.proc_setup.RequiredMeasures\"\n            </code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0proc_setup <code></code>\u00a0get_requried_measures </li> </ul> <p>Attributes:</p> Name Type Description <code>post</code> <code>Set[Measure]</code> <code>pre</code> <code>Set[Measure]</code>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.RequiredMeasures.post","title":"post  <code>instance-attribute</code>","text":"<pre><code>post: Set[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.RequiredMeasures.pre","title":"pre  <code>instance-attribute</code>","text":"<pre><code>pre: Set[Measure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.RequiredSampleMeasures","title":"RequiredSampleMeasures","text":"<p>               Bases: <code>NamedTuple</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.proc_setup.RequiredSampleMeasures[RequiredSampleMeasures]\n\n              \n\n              click bioimageio.core.proc_setup.RequiredSampleMeasures href \"\" \"bioimageio.core.proc_setup.RequiredSampleMeasures\"\n            </code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0proc_setup <code></code>\u00a0get_requried_sample_measures </li> </ul> <p>Attributes:</p> Name Type Description <code>post</code> <code>Set[SampleMeasure]</code> <code>pre</code> <code>Set[SampleMeasure]</code>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.RequiredSampleMeasures.post","title":"post  <code>instance-attribute</code>","text":"<pre><code>post: Set[SampleMeasure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.RequiredSampleMeasures.pre","title":"pre  <code>instance-attribute</code>","text":"<pre><code>pre: Set[SampleMeasure]\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.get_pre_and_postprocessing","title":"get_pre_and_postprocessing","text":"<pre><code>get_pre_and_postprocessing(model: AnyModelDescr, *, dataset_for_initial_statistics: Iterable[Sample], keep_updating_initial_dataset_stats: bool = False, fixed_dataset_stats: Optional[Mapping[DatasetMeasure, MeasureValue]] = None) -&gt; _ProcessingCallables\n</code></pre> <p>Creates callables to apply pre- and postprocessing in-place to a sample</p> Source code in <code>src/bioimageio/core/proc_setup.py</code> <pre><code>def get_pre_and_postprocessing(\n    model: AnyModelDescr,\n    *,\n    dataset_for_initial_statistics: Iterable[Sample],\n    keep_updating_initial_dataset_stats: bool = False,\n    fixed_dataset_stats: Optional[Mapping[DatasetMeasure, MeasureValue]] = None,\n) -&gt; _ProcessingCallables:\n    \"\"\"Creates callables to apply pre- and postprocessing in-place to a sample\"\"\"\n\n    setup = setup_pre_and_postprocessing(\n        model=model,\n        dataset_for_initial_statistics=dataset_for_initial_statistics,\n        keep_updating_initial_dataset_stats=keep_updating_initial_dataset_stats,\n        fixed_dataset_stats=fixed_dataset_stats,\n    )\n    return _ProcessingCallables(_ApplyProcs(setup.pre), _ApplyProcs(setup.post))\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.get_required_dataset_measures","title":"get_required_dataset_measures","text":"<pre><code>get_required_dataset_measures(model: AnyModelDescr) -&gt; RequiredDatasetMeasures\n</code></pre> Source code in <code>src/bioimageio/core/proc_setup.py</code> <pre><code>def get_required_dataset_measures(model: AnyModelDescr) -&gt; RequiredDatasetMeasures:\n    s = _prepare_setup_pre_and_postprocessing(model)\n    return RequiredDatasetMeasures(\n        {m for m in s.pre_measures if isinstance(m, DatasetMeasureBase)},\n        {m for m in s.post_measures if isinstance(m, DatasetMeasureBase)},\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.get_requried_measures","title":"get_requried_measures","text":"<pre><code>get_requried_measures(model: AnyModelDescr) -&gt; RequiredMeasures\n</code></pre> Source code in <code>src/bioimageio/core/proc_setup.py</code> <pre><code>def get_requried_measures(model: AnyModelDescr) -&gt; RequiredMeasures:\n    s = _prepare_setup_pre_and_postprocessing(model)\n    return RequiredMeasures(s.pre_measures, s.post_measures)\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.get_requried_sample_measures","title":"get_requried_sample_measures","text":"<pre><code>get_requried_sample_measures(model: AnyModelDescr) -&gt; RequiredSampleMeasures\n</code></pre> Source code in <code>src/bioimageio/core/proc_setup.py</code> <pre><code>def get_requried_sample_measures(model: AnyModelDescr) -&gt; RequiredSampleMeasures:\n    s = _prepare_setup_pre_and_postprocessing(model)\n    return RequiredSampleMeasures(\n        {m for m in s.pre_measures if isinstance(m, SampleMeasureBase)},\n        {m for m in s.post_measures if isinstance(m, SampleMeasureBase)},\n    )\n</code></pre>"},{"location":"api/bioimageio/core/proc_setup/#bioimageio.core.proc_setup.setup_pre_and_postprocessing","title":"setup_pre_and_postprocessing","text":"<pre><code>setup_pre_and_postprocessing(model: AnyModelDescr, dataset_for_initial_statistics: Iterable[Sample], keep_updating_initial_dataset_stats: bool = False, fixed_dataset_stats: Optional[Mapping[DatasetMeasure, MeasureValue]] = None) -&gt; PreAndPostprocessing\n</code></pre> <p>Get pre- and postprocessing operators for a <code>model</code> description. Used in `bioimageio.core.create_prediction_pipeline</p> Source code in <code>src/bioimageio/core/proc_setup.py</code> <pre><code>def setup_pre_and_postprocessing(\n    model: AnyModelDescr,\n    dataset_for_initial_statistics: Iterable[Sample],\n    keep_updating_initial_dataset_stats: bool = False,\n    fixed_dataset_stats: Optional[Mapping[DatasetMeasure, MeasureValue]] = None,\n) -&gt; PreAndPostprocessing:\n    \"\"\"\n    Get pre- and postprocessing operators for a `model` description.\n    Used in `bioimageio.core.create_prediction_pipeline\"\"\"\n    prep, post, prep_meas, post_meas = _prepare_setup_pre_and_postprocessing(model)\n\n    missing_dataset_stats = {\n        m\n        for m in prep_meas | post_meas\n        if fixed_dataset_stats is None or m not in fixed_dataset_stats\n    }\n    if missing_dataset_stats:\n        initial_stats_calc = StatsCalculator(missing_dataset_stats)\n        for sample in dataset_for_initial_statistics:\n            initial_stats_calc.update(sample)\n\n        initial_stats = initial_stats_calc.finalize()\n    else:\n        initial_stats = {}\n\n    prep.insert(\n        0,\n        UpdateStats(\n            StatsCalculator(prep_meas, initial_stats),\n            keep_updating_initial_dataset_stats=keep_updating_initial_dataset_stats,\n        ),\n    )\n    if post_meas:\n        post.insert(\n            0,\n            UpdateStats(\n                StatsCalculator(post_meas, initial_stats),\n                keep_updating_initial_dataset_stats=keep_updating_initial_dataset_stats,\n            ),\n        )\n\n    if fixed_dataset_stats:\n        prep.insert(0, AddKnownDatasetStats(fixed_dataset_stats))\n        post.insert(0, AddKnownDatasetStats(fixed_dataset_stats))\n\n    return PreAndPostprocessing(prep, post)\n</code></pre>"},{"location":"api/bioimageio/core/sample/","title":"bioimageio.core.sample","text":""},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample","title":"sample","text":"Used by: <ul> <li> API Reference \u00a0core \u00a0Sample </li> </ul> <p>Classes:</p> Name Description <code>LinearSampleAxisTransform</code> <code>Sample</code> <p>A dataset sample.</p> <code>SampleBlock</code> <p>A block of a dataset sample</p> <code>SampleBlockBase</code> <p>base class for <code>SampleBlockMeta</code> and <code>SampleBlock</code></p> <code>SampleBlockMeta</code> <p>Meta data of a dataset sample block</p> <code>SampleBlockWithOrigin</code> <p>A <code>SampleBlock</code> with a reference (<code>origin</code>) to the whole <code>Sample</code></p> <p>Functions:</p> Name Description <code>sample_block_generator</code> <code>sample_block_meta_generator</code> <p>Attributes:</p> Name Type Description <code>BlockT</code>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.BlockT","title":"BlockT  <code>module-attribute</code>","text":"<pre><code>BlockT = TypeVar('BlockT', Block, BlockMeta)\n</code></pre> Subclassed by: <ul> <li> API Reference <code></code>\u00a0sample <code></code>\u00a0SampleBlockBase </li> </ul> Used by: <ul> <li> API Reference <code></code>\u00a0sample <ul> <li> <code></code>\u00a0SampleBlock </li> <li> <code></code>\u00a0SampleBlockBase </li> <li> <code></code>\u00a0SampleBlockMeta </li> <li> <code></code>\u00a0SampleBlockWithOrigin </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.LinearSampleAxisTransform","title":"LinearSampleAxisTransform  <code>dataclass</code>","text":"<pre><code>LinearSampleAxisTransform(axis: AxisId, scale: float, offset: int, member: MemberId)\n</code></pre> <p>               Bases: <code>LinearAxisTransform</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.sample.LinearSampleAxisTransform[LinearSampleAxisTransform]\n              bioimageio.core.block_meta.LinearAxisTransform[LinearAxisTransform]\n\n                              bioimageio.core.block_meta.LinearAxisTransform --&gt; bioimageio.core.sample.LinearSampleAxisTransform\n                \n\n\n              click bioimageio.core.sample.LinearSampleAxisTransform href \"\" \"bioimageio.core.sample.LinearSampleAxisTransform\"\n              click bioimageio.core.block_meta.LinearAxisTransform href \"\" \"bioimageio.core.block_meta.LinearAxisTransform\"\n            </code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0digest_spec <code></code>\u00a0get_block_transform </li> </ul> <p>Methods:</p> Name Description <code>compute</code> <p>Attributes:</p> Name Type Description <code>axis</code> <code>AxisId</code> <code>member</code> <code>MemberId</code> <code>offset</code> <code>int</code> <code>scale</code> <code>float</code>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.LinearSampleAxisTransform.axis","title":"axis  <code>instance-attribute</code>","text":"<pre><code>axis: AxisId\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.LinearSampleAxisTransform.member","title":"member  <code>instance-attribute</code>","text":"<pre><code>member: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.LinearSampleAxisTransform.offset","title":"offset  <code>instance-attribute</code>","text":"<pre><code>offset: int\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.LinearSampleAxisTransform.scale","title":"scale  <code>instance-attribute</code>","text":"<pre><code>scale: float\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.LinearSampleAxisTransform.compute","title":"compute","text":"<pre><code>compute(s: int, round: Callable[[float], int] = floor) -&gt; int\n</code></pre> Source code in <code>src/bioimageio/core/block_meta.py</code> <pre><code>def compute(self, s: int, round: Callable[[float], int] = floor) -&gt; int:\n    return round(s * self.scale) + self.offset\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.Sample","title":"Sample  <code>dataclass</code>","text":"<pre><code>Sample(members: Dict[MemberId, Tensor], stat: Stat, id: SampleId)\n</code></pre> <p>A dataset sample.</p> <p>A <code>Sample</code> has <code>members</code>, which allows to combine multiple tensors into a single sample. For example a <code>Sample</code> from a dataset with masked images may contain a <code>MemberId(\"raw\")</code> and <code>MemberId(\"mask\")</code> image.</p> Returned by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0digest_spec <ul> <li> <code></code>\u00a0create_sample_for_model </li> <li> <code></code>\u00a0get_test_input_sample </li> <li> <code></code>\u00a0get_test_output_sample </li> </ul> </li> <li> <code></code>\u00a0prediction <ul> <li> <code></code>\u00a0predict </li> <li> <code></code>\u00a0predict_many </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0core <ul> <li> <code></code>\u00a0Sample </li> <li> <code></code>\u00a0create_prediction_pipeline </li> </ul> </li> <li> <code></code>\u00a0dataset <code></code>\u00a0Dataset </li> <li> <code></code>\u00a0io <code></code>\u00a0save_sample </li> <li> <code></code>\u00a0prediction <code></code>\u00a0predict </li> <li> <code></code>\u00a0proc_setup <ul> <li> <code></code>\u00a0get_pre_and_postprocessing </li> <li> <code></code>\u00a0setup_pre_and_postprocessing </li> </ul> </li> <li> <code></code>\u00a0sample <ul> <li> <code></code>\u00a0SampleBlockWithOrigin </li> <li> <code></code>\u00a0sample_block_generator </li> </ul> </li> <li> <code></code>\u00a0stat_calculators <ul> <li> <code></code>\u00a0compute_dataset_measures </li> <li> <code></code>\u00a0compute_measures </li> <li> <code></code>\u00a0compute_sample_measures </li> </ul> </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>as_arrays</code> <p>Return sample as dictionary of arrays.</p> <code>as_single_block</code> <code>from_blocks</code> <code>split_into_blocks</code> <p>Attributes:</p> Name Type Description <code>id</code> <code>SampleId</code> <p>Identifies the <code>Sample</code> within the dataset -- typically a number or a string.</p> <code>members</code> <code>Dict[MemberId, Tensor]</code> <p>The sample's tensors</p> <code>shape</code> <code>PerMember[PerAxis[int]]</code> <code>stat</code> <code>Stat</code> <p>Sample and dataset statistics</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.Sample.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: SampleId\n</code></pre> <p>Identifies the <code>Sample</code> within the dataset -- typically a number or a string.</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.Sample.members","title":"members  <code>instance-attribute</code>","text":"<pre><code>members: Dict[MemberId, Tensor]\n</code></pre> <p>The sample's tensors</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.Sample.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: PerMember[PerAxis[int]]\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.Sample.stat","title":"stat  <code>instance-attribute</code>","text":"<pre><code>stat: Stat\n</code></pre> <p>Sample and dataset statistics</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.Sample.as_arrays","title":"as_arrays","text":"<pre><code>as_arrays() -&gt; Dict[str, NDArray[Any]]\n</code></pre> <p>Return sample as dictionary of arrays.</p> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>def as_arrays(self) -&gt; Dict[str, NDArray[Any]]:\n    \"\"\"Return sample as dictionary of arrays.\"\"\"\n    return {str(m): t.data.to_numpy() for m, t in self.members.items()}\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.Sample.as_single_block","title":"as_single_block","text":"<pre><code>as_single_block(halo: Optional[PerMember[PerAxis[Halo]]] = None)\n</code></pre> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>def as_single_block(self, halo: Optional[PerMember[PerAxis[Halo]]] = None):\n    if halo is None:\n        halo = {}\n    return SampleBlockWithOrigin(\n        sample_shape=self.shape,\n        sample_id=self.id,\n        blocks={\n            m: Block(\n                sample_shape=self.shape[m],\n                data=data,\n                inner_slice={\n                    a: SliceInfo(0, s) for a, s in data.tagged_shape.items()\n                },\n                halo=halo.get(m, {}),\n                block_index=0,\n                blocks_in_sample=1,\n            )\n            for m, data in self.members.items()\n        },\n        stat=self.stat,\n        origin=self,\n        block_index=0,\n        blocks_in_sample=1,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.Sample.from_blocks","title":"from_blocks  <code>classmethod</code>","text":"<pre><code>from_blocks(sample_blocks: Iterable[SampleBlock], *, fill_value: float = float('nan')) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>@classmethod\ndef from_blocks(\n    cls,\n    sample_blocks: Iterable[SampleBlock],\n    *,\n    fill_value: float = float(\"nan\"),\n) -&gt; Self:\n    members: PerMember[Tensor] = {}\n    stat: Stat = {}\n    sample_id = None\n    for sample_block in sample_blocks:\n        assert sample_id is None or sample_id == sample_block.sample_id\n        sample_id = sample_block.sample_id\n        stat = sample_block.stat\n        for m, block in sample_block.blocks.items():\n            if m not in members:\n                if -1 in block.sample_shape.values():\n                    raise NotImplementedError(\n                        \"merging blocks with data dependent axis not yet implemented\"\n                    )\n\n                members[m] = Tensor(\n                    np.full(\n                        tuple(block.sample_shape[a] for a in block.data.dims),\n                        fill_value,\n                        dtype=block.data.dtype,\n                    ),\n                    dims=block.data.dims,\n                )\n\n            members[m][block.inner_slice] = block.inner_data\n\n    return cls(members=members, stat=stat, id=sample_id)\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.Sample.split_into_blocks","title":"split_into_blocks","text":"<pre><code>split_into_blocks(block_shapes: PerMember[PerAxis[int]], halo: PerMember[PerAxis[HaloLike]], pad_mode: PadMode, broadcast: bool = False) -&gt; Tuple[TotalNumberOfBlocks, Iterable[SampleBlockWithOrigin]]\n</code></pre> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>def split_into_blocks(\n    self,\n    block_shapes: PerMember[PerAxis[int]],\n    halo: PerMember[PerAxis[HaloLike]],\n    pad_mode: PadMode,\n    broadcast: bool = False,\n) -&gt; Tuple[TotalNumberOfBlocks, Iterable[SampleBlockWithOrigin]]:\n    assert not (missing := [m for m in block_shapes if m not in self.members]), (\n        f\"`block_shapes` specified for unknown members: {missing}\"\n    )\n    assert not (missing := [m for m in halo if m not in block_shapes]), (\n        f\"`halo` specified for members without `block_shape`: {missing}\"\n    )\n\n    n_blocks, blocks = split_multiple_shapes_into_blocks(\n        shapes=self.shape,\n        block_shapes=block_shapes,\n        halo=halo,\n        broadcast=broadcast,\n    )\n    return n_blocks, sample_block_generator(blocks, origin=self, pad_mode=pad_mode)\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock","title":"SampleBlock  <code>dataclass</code>","text":"<pre><code>SampleBlock(sample_shape: PerMember[PerAxis[int]], sample_id: SampleId, blocks: Dict[MemberId, BlockT], block_index: BlockIndex, blocks_in_sample: TotalNumberOfBlocks, stat: Stat)\n</code></pre> <p>               Bases: <code>SampleBlockBase[Block]</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.sample.SampleBlock[SampleBlock]\n              bioimageio.core.sample.SampleBlockBase[SampleBlockBase]\n\n                              bioimageio.core.sample.SampleBlockBase --&gt; bioimageio.core.sample.SampleBlock\n                \n\n\n              click bioimageio.core.sample.SampleBlock href \"\" \"bioimageio.core.sample.SampleBlock\"\n              click bioimageio.core.sample.SampleBlockBase href \"\" \"bioimageio.core.sample.SampleBlockBase\"\n            </code></pre> <p>A block of a dataset sample</p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0sample <code></code>\u00a0SampleBlockWithOrigin </li> </ul> <p>Methods:</p> Name Description <code>get_transformed_meta</code> <p>Attributes:</p> Name Type Description <code>block_index</code> <code>BlockIndex</code> <p>the n-th block of the sample</p> <code>blocks</code> <code>Dict[MemberId, BlockT]</code> <p>Individual tensor blocks comprising this sample block</p> <code>blocks_in_sample</code> <code>TotalNumberOfBlocks</code> <p>total number of blocks in the sample</p> <code>inner_shape</code> <code>PerMember[PerAxis[int]]</code> <code>members</code> <code>PerMember[Tensor]</code> <p>the sample block's tensors</p> <code>sample_id</code> <code>SampleId</code> <p>identifier for the sample within its dataset</p> <code>sample_shape</code> <code>PerMember[PerAxis[int]]</code> <p>the sample shape this block represents a part of</p> <code>shape</code> <code>PerMember[PerAxis[int]]</code> <code>stat</code> <code>Stat</code> <p>computed statistics</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.block_index","title":"block_index  <code>instance-attribute</code>","text":"<pre><code>block_index: BlockIndex\n</code></pre> <p>the n-th block of the sample</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.blocks","title":"blocks  <code>instance-attribute</code>","text":"<pre><code>blocks: Dict[MemberId, BlockT]\n</code></pre> <p>Individual tensor blocks comprising this sample block</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.blocks_in_sample","title":"blocks_in_sample  <code>instance-attribute</code>","text":"<pre><code>blocks_in_sample: TotalNumberOfBlocks\n</code></pre> <p>total number of blocks in the sample</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.inner_shape","title":"inner_shape  <code>property</code>","text":"<pre><code>inner_shape: PerMember[PerAxis[int]]\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.members","title":"members  <code>property</code>","text":"<pre><code>members: PerMember[Tensor]\n</code></pre> <p>the sample block's tensors</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.sample_id","title":"sample_id  <code>instance-attribute</code>","text":"<pre><code>sample_id: SampleId\n</code></pre> <p>identifier for the sample within its dataset</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.sample_shape","title":"sample_shape  <code>instance-attribute</code>","text":"<pre><code>sample_shape: PerMember[PerAxis[int]]\n</code></pre> <p>the sample shape this block represents a part of</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: PerMember[PerAxis[int]]\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.stat","title":"stat  <code>instance-attribute</code>","text":"<pre><code>stat: Stat\n</code></pre> <p>computed statistics</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlock.get_transformed_meta","title":"get_transformed_meta","text":"<pre><code>get_transformed_meta(new_axes: PerMember[PerAxis[Union[LinearSampleAxisTransform, int]]]) -&gt; SampleBlockMeta\n</code></pre> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>def get_transformed_meta(\n    self, new_axes: PerMember[PerAxis[Union[LinearSampleAxisTransform, int]]]\n) -&gt; SampleBlockMeta:\n    return SampleBlockMeta(\n        sample_id=self.sample_id,\n        blocks=dict(self.blocks),\n        sample_shape=self.sample_shape,\n        block_index=self.block_index,\n        blocks_in_sample=self.blocks_in_sample,\n    ).get_transformed(new_axes)\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockBase","title":"SampleBlockBase  <code>dataclass</code>","text":"<pre><code>SampleBlockBase(sample_shape: PerMember[PerAxis[int]], sample_id: SampleId, blocks: Dict[MemberId, BlockT], block_index: BlockIndex, blocks_in_sample: TotalNumberOfBlocks)\n</code></pre> <p>               Bases: <code>Generic[BlockT]</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.sample.SampleBlockBase[SampleBlockBase]\n\n              \n\n              click bioimageio.core.sample.SampleBlockBase href \"\" \"bioimageio.core.sample.SampleBlockBase\"\n            </code></pre> <p>base class for <code>SampleBlockMeta</code> and <code>SampleBlock</code></p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0sample <ul> <li> <code></code>\u00a0SampleBlock </li> <li> <code></code>\u00a0SampleBlockMeta </li> </ul> </li> </ul> <p>Attributes:</p> Name Type Description <code>block_index</code> <code>BlockIndex</code> <p>the n-th block of the sample</p> <code>blocks</code> <code>Dict[MemberId, BlockT]</code> <p>Individual tensor blocks comprising this sample block</p> <code>blocks_in_sample</code> <code>TotalNumberOfBlocks</code> <p>total number of blocks in the sample</p> <code>inner_shape</code> <code>PerMember[PerAxis[int]]</code> <code>sample_id</code> <code>SampleId</code> <p>identifier for the sample within its dataset</p> <code>sample_shape</code> <code>PerMember[PerAxis[int]]</code> <p>the sample shape this block represents a part of</p> <code>shape</code> <code>PerMember[PerAxis[int]]</code>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockBase.block_index","title":"block_index  <code>instance-attribute</code>","text":"<pre><code>block_index: BlockIndex\n</code></pre> <p>the n-th block of the sample</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockBase.blocks","title":"blocks  <code>instance-attribute</code>","text":"<pre><code>blocks: Dict[MemberId, BlockT]\n</code></pre> <p>Individual tensor blocks comprising this sample block</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockBase.blocks_in_sample","title":"blocks_in_sample  <code>instance-attribute</code>","text":"<pre><code>blocks_in_sample: TotalNumberOfBlocks\n</code></pre> <p>total number of blocks in the sample</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockBase.inner_shape","title":"inner_shape  <code>property</code>","text":"<pre><code>inner_shape: PerMember[PerAxis[int]]\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockBase.sample_id","title":"sample_id  <code>instance-attribute</code>","text":"<pre><code>sample_id: SampleId\n</code></pre> <p>identifier for the sample within its dataset</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockBase.sample_shape","title":"sample_shape  <code>instance-attribute</code>","text":"<pre><code>sample_shape: PerMember[PerAxis[int]]\n</code></pre> <p>the sample shape this block represents a part of</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockBase.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: PerMember[PerAxis[int]]\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta","title":"SampleBlockMeta  <code>dataclass</code>","text":"<pre><code>SampleBlockMeta(sample_shape: PerMember[PerAxis[int]], sample_id: SampleId, blocks: Dict[MemberId, BlockT], block_index: BlockIndex, blocks_in_sample: TotalNumberOfBlocks)\n</code></pre> <p>               Bases: <code>SampleBlockBase[BlockMeta]</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.sample.SampleBlockMeta[SampleBlockMeta]\n              bioimageio.core.sample.SampleBlockBase[SampleBlockBase]\n\n                              bioimageio.core.sample.SampleBlockBase --&gt; bioimageio.core.sample.SampleBlockMeta\n                \n\n\n              click bioimageio.core.sample.SampleBlockMeta href \"\" \"bioimageio.core.sample.SampleBlockMeta\"\n              click bioimageio.core.sample.SampleBlockBase href \"\" \"bioimageio.core.sample.SampleBlockBase\"\n            </code></pre> <p>Meta data of a dataset sample block</p> <p>Methods:</p> Name Description <code>get_transformed</code> <code>with_data</code> <p>Attributes:</p> Name Type Description <code>block_index</code> <code>BlockIndex</code> <p>the n-th block of the sample</p> <code>blocks</code> <code>Dict[MemberId, BlockT]</code> <p>Individual tensor blocks comprising this sample block</p> <code>blocks_in_sample</code> <code>TotalNumberOfBlocks</code> <p>total number of blocks in the sample</p> <code>inner_shape</code> <code>PerMember[PerAxis[int]]</code> <code>sample_id</code> <code>SampleId</code> <p>identifier for the sample within its dataset</p> <code>sample_shape</code> <code>PerMember[PerAxis[int]]</code> <p>the sample shape this block represents a part of</p> <code>shape</code> <code>PerMember[PerAxis[int]]</code>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta.block_index","title":"block_index  <code>instance-attribute</code>","text":"<pre><code>block_index: BlockIndex\n</code></pre> <p>the n-th block of the sample</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta.blocks","title":"blocks  <code>instance-attribute</code>","text":"<pre><code>blocks: Dict[MemberId, BlockT]\n</code></pre> <p>Individual tensor blocks comprising this sample block</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta.blocks_in_sample","title":"blocks_in_sample  <code>instance-attribute</code>","text":"<pre><code>blocks_in_sample: TotalNumberOfBlocks\n</code></pre> <p>total number of blocks in the sample</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta.inner_shape","title":"inner_shape  <code>property</code>","text":"<pre><code>inner_shape: PerMember[PerAxis[int]]\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta.sample_id","title":"sample_id  <code>instance-attribute</code>","text":"<pre><code>sample_id: SampleId\n</code></pre> <p>identifier for the sample within its dataset</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta.sample_shape","title":"sample_shape  <code>instance-attribute</code>","text":"<pre><code>sample_shape: PerMember[PerAxis[int]]\n</code></pre> <p>the sample shape this block represents a part of</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: PerMember[PerAxis[int]]\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta.get_transformed","title":"get_transformed","text":"<pre><code>get_transformed(new_axes: PerMember[PerAxis[Union[LinearSampleAxisTransform, int]]]) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>def get_transformed(\n    self, new_axes: PerMember[PerAxis[Union[LinearSampleAxisTransform, int]]]\n) -&gt; Self:\n    sample_shape = {\n        m: {\n            a: (\n                trf\n                if isinstance(trf, int)\n                else trf.compute(self.sample_shape[trf.member][trf.axis])\n            )\n            for a, trf in new_axes[m].items()\n        }\n        for m in new_axes\n    }\n\n    def get_member_halo(m: MemberId, round: Callable[[float], int]):\n        return {\n            a: (\n                Halo(0, 0)\n                if isinstance(trf, int)\n                or trf.axis not in self.blocks[trf.member].halo\n                else Halo(\n                    round(self.blocks[trf.member].halo[trf.axis].left * trf.scale),\n                    round(self.blocks[trf.member].halo[trf.axis].right * trf.scale),\n                )\n            )\n            for a, trf in new_axes[m].items()\n        }\n\n    halo: Dict[MemberId, Dict[AxisId, Halo]] = {}\n    for m in new_axes:\n        halo[m] = get_member_halo(m, floor)\n        if halo[m] != get_member_halo(m, ceil):\n            raise ValueError(\n                f\"failed to unambiguously scale halo {halo[m]} with {new_axes[m]}\"\n                + f\" for {m}.\"\n            )\n\n    inner_slice = {\n        m: {\n            a: (\n                SliceInfo(0, trf)\n                if isinstance(trf, int)\n                else SliceInfo(\n                    trf.compute(\n                        self.blocks[trf.member].inner_slice[trf.axis].start\n                    ),\n                    trf.compute(self.blocks[trf.member].inner_slice[trf.axis].stop),\n                )\n            )\n            for a, trf in new_axes[m].items()\n        }\n        for m in new_axes\n    }\n    return self.__class__(\n        blocks={\n            m: BlockMeta(\n                sample_shape=sample_shape[m],\n                inner_slice=inner_slice[m],\n                halo=halo[m],\n                block_index=self.block_index,\n                blocks_in_sample=self.blocks_in_sample,\n            )\n            for m in new_axes\n        },\n        sample_shape=sample_shape,\n        sample_id=self.sample_id,\n        block_index=self.block_index,\n        blocks_in_sample=self.blocks_in_sample,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockMeta.with_data","title":"with_data","text":"<pre><code>with_data(data: PerMember[Tensor], *, stat: Stat) -&gt; SampleBlock\n</code></pre> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>def with_data(self, data: PerMember[Tensor], *, stat: Stat) -&gt; SampleBlock:\n    return SampleBlock(\n        sample_shape={\n            m: {\n                a: data[m].tagged_shape[a] if s == -1 else s\n                for a, s in member_shape.items()\n            }\n            for m, member_shape in self.sample_shape.items()\n        },\n        sample_id=self.sample_id,\n        blocks={\n            m: Block.from_meta(b, data=data[m]) for m, b in self.blocks.items()\n        },\n        stat=stat,\n        block_index=self.block_index,\n        blocks_in_sample=self.blocks_in_sample,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin","title":"SampleBlockWithOrigin  <code>dataclass</code>","text":"<pre><code>SampleBlockWithOrigin(sample_shape: PerMember[PerAxis[int]], sample_id: SampleId, blocks: Dict[MemberId, BlockT], block_index: BlockIndex, blocks_in_sample: TotalNumberOfBlocks, stat: Stat, origin: Sample)\n</code></pre> <p>               Bases: <code>SampleBlock</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.sample.SampleBlockWithOrigin[SampleBlockWithOrigin]\n              bioimageio.core.sample.SampleBlock[SampleBlock]\n              bioimageio.core.sample.SampleBlockBase[SampleBlockBase]\n\n                              bioimageio.core.sample.SampleBlock --&gt; bioimageio.core.sample.SampleBlockWithOrigin\n                                bioimageio.core.sample.SampleBlockBase --&gt; bioimageio.core.sample.SampleBlock\n                \n\n\n\n              click bioimageio.core.sample.SampleBlockWithOrigin href \"\" \"bioimageio.core.sample.SampleBlockWithOrigin\"\n              click bioimageio.core.sample.SampleBlock href \"\" \"bioimageio.core.sample.SampleBlock\"\n              click bioimageio.core.sample.SampleBlockBase href \"\" \"bioimageio.core.sample.SampleBlockBase\"\n            </code></pre> <p>A <code>SampleBlock</code> with a reference (<code>origin</code>) to the whole <code>Sample</code></p> Returned by: <ul> <li> API Reference <code></code>\u00a0sample <code></code>\u00a0sample_block_generator </li> </ul> <p>Methods:</p> Name Description <code>get_transformed_meta</code> <p>Attributes:</p> Name Type Description <code>block_index</code> <code>BlockIndex</code> <p>the n-th block of the sample</p> <code>blocks</code> <code>Dict[MemberId, BlockT]</code> <p>Individual tensor blocks comprising this sample block</p> <code>blocks_in_sample</code> <code>TotalNumberOfBlocks</code> <p>total number of blocks in the sample</p> <code>inner_shape</code> <code>PerMember[PerAxis[int]]</code> <code>members</code> <code>PerMember[Tensor]</code> <p>the sample block's tensors</p> <code>origin</code> <code>Sample</code> <p>the sample this sample block was taken from</p> <code>sample_id</code> <code>SampleId</code> <p>identifier for the sample within its dataset</p> <code>sample_shape</code> <code>PerMember[PerAxis[int]]</code> <p>the sample shape this block represents a part of</p> <code>shape</code> <code>PerMember[PerAxis[int]]</code> <code>stat</code> <code>Stat</code> <p>computed statistics</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.block_index","title":"block_index  <code>instance-attribute</code>","text":"<pre><code>block_index: BlockIndex\n</code></pre> <p>the n-th block of the sample</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.blocks","title":"blocks  <code>instance-attribute</code>","text":"<pre><code>blocks: Dict[MemberId, BlockT]\n</code></pre> <p>Individual tensor blocks comprising this sample block</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.blocks_in_sample","title":"blocks_in_sample  <code>instance-attribute</code>","text":"<pre><code>blocks_in_sample: TotalNumberOfBlocks\n</code></pre> <p>total number of blocks in the sample</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.inner_shape","title":"inner_shape  <code>property</code>","text":"<pre><code>inner_shape: PerMember[PerAxis[int]]\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.members","title":"members  <code>property</code>","text":"<pre><code>members: PerMember[Tensor]\n</code></pre> <p>the sample block's tensors</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.origin","title":"origin  <code>instance-attribute</code>","text":"<pre><code>origin: Sample\n</code></pre> <p>the sample this sample block was taken from</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.sample_id","title":"sample_id  <code>instance-attribute</code>","text":"<pre><code>sample_id: SampleId\n</code></pre> <p>identifier for the sample within its dataset</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.sample_shape","title":"sample_shape  <code>instance-attribute</code>","text":"<pre><code>sample_shape: PerMember[PerAxis[int]]\n</code></pre> <p>the sample shape this block represents a part of</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: PerMember[PerAxis[int]]\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.stat","title":"stat  <code>instance-attribute</code>","text":"<pre><code>stat: Stat\n</code></pre> <p>computed statistics</p>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.SampleBlockWithOrigin.get_transformed_meta","title":"get_transformed_meta","text":"<pre><code>get_transformed_meta(new_axes: PerMember[PerAxis[Union[LinearSampleAxisTransform, int]]]) -&gt; SampleBlockMeta\n</code></pre> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>def get_transformed_meta(\n    self, new_axes: PerMember[PerAxis[Union[LinearSampleAxisTransform, int]]]\n) -&gt; SampleBlockMeta:\n    return SampleBlockMeta(\n        sample_id=self.sample_id,\n        blocks=dict(self.blocks),\n        sample_shape=self.sample_shape,\n        block_index=self.block_index,\n        blocks_in_sample=self.blocks_in_sample,\n    ).get_transformed(new_axes)\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.sample_block_generator","title":"sample_block_generator","text":"<pre><code>sample_block_generator(blocks: Iterable[PerMember[BlockMeta]], *, origin: Sample, pad_mode: PadMode) -&gt; Iterable[SampleBlockWithOrigin]\n</code></pre> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>def sample_block_generator(\n    blocks: Iterable[PerMember[BlockMeta]],\n    *,\n    origin: Sample,\n    pad_mode: PadMode,\n) -&gt; Iterable[SampleBlockWithOrigin]:\n    for member_blocks in blocks:\n        cons = _ConsolidatedMemberBlocks(member_blocks)\n        yield SampleBlockWithOrigin(\n            blocks={\n                m: Block.from_sample_member(\n                    origin.members[m], block=member_blocks[m], pad_mode=pad_mode\n                )\n                for m in origin.members\n            },\n            sample_shape=origin.shape,\n            origin=origin,\n            stat=origin.stat,\n            sample_id=origin.id,\n            block_index=cons.block_index,\n            blocks_in_sample=cons.blocks_in_sample,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/sample/#bioimageio.core.sample.sample_block_meta_generator","title":"sample_block_meta_generator","text":"<pre><code>sample_block_meta_generator(blocks: Iterable[PerMember[BlockMeta]], *, sample_shape: PerMember[PerAxis[int]], sample_id: SampleId)\n</code></pre> Source code in <code>src/bioimageio/core/sample.py</code> <pre><code>def sample_block_meta_generator(\n    blocks: Iterable[PerMember[BlockMeta]],\n    *,\n    sample_shape: PerMember[PerAxis[int]],\n    sample_id: SampleId,\n):\n    for member_blocks in blocks:\n        cons = _ConsolidatedMemberBlocks(member_blocks)\n        yield SampleBlockMeta(\n            blocks=dict(member_blocks),\n            sample_shape=sample_shape,\n            sample_id=sample_id,\n            block_index=cons.block_index,\n            blocks_in_sample=cons.blocks_in_sample,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/","title":"bioimageio.core.stat_calculators","text":""},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators","title":"stat_calculators","text":"Used by: <ul> <li> API Reference \u00a0core \u00a0compute_dataset_measures </li> </ul> <p>Classes:</p> Name Description <code>CrickQuantilesCalculator</code> <p>to calculate dataset quantiles with the experimental crick libray</p> <code>MeanCalculator</code> <p>to calculate sample and dataset mean for in-memory samples</p> <code>MeanQuantilesCalculator</code> <p>to calculate dataset quantiles heuristically by averaging across samples</p> <code>MeanVarStdCalculator</code> <p>to calculate sample and dataset mean, variance or standard deviation</p> <code>NaiveSampleMeasureCalculator</code> <p>wrapper for measures to match interface of other sample measure calculators</p> <code>SampleQuantilesCalculator</code> <p>to calculate sample quantiles</p> <code>StatsCalculator</code> <p>Estimates dataset statistics and computes sample statistics efficiently</p> <p>Functions:</p> Name Description <code>compute_dataset_measures</code> <p>compute all dataset <code>measures</code> for the given <code>dataset</code></p> <code>compute_measures</code> <p>compute all <code>measures</code> for the given <code>dataset</code></p> <code>compute_sample_measures</code> <p>compute all sample <code>measures</code> for the given <code>sample</code></p> <code>get_measure_calculators</code> <p>determines which calculators are needed to compute the required measures efficiently</p> <p>Attributes:</p> Name Type Description <code>DatasetMeasureCalculator</code> <code>DatasetQuantilesCalculator</code> <code>Type[Union[MeanQuantilesCalculator, CrickQuantilesCalculator]]</code> <code>SampleMeasureCalculator</code> <code>TDigest</code>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.DatasetMeasureCalculator","title":"DatasetMeasureCalculator  <code>module-attribute</code>","text":"<pre><code>DatasetMeasureCalculator = Union[MeanCalculator, MeanVarStdCalculator, DatasetQuantilesCalculator]\n</code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0get_measure_calculators </li> </ul>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.DatasetQuantilesCalculator","title":"DatasetQuantilesCalculator  <code>module-attribute</code>","text":"<pre><code>DatasetQuantilesCalculator: Type[Union[MeanQuantilesCalculator, CrickQuantilesCalculator]] = MeanQuantilesCalculator\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0DatasetMeasureCalculator </li> </ul>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.SampleMeasureCalculator","title":"SampleMeasureCalculator  <code>module-attribute</code>","text":"<pre><code>SampleMeasureCalculator = Union[MeanCalculator, MeanVarStdCalculator, SampleQuantilesCalculator, NaiveSampleMeasureCalculator]\n</code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0get_measure_calculators </li> </ul>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.TDigest","title":"TDigest  <code>module-attribute</code>","text":"<pre><code>TDigest = crick.TDigest\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.CrickQuantilesCalculator","title":"CrickQuantilesCalculator","text":"<pre><code>CrickQuantilesCalculator(member_id: MemberId, axes: Optional[Sequence[AxisId]], qs: Collection[float])\n</code></pre> <p>to calculate dataset quantiles with the experimental crick libray</p> Returned by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0DatasetQuantilesCalculator </li> </ul> <p>Methods:</p> Name Description <code>finalize</code> <code>update</code> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def __init__(\n    self,\n    member_id: MemberId,\n    axes: Optional[Sequence[AxisId]],\n    qs: Collection[float],\n):\n    warnings.warn(\"Computing dataset quantiles with experimental 'crick' library.\")\n    super().__init__()\n    assert all(0.0 &lt;= q &lt;= 1.0 for q in qs)\n    assert axes is None or \"_quantiles\" not in axes\n    self._qs = sorted(set(qs))\n    self._axes = None if axes is None else tuple(axes)\n    self._member_id = member_id\n    self._digest: Optional[List[TDigest]] = None\n    self._dims: Optional[Tuple[AxisId, ...]] = None\n    self._indices: Optional[Iterator[Tuple[int, ...]]] = None\n    self._shape: Optional[Tuple[int, ...]] = None\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.CrickQuantilesCalculator.finalize","title":"finalize","text":"<pre><code>finalize() -&gt; Dict[DatasetQuantile, MeasureValue]\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def finalize(self) -&gt; Dict[DatasetQuantile, MeasureValue]:\n    if self._digest is None:\n        return {}\n    else:\n        assert self._dims is not None\n        assert self._shape is not None\n\n        vs: NDArray[Any] = np.asarray(\n            [[d.quantile(q) for d in self._digest] for q in self._qs]\n        ).reshape(self._shape)\n        return {\n            DatasetQuantile(\n                q=q, axes=self._axes, member_id=self._member_id\n            ): Tensor(v, dims=self._dims[1:])\n            for q, v in zip(self._qs, vs)\n        }\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.CrickQuantilesCalculator.update","title":"update","text":"<pre><code>update(part: Sample)\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def update(self, part: Sample):\n    tensor = (\n        part.members[self._member_id]\n        if isinstance(part, Sample)\n        else part.members[self._member_id].data\n    )\n    assert \"_quantiles\" not in tensor.dims\n    if self._digest is None:\n        self._initialize(tensor.tagged_shape)\n\n    assert self._digest is not None\n    assert self._indices is not None\n    assert self._dims is not None\n    for i, idx in enumerate(self._indices):\n        self._digest[i].update(tensor[dict(zip(self._dims[1:], idx))])\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanCalculator","title":"MeanCalculator","text":"<pre><code>MeanCalculator(member_id: MemberId, axes: Optional[Sequence[AxisId]])\n</code></pre> <p>to calculate sample and dataset mean for in-memory samples</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <ul> <li> <code></code>\u00a0DatasetMeasureCalculator </li> <li> <code></code>\u00a0SampleMeasureCalculator </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>compute</code> <code>compute_and_update</code> <code>finalize</code> <code>update</code> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def __init__(self, member_id: MemberId, axes: Optional[Sequence[AxisId]]):\n    super().__init__()\n    self._n: int = 0\n    self._mean: Optional[Tensor] = None\n    self._axes = None if axes is None else tuple(axes)\n    self._member_id = member_id\n    self._sample_mean = SampleMean(member_id=self._member_id, axes=self._axes)\n    self._dataset_mean = DatasetMean(member_id=self._member_id, axes=self._axes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanCalculator.compute","title":"compute","text":"<pre><code>compute(sample: Sample) -&gt; Dict[SampleMean, MeasureValue]\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def compute(self, sample: Sample) -&gt; Dict[SampleMean, MeasureValue]:\n    return {self._sample_mean: self._compute_impl(sample)}\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanCalculator.compute_and_update","title":"compute_and_update","text":"<pre><code>compute_and_update(sample: Sample) -&gt; Dict[SampleMean, MeasureValue]\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def compute_and_update(self, sample: Sample) -&gt; Dict[SampleMean, MeasureValue]:\n    mean = self._compute_impl(sample)\n    self._update_impl(sample.members[self._member_id], mean)\n    return {self._sample_mean: mean}\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanCalculator.finalize","title":"finalize","text":"<pre><code>finalize() -&gt; Dict[DatasetMean, MeasureValue]\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def finalize(self) -&gt; Dict[DatasetMean, MeasureValue]:\n    if self._mean is None:\n        return {}\n    else:\n        return {self._dataset_mean: self._mean}\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanCalculator.update","title":"update","text":"<pre><code>update(sample: Sample) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def update(self, sample: Sample) -&gt; None:\n    mean = self._compute_impl(sample)\n    self._update_impl(sample.members[self._member_id], mean)\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanQuantilesCalculator","title":"MeanQuantilesCalculator","text":"<pre><code>MeanQuantilesCalculator(member_id: MemberId, axes: Optional[Sequence[AxisId]], qs: Collection[float])\n</code></pre> <p>to calculate dataset quantiles heuristically by averaging across samples</p> Note <p>The returned dataset quantiles are an estiamte and not mathematically correct</p> Returned by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0DatasetQuantilesCalculator </li> </ul> Used by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0DatasetQuantilesCalculator </li> </ul> <p>Methods:</p> Name Description <code>finalize</code> <code>update</code> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def __init__(\n    self,\n    member_id: MemberId,\n    axes: Optional[Sequence[AxisId]],\n    qs: Collection[float],\n):\n    super().__init__()\n    assert all(0.0 &lt;= q &lt;= 1.0 for q in qs)\n    self._qs = sorted(set(qs))\n    self._axes = None if axes is None else tuple(axes)\n    self._member_id = member_id\n    self._n: int = 0\n    self._estimates: Optional[Tensor] = None\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanQuantilesCalculator.finalize","title":"finalize","text":"<pre><code>finalize() -&gt; Dict[DatasetQuantile, MeasureValue]\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def finalize(self) -&gt; Dict[DatasetQuantile, MeasureValue]:\n    if self._estimates is None:\n        return {}\n    else:\n        warnings.warn(\n            \"Computed dataset percentiles naively by averaging percentiles of samples.\"\n        )\n        return {\n            DatasetQuantile(q=q, axes=self._axes, member_id=self._member_id): e\n            for q, e in zip(self._qs, self._estimates)\n        }\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanQuantilesCalculator.update","title":"update","text":"<pre><code>update(sample: Sample)\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def update(self, sample: Sample):\n    tensor = sample.members[self._member_id]\n    sample_estimates = tensor.quantile(\n        self._qs, dim=self._axes, method=\"linear\"\n    ).astype(\"float64\", copy=False)\n\n    # reduced voxel count\n    n = int(tensor.size / np.prod(sample_estimates.shape_tuple[1:]))\n\n    if self._estimates is None:\n        assert self._n == 0\n        self._estimates = sample_estimates\n    else:\n        self._estimates = (self._n * self._estimates + n * sample_estimates) / (\n            self._n + n\n        )\n        assert self._estimates.dtype == \"float64\"\n\n    self._n += n\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanVarStdCalculator","title":"MeanVarStdCalculator","text":"<pre><code>MeanVarStdCalculator(member_id: MemberId, axes: Optional[Sequence[AxisId]])\n</code></pre> <p>to calculate sample and dataset mean, variance or standard deviation</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <ul> <li> <code></code>\u00a0DatasetMeasureCalculator </li> <li> <code></code>\u00a0SampleMeasureCalculator </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>compute</code> <code>finalize</code> <code>update</code> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def __init__(self, member_id: MemberId, axes: Optional[Sequence[AxisId]]):\n    super().__init__()\n    self._axes = None if axes is None else tuple(map(AxisId, axes))\n    self._member_id = member_id\n    self._n: int = 0\n    self._mean: Optional[Tensor] = None\n    self._m2: Optional[Tensor] = None\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanVarStdCalculator.compute","title":"compute","text":"<pre><code>compute(sample: Sample) -&gt; Dict[Union[SampleMean, SampleVar, SampleStd], MeasureValue]\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def compute(\n    self, sample: Sample\n) -&gt; Dict[Union[SampleMean, SampleVar, SampleStd], MeasureValue]:\n    tensor = sample.members[self._member_id]\n    mean = tensor.mean(dim=self._axes)\n    c = (tensor - mean).data\n    if self._axes is None:\n        n = tensor.size\n    else:\n        n = int(np.prod([tensor.sizes[d] for d in self._axes]))\n\n    if xr.__version__.startswith(\"2023\"):\n        var = xr.dot(c, c, dims=self._axes) / n\n    else:\n        var = xr.dot(c, c, dim=self._axes) / n\n\n    assert isinstance(var, xr.DataArray)\n    std = np.sqrt(var)\n    assert isinstance(std, xr.DataArray)\n    return {\n        SampleMean(axes=self._axes, member_id=self._member_id): mean,\n        SampleVar(axes=self._axes, member_id=self._member_id): Tensor.from_xarray(\n            var\n        ),\n        SampleStd(axes=self._axes, member_id=self._member_id): Tensor.from_xarray(\n            std\n        ),\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanVarStdCalculator.finalize","title":"finalize","text":"<pre><code>finalize() -&gt; Dict[Union[DatasetMean, DatasetVar, DatasetStd], MeasureValue]\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def finalize(\n    self,\n) -&gt; Dict[Union[DatasetMean, DatasetVar, DatasetStd], MeasureValue]:\n    if (\n        self._axes is not None\n        and BATCH_AXIS_ID not in self._axes\n        or self._mean is None\n    ):\n        return {}\n    else:\n        assert self._m2 is not None\n        var = self._m2 / self._n\n        sqrt = var**0.5\n        if isinstance(sqrt, (int, float)):\n            # var and mean are scalar tensors, let's keep it consistent\n            sqrt = Tensor.from_xarray(xr.DataArray(sqrt))\n\n        assert isinstance(sqrt, Tensor), type(sqrt)\n        return {\n            DatasetMean(member_id=self._member_id, axes=self._axes): self._mean,\n            DatasetVar(member_id=self._member_id, axes=self._axes): var,\n            DatasetStd(member_id=self._member_id, axes=self._axes): sqrt,\n        }\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.MeanVarStdCalculator.update","title":"update","text":"<pre><code>update(sample: Sample)\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def update(self, sample: Sample):\n    if self._axes is not None and BATCH_AXIS_ID not in self._axes:\n        return\n\n    tensor = sample.members[self._member_id].astype(\"float64\", copy=False)\n    mean_b = tensor.mean(dim=self._axes)\n    assert mean_b.dtype == \"float64\"\n    # reduced voxel count\n    n_b = int(tensor.size / mean_b.size)\n    m2_b = ((tensor - mean_b) ** 2).sum(dim=self._axes)\n    assert m2_b.dtype == \"float64\"\n    if self._mean is None:\n        assert self._m2 is None\n        self._n = n_b\n        self._mean = mean_b\n        self._m2 = m2_b\n    else:\n        n_a = self._n\n        mean_a = self._mean\n        m2_a = self._m2\n        self._n = n = n_a + n_b\n        self._mean = (n_a * mean_a + n_b * mean_b) / n\n        assert self._mean.dtype == \"float64\"\n        d = mean_b - mean_a\n        self._m2 = m2_a + m2_b + d**2 * n_a * n_b / n\n        assert self._m2.dtype == \"float64\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.NaiveSampleMeasureCalculator","title":"NaiveSampleMeasureCalculator","text":"<pre><code>NaiveSampleMeasureCalculator(member_id: MemberId, measure: SampleMeasure)\n</code></pre> <p>wrapper for measures to match interface of other sample measure calculators</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0SampleMeasureCalculator </li> </ul> <p>Methods:</p> Name Description <code>compute</code> <p>Attributes:</p> Name Type Description <code>measure</code> <code>tensor_name</code> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def __init__(self, member_id: MemberId, measure: SampleMeasure):\n    super().__init__()\n    self.tensor_name = member_id\n    self.measure = measure\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.NaiveSampleMeasureCalculator.measure","title":"measure  <code>instance-attribute</code>","text":"<pre><code>measure = measure\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.NaiveSampleMeasureCalculator.tensor_name","title":"tensor_name  <code>instance-attribute</code>","text":"<pre><code>tensor_name = member_id\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.NaiveSampleMeasureCalculator.compute","title":"compute","text":"<pre><code>compute(sample: Sample) -&gt; Dict[SampleMeasure, MeasureValue]\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def compute(self, sample: Sample) -&gt; Dict[SampleMeasure, MeasureValue]:\n    return {self.measure: self.measure.compute(sample)}\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.SampleQuantilesCalculator","title":"SampleQuantilesCalculator","text":"<pre><code>SampleQuantilesCalculator(member_id: MemberId, axes: Optional[Sequence[AxisId]], qs: Collection[float], method: QuantileMethod = 'linear')\n</code></pre> <p>to calculate sample quantiles</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0SampleMeasureCalculator </li> </ul> <p>Methods:</p> Name Description <code>compute</code> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def __init__(\n    self,\n    member_id: MemberId,\n    axes: Optional[Sequence[AxisId]],\n    qs: Collection[float],\n    method: QuantileMethod = \"linear\",\n):\n    super().__init__()\n    assert all(0.0 &lt;= q &lt;= 1.0 for q in qs)\n    self._qs = sorted(set(qs))\n    self._axes = None if axes is None else tuple(axes)\n    self._member_id = member_id\n    self._method: QuantileMethod = method\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.SampleQuantilesCalculator.compute","title":"compute","text":"<pre><code>compute(sample: Sample) -&gt; Dict[SampleQuantile, MeasureValue]\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def compute(self, sample: Sample) -&gt; Dict[SampleQuantile, MeasureValue]:\n    tensor = sample.members[self._member_id]\n    ps = tensor.quantile(self._qs, dim=self._axes, method=self._method)\n    return {\n        SampleQuantile(\n            q=q, axes=self._axes, member_id=self._member_id, method=self._method\n        ): p\n        for q, p in zip(self._qs, ps)\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.StatsCalculator","title":"StatsCalculator","text":"<pre><code>StatsCalculator(measures: Collection[Measure], initial_dataset_measures: Optional[Mapping[DatasetMeasure, MeasureValue]] = None)\n</code></pre> <p>Estimates dataset statistics and computes sample statistics efficiently</p> Used by: <ul> <li> API Reference <code></code>\u00a0proc_ops <code></code>\u00a0UpdateStats </li> </ul> <p>Methods:</p> Name Description <code>finalize</code> <p>returns aggregated dataset statistics</p> <code>skip_update_and_get_all</code> <p>Returns sample as well as previously computed dataset statistics</p> <code>update</code> <code>update_and_get_all</code> <p>Returns sample as well as updated dataset statistics</p> <p>Attributes:</p> Name Type Description <code>has_dataset_measures</code> <code>sample_count</code> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def __init__(\n    self,\n    measures: Collection[Measure],\n    initial_dataset_measures: Optional[\n        Mapping[DatasetMeasure, MeasureValue]\n    ] = None,\n):\n    super().__init__()\n    self.sample_count = 0\n    self.sample_calculators, self.dataset_calculators = get_measure_calculators(\n        measures\n    )\n    if not initial_dataset_measures:\n        self._current_dataset_measures: Optional[\n            Dict[DatasetMeasure, MeasureValue]\n        ] = None\n    else:\n        missing_dataset_meas = {\n            m\n            for m in measures\n            if isinstance(m, DatasetMeasureBase)\n            and m not in initial_dataset_measures\n        }\n        if missing_dataset_meas:\n            logger.debug(\n                f\"ignoring `initial_dataset_measure` as it is missing {missing_dataset_meas}\"\n            )\n            self._current_dataset_measures = None\n        else:\n            self._current_dataset_measures = dict(initial_dataset_measures)\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.StatsCalculator.has_dataset_measures","title":"has_dataset_measures  <code>property</code>","text":"<pre><code>has_dataset_measures\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.StatsCalculator.sample_count","title":"sample_count  <code>instance-attribute</code>","text":"<pre><code>sample_count = 0\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.StatsCalculator.finalize","title":"finalize","text":"<pre><code>finalize() -&gt; Dict[DatasetMeasure, MeasureValue]\n</code></pre> <p>returns aggregated dataset statistics</p> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def finalize(self) -&gt; Dict[DatasetMeasure, MeasureValue]:\n    \"\"\"returns aggregated dataset statistics\"\"\"\n    if self._current_dataset_measures is None:\n        self._current_dataset_measures = {}\n        for calc in self.dataset_calculators:\n            values = calc.finalize()\n            self._current_dataset_measures.update(values.items())\n\n    return self._current_dataset_measures\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.StatsCalculator.skip_update_and_get_all","title":"skip_update_and_get_all","text":"<pre><code>skip_update_and_get_all(sample: Sample) -&gt; Dict[Measure, MeasureValue]\n</code></pre> <p>Returns sample as well as previously computed dataset statistics</p> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def skip_update_and_get_all(self, sample: Sample) -&gt; Dict[Measure, MeasureValue]:\n    \"\"\"Returns sample as well as previously computed dataset statistics\"\"\"\n    return {**self._compute(sample), **self.finalize()}\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.StatsCalculator.update","title":"update","text":"<pre><code>update(sample: Union[Sample, Iterable[Sample]]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def update(\n    self,\n    sample: Union[Sample, Iterable[Sample]],\n) -&gt; None:\n    _ = self._update(sample)\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.StatsCalculator.update_and_get_all","title":"update_and_get_all","text":"<pre><code>update_and_get_all(sample: Union[Sample, Iterable[Sample]]) -&gt; Dict[Measure, MeasureValue]\n</code></pre> <p>Returns sample as well as updated dataset statistics</p> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def update_and_get_all(\n    self,\n    sample: Union[Sample, Iterable[Sample]],\n) -&gt; Dict[Measure, MeasureValue]:\n    \"\"\"Returns sample as well as updated dataset statistics\"\"\"\n    last_sample = self._update(sample)\n    if last_sample is None:\n        raise ValueError(\"`sample` was not a `Sample`, nor did it yield any.\")\n\n    return {**self._compute(last_sample), **self.finalize()}\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.compute_dataset_measures","title":"compute_dataset_measures","text":"<pre><code>compute_dataset_measures(measures: Iterable[DatasetMeasure], dataset: Iterable[Sample]) -&gt; Dict[DatasetMeasure, MeasureValue]\n</code></pre> <p>compute all dataset <code>measures</code> for the given <code>dataset</code></p> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0compute_dataset_measures </li> </ul> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def compute_dataset_measures(\n    measures: Iterable[DatasetMeasure], dataset: Iterable[Sample]\n) -&gt; Dict[DatasetMeasure, MeasureValue]:\n    \"\"\"compute all dataset `measures` for the given `dataset`\"\"\"\n    sample_calculators, calculators = get_measure_calculators(measures)\n    assert not sample_calculators\n\n    ret: Dict[DatasetMeasure, MeasureValue] = {}\n\n    for sample in dataset:\n        for calc in calculators:\n            calc.update(sample)\n\n    for calc in calculators:\n        ret.update(calc.finalize().items())\n\n    return ret\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.compute_measures","title":"compute_measures","text":"<pre><code>compute_measures(measures: Iterable[Measure], dataset: Iterable[Sample]) -&gt; Dict[Measure, MeasureValue]\n</code></pre> <p>compute all <code>measures</code> for the given <code>dataset</code> sample measures are computed for the last sample in <code>dataset</code></p> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def compute_measures(\n    measures: Iterable[Measure], dataset: Iterable[Sample]\n) -&gt; Dict[Measure, MeasureValue]:\n    \"\"\"compute all `measures` for the given `dataset`\n    sample measures are computed for the last sample in `dataset`\"\"\"\n    sample_calculators, dataset_calculators = get_measure_calculators(measures)\n    ret: Dict[Measure, MeasureValue] = {}\n    sample = None\n    for sample in dataset:\n        for calc in dataset_calculators:\n            calc.update(sample)\n    if sample is None:\n        raise ValueError(\"empty dataset\")\n\n    for calc in dataset_calculators:\n        ret.update(calc.finalize().items())\n\n    for calc in sample_calculators:\n        ret.update(calc.compute(sample).items())\n\n    return ret\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.compute_sample_measures","title":"compute_sample_measures","text":"<pre><code>compute_sample_measures(measures: Iterable[SampleMeasure], sample: Sample) -&gt; Dict[SampleMeasure, MeasureValue]\n</code></pre> <p>compute all sample <code>measures</code> for the given <code>sample</code></p> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def compute_sample_measures(\n    measures: Iterable[SampleMeasure], sample: Sample\n) -&gt; Dict[SampleMeasure, MeasureValue]:\n    \"\"\"compute all sample `measures` for the given `sample`\"\"\"\n    calculators, dataset_calculators = get_measure_calculators(measures)\n    assert not dataset_calculators\n    ret: Dict[SampleMeasure, MeasureValue] = {}\n\n    for calc in calculators:\n        ret.update(calc.compute(sample).items())\n\n    return ret\n</code></pre>"},{"location":"api/bioimageio/core/stat_calculators/#bioimageio.core.stat_calculators.get_measure_calculators","title":"get_measure_calculators","text":"<pre><code>get_measure_calculators(required_measures: Iterable[Measure]) -&gt; Tuple[List[SampleMeasureCalculator], List[DatasetMeasureCalculator]]\n</code></pre> <p>determines which calculators are needed to compute the required measures efficiently</p> Source code in <code>src/bioimageio/core/stat_calculators.py</code> <pre><code>def get_measure_calculators(\n    required_measures: Iterable[Measure],\n) -&gt; Tuple[List[SampleMeasureCalculator], List[DatasetMeasureCalculator]]:\n    \"\"\"determines which calculators are needed to compute the required measures efficiently\"\"\"\n\n    sample_calculators: List[SampleMeasureCalculator] = []\n    dataset_calculators: List[DatasetMeasureCalculator] = []\n\n    # split required measures into groups\n    required_sample_means: Set[SampleMean] = set()\n    required_dataset_means: Set[DatasetMean] = set()\n    required_sample_mean_var_std: Set[Union[SampleMean, SampleVar, SampleStd]] = set()\n    required_dataset_mean_var_std: Set[Union[DatasetMean, DatasetVar, DatasetStd]] = (\n        set()\n    )\n    required_sample_quantiles: Dict[\n        Tuple[MemberId, Optional[Tuple[AxisId, ...]], QuantileMethod], Set[float]\n    ] = {}\n    required_dataset_quantiles: Dict[\n        Tuple[MemberId, Optional[Tuple[AxisId, ...]]], Set[float]\n    ] = {}\n\n    for rm in required_measures:\n        if isinstance(rm, SampleMean):\n            required_sample_means.add(rm)\n        elif isinstance(rm, DatasetMean):\n            required_dataset_means.add(rm)\n        elif isinstance(rm, (SampleVar, SampleStd)):\n            required_sample_mean_var_std.update(\n                {\n                    msv(axes=rm.axes, member_id=rm.member_id)\n                    for msv in (SampleMean, SampleStd, SampleVar)\n                }\n            )\n            assert rm in required_sample_mean_var_std\n        elif isinstance(rm, (DatasetVar, DatasetStd)):\n            required_dataset_mean_var_std.update(\n                {\n                    msv(axes=rm.axes, member_id=rm.member_id)\n                    for msv in (DatasetMean, DatasetStd, DatasetVar)\n                }\n            )\n            assert rm in required_dataset_mean_var_std\n        elif isinstance(rm, SampleQuantile):\n            required_sample_quantiles.setdefault(\n                (rm.member_id, rm.axes, rm.method), set()\n            ).add(rm.q)\n        elif isinstance(rm, DatasetQuantile):\n            required_dataset_quantiles.setdefault((rm.member_id, rm.axes), set()).add(\n                rm.q\n            )\n        else:\n            assert_never(rm)\n\n    for rm in required_sample_means:\n        if rm in required_sample_mean_var_std:\n            # computed togehter with var and std\n            continue\n\n        sample_calculators.append(MeanCalculator(member_id=rm.member_id, axes=rm.axes))\n\n    for rm in required_sample_mean_var_std:\n        sample_calculators.append(\n            MeanVarStdCalculator(member_id=rm.member_id, axes=rm.axes)\n        )\n\n    for rm in required_dataset_means:\n        if rm in required_dataset_mean_var_std:\n            # computed togehter with var and std\n            continue\n\n        dataset_calculators.append(MeanCalculator(member_id=rm.member_id, axes=rm.axes))\n\n    for rm in required_dataset_mean_var_std:\n        dataset_calculators.append(\n            MeanVarStdCalculator(member_id=rm.member_id, axes=rm.axes)\n        )\n\n    for (tid, axes, m), qs in required_sample_quantiles.items():\n        sample_calculators.append(\n            SampleQuantilesCalculator(member_id=tid, axes=axes, qs=qs, method=m)\n        )\n\n    for (tid, axes), qs in required_dataset_quantiles.items():\n        dataset_calculators.append(\n            DatasetQuantilesCalculator(member_id=tid, axes=axes, qs=qs)\n        )\n\n    return sample_calculators, dataset_calculators\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/","title":"bioimageio.core.stat_measures","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures","title":"stat_measures","text":"Used by: <ul> <li> API Reference \u00a0core \u00a0Stat </li> </ul> <p>Classes:</p> Name Description <code>DatasetMean</code> <p>The mean value across multiple samples</p> <code>DatasetMeasureBase</code> <code>DatasetQuantile</code> <p>The <code>q</code>th quantile across multiple samples</p> <code>DatasetStd</code> <p>The standard deviation across multiple samples</p> <code>DatasetVar</code> <p>The variance across multiple samples</p> <code>MeasureBase</code> <code>SampleLike</code> <code>SampleMean</code> <p>The mean value of a single tensor</p> <code>SampleMeasureBase</code> <code>SampleQuantile</code> <p>The <code>q</code>th quantile of a single tensor</p> <code>SampleStd</code> <p>The standard deviation of a single tensor</p> <code>SampleVar</code> <p>The variance of a single tensor</p> <p>Functions:</p> Name Description <code>tensor_custom_before_validator</code> <code>tensor_custom_serializer</code> <p>Attributes:</p> Name Type Description <code>DatasetMeasure</code> <code>MeanMeasure</code> <code>MeanMeasureT</code> <code>Measure</code> <code>MeasureValue</code> <code>PercentileMeasure</code> <code>PercentileMeasureT</code> <code>SampleMeasure</code> <code>Stat</code> <code>StdMeasure</code> <code>StdMeasureT</code> <code>VarMeasure</code> <code>VarMeasureT</code>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasure","title":"DatasetMeasure  <code>module-attribute</code>","text":"<pre><code>DatasetMeasure = Annotated[Union[DatasetMean, DatasetStd, DatasetVar, DatasetQuantile], Discriminator('name')]\n</code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0compute_dataset_measures </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0core <code></code>\u00a0create_prediction_pipeline </li> <li> <code></code>\u00a0io <code></code>\u00a0save_dataset_stat </li> <li> <code></code>\u00a0proc_ops <code></code>\u00a0AddKnownDatasetStats </li> <li> <code></code>\u00a0proc_setup <ul> <li> <code></code>\u00a0get_pre_and_postprocessing </li> <li> <code></code>\u00a0setup_pre_and_postprocessing </li> </ul> </li> <li> <code></code>\u00a0stat_calculators <ul> <li> <code></code>\u00a0StatsCalculator </li> <li> <code></code>\u00a0compute_dataset_measures </li> </ul> </li> <li> <code></code>\u00a0stat_measures <code></code>\u00a0Measure </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeanMeasure","title":"MeanMeasure  <code>module-attribute</code>","text":"<pre><code>MeanMeasure = Union[SampleMean, DatasetMean]\n</code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0proc_ops <code></code>\u00a0ZeroMeanUnitVariance </li> <li> <code></code>\u00a0stat_measures <code></code>\u00a0MeanMeasureT </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeanMeasureT","title":"MeanMeasureT  <code>module-attribute</code>","text":"<pre><code>MeanMeasureT = TypeVar('MeanMeasureT', bound=MeanMeasure)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.Measure","title":"Measure  <code>module-attribute</code>","text":"<pre><code>Measure = Annotated[Union[SampleMeasure, DatasetMeasure], Discriminator('scope')]\n</code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0compute_measures </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0stat_calculators <ul> <li> <code></code>\u00a0StatsCalculator </li> <li> <code></code>\u00a0compute_measures </li> <li> <code></code>\u00a0get_measure_calculators </li> </ul> </li> <li> <code></code>\u00a0stat_measures <code></code>\u00a0Stat </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureValue","title":"MeasureValue  <code>module-attribute</code>","text":"<pre><code>MeasureValue = Union[float, Annotated[Tensor, BeforeValidator(tensor_custom_before_validator), PlainSerializer(tensor_custom_serializer)]]\n</code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <ul> <li> <code></code>\u00a0compute_dataset_measures </li> <li> <code></code>\u00a0compute_measures </li> <li> <code></code>\u00a0compute_sample_measures </li> </ul> </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0core <code></code>\u00a0create_prediction_pipeline </li> <li> <code></code>\u00a0io <code></code>\u00a0save_dataset_stat </li> <li> <code></code>\u00a0proc_ops <code></code>\u00a0AddKnownDatasetStats </li> <li> <code></code>\u00a0proc_setup <ul> <li> <code></code>\u00a0get_pre_and_postprocessing </li> <li> <code></code>\u00a0setup_pre_and_postprocessing </li> </ul> </li> <li> <code></code>\u00a0stat_calculators <code></code>\u00a0StatsCalculator </li> <li> <code></code>\u00a0stat_measures <code></code>\u00a0Stat </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.PercentileMeasure","title":"PercentileMeasure  <code>module-attribute</code>","text":"<pre><code>PercentileMeasure = Union[SampleQuantile, DatasetQuantile]\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <code></code>\u00a0PercentileMeasureT </li> </ul>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.PercentileMeasureT","title":"PercentileMeasureT  <code>module-attribute</code>","text":"<pre><code>PercentileMeasureT = TypeVar('PercentileMeasureT', bound=PercentileMeasure)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasure","title":"SampleMeasure  <code>module-attribute</code>","text":"<pre><code>SampleMeasure = Annotated[Union[SampleMean, SampleStd, SampleVar, SampleQuantile], Discriminator('name')]\n</code></pre> Returned by: <ul> <li> API Reference <code></code>\u00a0stat_calculators <code></code>\u00a0compute_sample_measures </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0stat_calculators <ul> <li> <code></code>\u00a0NaiveSampleMeasureCalculator </li> <li> <code></code>\u00a0compute_sample_measures </li> </ul> </li> <li> <code></code>\u00a0stat_measures <code></code>\u00a0Measure </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.Stat","title":"Stat  <code>module-attribute</code>","text":"<pre><code>Stat = Dict[Measure, MeasureValue]\n</code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0core <code></code>\u00a0Stat </li> <li> <code></code>\u00a0digest_spec <ul> <li> <code></code>\u00a0create_sample_for_model </li> <li> <code></code>\u00a0load_sample_for_model </li> </ul> </li> <li> <code></code>\u00a0sample <ul> <li> <code></code>\u00a0Sample </li> <li> <code></code>\u00a0SampleBlock </li> <li> <code></code>\u00a0SampleBlockWithOrigin </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.StdMeasure","title":"StdMeasure  <code>module-attribute</code>","text":"<pre><code>StdMeasure = Union[SampleStd, DatasetStd]\n</code></pre> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0proc_ops <code></code>\u00a0ZeroMeanUnitVariance </li> <li> <code></code>\u00a0stat_measures <code></code>\u00a0StdMeasureT </li> </ul> </li> </ul>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.StdMeasureT","title":"StdMeasureT  <code>module-attribute</code>","text":"<pre><code>StdMeasureT = TypeVar('StdMeasureT', bound=StdMeasure)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.VarMeasure","title":"VarMeasure  <code>module-attribute</code>","text":"<pre><code>VarMeasure = Union[SampleVar, DatasetVar]\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <code></code>\u00a0VarMeasureT </li> </ul>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.VarMeasureT","title":"VarMeasureT  <code>module-attribute</code>","text":"<pre><code>VarMeasureT = TypeVar('VarMeasureT', bound=VarMeasure)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean","title":"DatasetMean","text":"<pre><code>DatasetMean(**data: Any)\n</code></pre> <p>               Bases: <code>_Mean</code>, <code>DatasetMeasureBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.DatasetMean[DatasetMean]\n              bioimageio.core.stat_measures._Mean[_Mean]\n              bioimageio.core.stat_measures.DatasetMeasureBase[DatasetMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures._Mean --&gt; bioimageio.core.stat_measures.DatasetMean\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures._Mean\n                \n\n                bioimageio.core.stat_measures.DatasetMeasureBase --&gt; bioimageio.core.stat_measures.DatasetMean\n                                bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.DatasetMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n\n              click bioimageio.core.stat_measures.DatasetMean href \"\" \"bioimageio.core.stat_measures.DatasetMean\"\n              click bioimageio.core.stat_measures._Mean href \"\" \"bioimageio.core.stat_measures._Mean\"\n              click bioimageio.core.stat_measures.DatasetMeasureBase href \"\" \"bioimageio.core.stat_measures.DatasetMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>The mean value across multiple samples</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0DatasetMeasure </li> <li> <code></code>\u00a0MeanMeasure </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>axes</code> <code>Optional[Tuple[AxisId, ...]]</code> <p><code>axes</code> to reduce</p> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>name</code> <code>Literal['mean']</code> <code>scope</code> <code>Literal['dataset']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.axes","title":"axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axes: Optional[Tuple[AxisId, ...]] = None\n</code></pre> <p><code>axes</code> to reduce</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Literal['mean'] = 'mean'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['dataset'] = 'dataset'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any)\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def model_post_init(self, __context: Any):\n    assert self.axes is None or AxisId(\"batch\") in self.axes\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMean.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase","title":"DatasetMeasureBase","text":"<pre><code>DatasetMeasureBase(**data: Any)\n</code></pre> <p>               Bases: <code>MeasureBase</code>, <code>ABC</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.DatasetMeasureBase[DatasetMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.DatasetMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n              click bioimageio.core.stat_measures.DatasetMeasureBase href \"\" \"bioimageio.core.stat_measures.DatasetMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0DatasetMean </li> <li> <code></code>\u00a0DatasetQuantile </li> <li> <code></code>\u00a0DatasetStd </li> <li> <code></code>\u00a0DatasetVar </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>scope</code> <code>Literal['dataset']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['dataset'] = 'dataset'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetMeasureBase.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile","title":"DatasetQuantile","text":"<pre><code>DatasetQuantile(**data: Any)\n</code></pre> <p>               Bases: <code>_Quantile</code>, <code>DatasetMeasureBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.DatasetQuantile[DatasetQuantile]\n              bioimageio.core.stat_measures._Quantile[_Quantile]\n              bioimageio.core.stat_measures.DatasetMeasureBase[DatasetMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures._Quantile --&gt; bioimageio.core.stat_measures.DatasetQuantile\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures._Quantile\n                \n\n                bioimageio.core.stat_measures.DatasetMeasureBase --&gt; bioimageio.core.stat_measures.DatasetQuantile\n                                bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.DatasetMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n\n              click bioimageio.core.stat_measures.DatasetQuantile href \"\" \"bioimageio.core.stat_measures.DatasetQuantile\"\n              click bioimageio.core.stat_measures._Quantile href \"\" \"bioimageio.core.stat_measures._Quantile\"\n              click bioimageio.core.stat_measures.DatasetMeasureBase href \"\" \"bioimageio.core.stat_measures.DatasetMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>The <code>q</code>th quantile across multiple samples</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0proc_ops <ul> <li> <code></code>\u00a0Clip </li> <li> <code></code>\u00a0ScaleRange </li> </ul> </li> <li> <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0DatasetMeasure </li> <li> <code></code>\u00a0PercentileMeasure </li> </ul> </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>axes</code> <code>Optional[Tuple[AxisId, ...]]</code> <p><code>axes</code> to reduce</p> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>name</code> <code>Literal['quantile']</code> <code>q</code> <code>float</code> <code>scope</code> <code>Literal['dataset']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.axes","title":"axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axes: Optional[Tuple[AxisId, ...]] = None\n</code></pre> <p><code>axes</code> to reduce</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Literal['quantile'] = 'quantile'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.q","title":"q  <code>instance-attribute</code>","text":"<pre><code>q: float\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['dataset'] = 'dataset'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any)\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def model_post_init(self, __context: Any):\n    super().model_post_init(__context)\n    assert self.axes is None or AxisId(\"batch\") in self.axes\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetQuantile.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd","title":"DatasetStd","text":"<pre><code>DatasetStd(**data: Any)\n</code></pre> <p>               Bases: <code>_Std</code>, <code>DatasetMeasureBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.DatasetStd[DatasetStd]\n              bioimageio.core.stat_measures._Std[_Std]\n              bioimageio.core.stat_measures.DatasetMeasureBase[DatasetMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures._Std --&gt; bioimageio.core.stat_measures.DatasetStd\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures._Std\n                \n\n                bioimageio.core.stat_measures.DatasetMeasureBase --&gt; bioimageio.core.stat_measures.DatasetStd\n                                bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.DatasetMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n\n              click bioimageio.core.stat_measures.DatasetStd href \"\" \"bioimageio.core.stat_measures.DatasetStd\"\n              click bioimageio.core.stat_measures._Std href \"\" \"bioimageio.core.stat_measures._Std\"\n              click bioimageio.core.stat_measures.DatasetMeasureBase href \"\" \"bioimageio.core.stat_measures.DatasetMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>The standard deviation across multiple samples</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0DatasetMeasure </li> <li> <code></code>\u00a0StdMeasure </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>axes</code> <code>Optional[Tuple[AxisId, ...]]</code> <p><code>axes</code> to reduce</p> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>name</code> <code>Literal['std']</code> <code>scope</code> <code>Literal['dataset']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.axes","title":"axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axes: Optional[Tuple[AxisId, ...]] = None\n</code></pre> <p><code>axes</code> to reduce</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Literal['std'] = 'std'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['dataset'] = 'dataset'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any)\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def model_post_init(self, __context: Any):\n    assert self.axes is None or AxisId(\"batch\") in self.axes\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetStd.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar","title":"DatasetVar","text":"<pre><code>DatasetVar(**data: Any)\n</code></pre> <p>               Bases: <code>_Var</code>, <code>DatasetMeasureBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.DatasetVar[DatasetVar]\n              bioimageio.core.stat_measures._Var[_Var]\n              bioimageio.core.stat_measures.DatasetMeasureBase[DatasetMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures._Var --&gt; bioimageio.core.stat_measures.DatasetVar\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures._Var\n                \n\n                bioimageio.core.stat_measures.DatasetMeasureBase --&gt; bioimageio.core.stat_measures.DatasetVar\n                                bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.DatasetMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n\n              click bioimageio.core.stat_measures.DatasetVar href \"\" \"bioimageio.core.stat_measures.DatasetVar\"\n              click bioimageio.core.stat_measures._Var href \"\" \"bioimageio.core.stat_measures._Var\"\n              click bioimageio.core.stat_measures.DatasetMeasureBase href \"\" \"bioimageio.core.stat_measures.DatasetMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>The variance across multiple samples</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0DatasetMeasure </li> <li> <code></code>\u00a0VarMeasure </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>axes</code> <code>Optional[Tuple[AxisId, ...]]</code> <p><code>axes</code> to reduce</p> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>name</code> <code>Literal['var']</code> <code>scope</code> <code>Literal['dataset']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.axes","title":"axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axes: Optional[Tuple[AxisId, ...]] = None\n</code></pre> <p><code>axes</code> to reduce</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Literal['var'] = 'var'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['dataset'] = 'dataset'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any)\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def model_post_init(self, __context: Any):  # TODO: turn into @model_validator\n    assert self.axes is None or AxisId(\"batch\") in self.axes\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.DatasetVar.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase","title":"MeasureBase","text":"<pre><code>MeasureBase(**data: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0DatasetMeasureBase </li> <li> <code></code>\u00a0SampleMeasureBase </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.MeasureBase.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleLike","title":"SampleLike","text":"<p>               Bases: <code>Protocol</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.SampleLike[SampleLike]\n\n              \n\n              click bioimageio.core.stat_measures.SampleLike href \"\" \"bioimageio.core.stat_measures.SampleLike\"\n            </code></pre> <p>Attributes:</p> Name Type Description <code>members</code> <code>PerMember[Tensor]</code>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleLike.members","title":"members  <code>property</code>","text":"<pre><code>members: PerMember[Tensor]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean","title":"SampleMean","text":"<pre><code>SampleMean(**data: Any)\n</code></pre> <p>               Bases: <code>_Mean</code>, <code>SampleMeasureBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.SampleMean[SampleMean]\n              bioimageio.core.stat_measures._Mean[_Mean]\n              bioimageio.core.stat_measures.SampleMeasureBase[SampleMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures._Mean --&gt; bioimageio.core.stat_measures.SampleMean\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures._Mean\n                \n\n                bioimageio.core.stat_measures.SampleMeasureBase --&gt; bioimageio.core.stat_measures.SampleMean\n                                bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.SampleMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n\n              click bioimageio.core.stat_measures.SampleMean href \"\" \"bioimageio.core.stat_measures.SampleMean\"\n              click bioimageio.core.stat_measures._Mean href \"\" \"bioimageio.core.stat_measures._Mean\"\n              click bioimageio.core.stat_measures.SampleMeasureBase href \"\" \"bioimageio.core.stat_measures.SampleMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>The mean value of a single tensor</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0MeanMeasure </li> <li> <code></code>\u00a0SampleMeasure </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>compute</code> <p>compute the measure</p> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>axes</code> <code>Optional[Tuple[AxisId, ...]]</code> <p><code>axes</code> to reduce</p> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>name</code> <code>Literal['mean']</code> <code>scope</code> <code>Literal['sample']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.axes","title":"axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axes: Optional[Tuple[AxisId, ...]] = None\n</code></pre> <p><code>axes</code> to reduce</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Literal['mean'] = 'mean'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['sample'] = 'sample'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.compute","title":"compute","text":"<pre><code>compute(sample: SampleLike) -&gt; MeasureValue\n</code></pre> <p>compute the measure</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def compute(self, sample: SampleLike) -&gt; MeasureValue:\n    tensor = sample.members[self.member_id]\n    return tensor.mean(dim=self.axes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any)\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def model_post_init(self, __context: Any):\n    assert self.axes is None or AxisId(\"batch\") not in self.axes\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMean.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase","title":"SampleMeasureBase","text":"<pre><code>SampleMeasureBase(**data: Any)\n</code></pre> <p>               Bases: <code>MeasureBase</code>, <code>ABC</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.SampleMeasureBase[SampleMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.SampleMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n              click bioimageio.core.stat_measures.SampleMeasureBase href \"\" \"bioimageio.core.stat_measures.SampleMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Subclassed by: <ul> <li> API Reference <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0SampleMean </li> <li> <code></code>\u00a0SampleQuantile </li> <li> <code></code>\u00a0SampleStd </li> <li> <code></code>\u00a0SampleVar </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>compute</code> <p>compute the measure</p> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>scope</code> <code>Literal['sample']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['sample'] = 'sample'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.compute","title":"compute  <code>abstractmethod</code>","text":"<pre><code>compute(sample: SampleLike) -&gt; MeasureValue\n</code></pre> <p>compute the measure</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>@abstractmethod\ndef compute(self, sample: SampleLike) -&gt; MeasureValue:\n    \"\"\"compute the measure\"\"\"\n    ...\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleMeasureBase.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile","title":"SampleQuantile","text":"<pre><code>SampleQuantile(**data: Any)\n</code></pre> <p>               Bases: <code>_Quantile</code>, <code>SampleMeasureBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.SampleQuantile[SampleQuantile]\n              bioimageio.core.stat_measures._Quantile[_Quantile]\n              bioimageio.core.stat_measures.SampleMeasureBase[SampleMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures._Quantile --&gt; bioimageio.core.stat_measures.SampleQuantile\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures._Quantile\n                \n\n                bioimageio.core.stat_measures.SampleMeasureBase --&gt; bioimageio.core.stat_measures.SampleQuantile\n                                bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.SampleMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n\n              click bioimageio.core.stat_measures.SampleQuantile href \"\" \"bioimageio.core.stat_measures.SampleQuantile\"\n              click bioimageio.core.stat_measures._Quantile href \"\" \"bioimageio.core.stat_measures._Quantile\"\n              click bioimageio.core.stat_measures.SampleMeasureBase href \"\" \"bioimageio.core.stat_measures.SampleMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>The <code>q</code>th quantile of a single tensor</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0proc_ops <ul> <li> <code></code>\u00a0Clip </li> <li> <code></code>\u00a0ScaleRange </li> </ul> </li> <li> <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0PercentileMeasure </li> <li> <code></code>\u00a0SampleMeasure </li> </ul> </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>compute</code> <p>compute the measure</p> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>axes</code> <code>Optional[Tuple[AxisId, ...]]</code> <p><code>axes</code> to reduce</p> <code>member_id</code> <code>MemberId</code> <code>method</code> <code>QuantileMethod</code> <p>Method to use when the desired quantile lies between two data points.</p> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>name</code> <code>Literal['quantile']</code> <code>q</code> <code>float</code> <code>scope</code> <code>Literal['sample']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.axes","title":"axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axes: Optional[Tuple[AxisId, ...]] = None\n</code></pre> <p><code>axes</code> to reduce</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.method","title":"method  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>method: QuantileMethod = 'linear'\n</code></pre> <p>Method to use when the desired quantile lies between two data points. See https://numpy.org/devdocs/reference/generated/numpy.quantile.html#numpy-quantile for details.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Literal['quantile'] = 'quantile'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.q","title":"q  <code>instance-attribute</code>","text":"<pre><code>q: float\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['sample'] = 'sample'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.compute","title":"compute","text":"<pre><code>compute(sample: SampleLike) -&gt; MeasureValue\n</code></pre> <p>compute the measure</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def compute(self, sample: SampleLike) -&gt; MeasureValue:\n    tensor = sample.members[self.member_id]\n    return tensor.quantile(self.q, dim=self.axes, method=self.method)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any)\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def model_post_init(self, __context: Any):\n    super().model_post_init(__context)\n    assert self.axes is None or AxisId(\"batch\") not in self.axes\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleQuantile.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd","title":"SampleStd","text":"<pre><code>SampleStd(**data: Any)\n</code></pre> <p>               Bases: <code>_Std</code>, <code>SampleMeasureBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.SampleStd[SampleStd]\n              bioimageio.core.stat_measures._Std[_Std]\n              bioimageio.core.stat_measures.SampleMeasureBase[SampleMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures._Std --&gt; bioimageio.core.stat_measures.SampleStd\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures._Std\n                \n\n                bioimageio.core.stat_measures.SampleMeasureBase --&gt; bioimageio.core.stat_measures.SampleStd\n                                bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.SampleMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n\n              click bioimageio.core.stat_measures.SampleStd href \"\" \"bioimageio.core.stat_measures.SampleStd\"\n              click bioimageio.core.stat_measures._Std href \"\" \"bioimageio.core.stat_measures._Std\"\n              click bioimageio.core.stat_measures.SampleMeasureBase href \"\" \"bioimageio.core.stat_measures.SampleMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>The standard deviation of a single tensor</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0SampleMeasure </li> <li> <code></code>\u00a0StdMeasure </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>compute</code> <p>compute the measure</p> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>axes</code> <code>Optional[Tuple[AxisId, ...]]</code> <p><code>axes</code> to reduce</p> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>name</code> <code>Literal['std']</code> <code>scope</code> <code>Literal['sample']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.axes","title":"axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axes: Optional[Tuple[AxisId, ...]] = None\n</code></pre> <p><code>axes</code> to reduce</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Literal['std'] = 'std'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['sample'] = 'sample'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.compute","title":"compute","text":"<pre><code>compute(sample: SampleLike) -&gt; MeasureValue\n</code></pre> <p>compute the measure</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def compute(self, sample: SampleLike) -&gt; MeasureValue:\n    tensor = sample.members[self.member_id]\n    return tensor.std(dim=self.axes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any)\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def model_post_init(self, __context: Any):\n    assert self.axes is None or AxisId(\"batch\") not in self.axes\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleStd.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar","title":"SampleVar","text":"<pre><code>SampleVar(**data: Any)\n</code></pre> <p>               Bases: <code>_Var</code>, <code>SampleMeasureBase</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.stat_measures.SampleVar[SampleVar]\n              bioimageio.core.stat_measures._Var[_Var]\n              bioimageio.core.stat_measures.SampleMeasureBase[SampleMeasureBase]\n              bioimageio.core.stat_measures.MeasureBase[MeasureBase]\n              pydantic.main.BaseModel[BaseModel]\n\n                              bioimageio.core.stat_measures._Var --&gt; bioimageio.core.stat_measures.SampleVar\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures._Var\n                \n\n                bioimageio.core.stat_measures.SampleMeasureBase --&gt; bioimageio.core.stat_measures.SampleVar\n                                bioimageio.core.stat_measures.MeasureBase --&gt; bioimageio.core.stat_measures.SampleMeasureBase\n                                pydantic.main.BaseModel --&gt; bioimageio.core.stat_measures.MeasureBase\n                \n\n\n\n\n              click bioimageio.core.stat_measures.SampleVar href \"\" \"bioimageio.core.stat_measures.SampleVar\"\n              click bioimageio.core.stat_measures._Var href \"\" \"bioimageio.core.stat_measures._Var\"\n              click bioimageio.core.stat_measures.SampleMeasureBase href \"\" \"bioimageio.core.stat_measures.SampleMeasureBase\"\n              click bioimageio.core.stat_measures.MeasureBase href \"\" \"bioimageio.core.stat_measures.MeasureBase\"\n              click pydantic.main.BaseModel href \"\" \"pydantic.main.BaseModel\"\n            </code></pre> <p>The variance of a single tensor</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0SampleMeasure </li> <li> <code></code>\u00a0VarMeasure </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__class_getitem__</code> <code>__copy__</code> <p>Returns a shallow copy of the model.</p> <code>__deepcopy__</code> <p>Returns a deep copy of the model.</p> <code>__delattr__</code> <code>__eq__</code> <code>__get_pydantic_core_schema__</code> <code>__get_pydantic_json_schema__</code> <p>Hook into generating the model's JSON schema.</p> <code>__getattr__</code> <code>__getstate__</code> <code>__init_subclass__</code> <p>This signature is included purely to help type-checkers check arguments to class declaration, which</p> <code>__iter__</code> <p>So <code>dict(model)</code> works.</p> <code>__pydantic_init_subclass__</code> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code></p> <code>__pydantic_on_complete__</code> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <code>__replace__</code> <code>__repr__</code> <code>__repr_args__</code> <code>__setattr__</code> <code>__setstate__</code> <code>__str__</code> <code>compute</code> <p>compute the measure</p> <code>construct</code> <code>copy</code> <p>Returns a copy of the model.</p> <code>dict</code> <code>from_orm</code> <code>json</code> <code>model_computed_fields</code> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <code>model_construct</code> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <code>model_copy</code> <p>Usage Documentation</p> <code>model_dump</code> <p>Usage Documentation</p> <code>model_dump_json</code> <p>Usage Documentation</p> <code>model_fields</code> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <code>model_json_schema</code> <p>Generates a JSON schema for a model class.</p> <code>model_parametrized_name</code> <p>Compute the class name for parametrizations of generic classes.</p> <code>model_post_init</code> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <code>model_rebuild</code> <p>Try to rebuild the pydantic-core schema for the model.</p> <code>model_validate</code> <p>Validate a pydantic model instance.</p> <code>model_validate_json</code> <p>Usage Documentation</p> <code>model_validate_strings</code> <p>Validate the given object with string data against the Pydantic model.</p> <code>parse_file</code> <code>parse_obj</code> <code>parse_raw</code> <code>schema</code> <code>schema_json</code> <code>update_forward_refs</code> <code>validate</code> <p>Attributes:</p> Name Type Description <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__fields__</code> <code>dict[str, FieldInfo]</code> <code>__fields_set__</code> <code>set[str]</code> <code>__pretty__</code> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> method.</p> <code>__pydantic_decorators__</code> <code>_decorators.DecoratorInfos</code> <p>Metadata containing the decorators defined on the model.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_generic_metadata__</code> <code>_generics.PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_setattr_handlers__</code> <code>Dict[str, Callable[[BaseModel, str, Any], None]]</code> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__repr_name__</code> <code>__repr_recursion__</code> <code>__repr_str__</code> <code>__rich_repr__</code> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p> <code>__slots__</code> <code>axes</code> <code>Optional[Tuple[AxisId, ...]]</code> <p><code>axes</code> to reduce</p> <code>member_id</code> <code>MemberId</code> <code>model_config</code> <code>ConfigDict</code> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p> <code>model_extra</code> <code>dict[str, Any] | None</code> <p>Get extra fields set during validation.</p> <code>model_fields_set</code> <code>set[str]</code> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <code>name</code> <code>Literal['var']</code> <code>scope</code> <code>Literal['sample']</code> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__class_vars__","title":"__class_vars__  <code>class-attribute</code>","text":"<pre><code>__class_vars__: set[str]\n</code></pre> <p>The names of the class variables defined on the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__fields__","title":"__fields__  <code>property</code>","text":"<pre><code>__fields__: dict[str, FieldInfo]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__fields_set__","title":"__fields_set__  <code>property</code>","text":"<pre><code>__fields_set__: set[str]\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pretty__","title":"__pretty__  <code>pydantic-field</code>","text":"<pre><code>__pretty__ = _repr.Representation.__pretty__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__private_attributes__","title":"__private_attributes__  <code>class-attribute</code>","text":"<pre><code>__private_attributes__: Dict[str, ModelPrivateAttr]\n</code></pre> <p>Metadata about the private attributes of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_complete__","title":"__pydantic_complete__  <code>class-attribute</code>","text":"<pre><code>__pydantic_complete__: bool = False\n</code></pre> <p>Whether model building is completed, or if there are still undefined fields.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_computed_fields__","title":"__pydantic_computed_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_computed_fields__: Dict[str, ComputedFieldInfo]\n</code></pre> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_custom_init__","title":"__pydantic_custom_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_custom_init__: bool\n</code></pre> <p>Whether the model has a custom <code>__init__</code> method.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_decorators__","title":"__pydantic_decorators__  <code>class-attribute</code>","text":"<pre><code>__pydantic_decorators__: _decorators.DecoratorInfos = _decorators.DecoratorInfos()\n</code></pre> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_extra__","title":"__pydantic_extra__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_extra__: Dict[str, Any] | None\n</code></pre> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_fields__","title":"__pydantic_fields__  <code>class-attribute</code>","text":"<pre><code>__pydantic_fields__: Dict[str, FieldInfo]\n</code></pre> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects. This replaces <code>Model.__fields__</code> from Pydantic V1.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_fields_set__","title":"__pydantic_fields_set__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_fields_set__: set[str]\n</code></pre> <p>The names of fields explicitly set during instantiation.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_generic_metadata__","title":"__pydantic_generic_metadata__  <code>class-attribute</code>","text":"<pre><code>__pydantic_generic_metadata__: _generics.PydanticGenericMetadata\n</code></pre> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_parent_namespace__","title":"__pydantic_parent_namespace__  <code>class-attribute</code>","text":"<pre><code>__pydantic_parent_namespace__: Dict[str, Any] | None = None\n</code></pre> <p>Parent namespace of the model, used for automatic rebuilding of models.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_post_init__","title":"__pydantic_post_init__  <code>class-attribute</code>","text":"<pre><code>__pydantic_post_init__: None | Literal['model_post_init']\n</code></pre> <p>The name of the post-init method for the model, if defined.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_private__","title":"__pydantic_private__  <code>pydantic-field</code>","text":"<pre><code>__pydantic_private__: Dict[str, Any] | None\n</code></pre> <p>Values of private attributes set on the model instance.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_root_model__","title":"__pydantic_root_model__  <code>class-attribute</code>","text":"<pre><code>__pydantic_root_model__: bool = False\n</code></pre> <p>Whether the model is a <code>RootModel</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_serializer__","title":"__pydantic_serializer__  <code>class-attribute</code>","text":"<pre><code>__pydantic_serializer__: SchemaSerializer\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_setattr_handlers__","title":"__pydantic_setattr_handlers__  <code>class-attribute</code>","text":"<pre><code>__pydantic_setattr_handlers__: Dict[str, Callable[[BaseModel, str, Any], None]]\n</code></pre> <p><code>__setattr__</code> handlers. Memoizing the handlers leads to a dramatic performance improvement in <code>__setattr__</code></p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_validator__","title":"__pydantic_validator__  <code>class-attribute</code>","text":"<pre><code>__pydantic_validator__: SchemaValidator | PluggableSchemaValidator\n</code></pre> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__repr_name__","title":"__repr_name__  <code>pydantic-field</code>","text":"<pre><code>__repr_name__ = _repr.Representation.__repr_name__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__repr_recursion__","title":"__repr_recursion__  <code>pydantic-field</code>","text":"<pre><code>__repr_recursion__ = _repr.Representation.__repr_recursion__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__repr_str__","title":"__repr_str__  <code>pydantic-field</code>","text":"<pre><code>__repr_str__ = _repr.Representation.__repr_str__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__rich_repr__","title":"__rich_repr__  <code>pydantic-field</code>","text":"<pre><code>__rich_repr__ = _repr.Representation.__rich_repr__\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__signature__","title":"__signature__  <code>class-attribute</code>","text":"<pre><code>__signature__: Signature\n</code></pre> <p>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__slots__","title":"__slots__  <code>pydantic-field</code>","text":"<pre><code>__slots__ = ('__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.axes","title":"axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axes: Optional[Tuple[AxisId, ...]] = None\n</code></pre> <p><code>axes</code> to reduce</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.member_id","title":"member_id  <code>instance-attribute</code>","text":"<pre><code>member_id: MemberId\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of strings representing the fields that have been set,     i.e. that were not filled from defaults.</p>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Literal['var'] = 'var'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.scope","title":"scope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scope: Literal['sample'] = 'sample'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__class_getitem__","title":"__class_getitem__","text":"<pre><code>__class_getitem__(typevar_values: type[Any] | tuple[type[Any], ...]) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __class_getitem__(\n    cls, typevar_values: type[Any] | tuple[type[Any], ...]\n) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n    cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n    if cached is not None:\n        return cached\n\n    if cls is BaseModel:\n        raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n    if not hasattr(cls, '__parameters__'):\n        raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n    if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n        raise TypeError(f'{cls} is not a generic class')\n\n    if not isinstance(typevar_values, tuple):\n        typevar_values = (typevar_values,)\n\n    # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n    # this gives us `{T: str, U: bool, V: int}`:\n    typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n    # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n    typevar_values = tuple(v for v in typevars_map.values())\n\n    if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n        submodel = cls  # if arguments are equal to parameters it's the same object\n        _generics.set_cached_generic_type(cls, typevar_values, submodel)\n    else:\n        parent_args = cls.__pydantic_generic_metadata__['args']\n        if not parent_args:\n            args = typevar_values\n        else:\n            args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n        origin = cls.__pydantic_generic_metadata__['origin'] or cls\n        model_name = origin.model_parametrized_name(args)\n        params = tuple(\n            dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n        )  # use dict as ordered set\n\n        with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n            cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n            if cached is not None:\n                return cached\n\n            if maybe_self_type is not None:\n                return maybe_self_type\n\n            # Attempt to rebuild the origin in case new types have been defined\n            try:\n                # depth 2 gets you above this __class_getitem__ call.\n                # Note that we explicitly provide the parent ns, otherwise\n                # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                # We don't want this here, as this has unexpected effects when a model\n                # is being parametrized during a forward annotation evaluation.\n                parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                origin.model_rebuild(_types_namespace=parent_ns)\n            except PydanticUndefinedAnnotation:\n                # It's okay if it fails, it just means there are still undefined types\n                # that could be evaluated later.\n                pass\n\n            submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n            _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n    return submodel\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__copy__","title":"__copy__","text":"<pre><code>__copy__() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Returns a shallow copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', copy(self.__dict__))\n    _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict[int, Any] | None = None) -&gt; Self\n</code></pre> <p>Returns a deep copy of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n    \"\"\"Returns a deep copy of the model.\"\"\"\n    cls = type(self)\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n    _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n    # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n    # and attempting a deepcopy would be marginally slower.\n    _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n    if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n        _object_setattr(m, '__pydantic_private__', None)\n    else:\n        _object_setattr(\n            m,\n            '__pydantic_private__',\n            deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n        )\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __delattr__(self, item: str) -&gt; Any:\n    cls = self.__class__\n\n    if item in self.__private_attributes__:\n        attribute = self.__private_attributes__[item]\n        if hasattr(attribute, '__delete__'):\n            attribute.__delete__(self)  # type: ignore\n            return\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            del self.__pydantic_private__[item]  # type: ignore\n            return\n        except KeyError as exc:\n            raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n    # Allow cached properties to be deleted (even if the class is frozen):\n    attr = getattr(cls, item, None)\n    if isinstance(attr, cached_property):\n        return object.__delattr__(self, item)\n\n    _check_frozen(cls, name=item, value=None)\n\n    if item in self.__pydantic_fields__:\n        object.__delattr__(self, item)\n    elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n        del self.__pydantic_extra__[item]\n    else:\n        try:\n            object.__delattr__(self, item)\n        except AttributeError:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    if isinstance(other, BaseModel):\n        # When comparing instances of generic types for equality, as long as all field values are equal,\n        # only require their generic origin types to be equal, rather than exact type equality.\n        # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n        self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n        other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n        # Perform common checks first\n        if not (\n            self_type == other_type\n            and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n            and self.__pydantic_extra__ == other.__pydantic_extra__\n        ):\n            return False\n\n        # We only want to compare pydantic fields but ignoring fields is costly.\n        # We'll perform a fast check first, and fallback only when needed\n        # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n        # First, do the fast (and sometimes faulty) __dict__ comparison\n        if self.__dict__ == other.__dict__:\n            # If the check above passes, then pydantic fields are equal, we can return early\n            return True\n\n        # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n        # early if there are no keys to ignore (we would just return False later on anyway)\n        model_fields = type(self).__pydantic_fields__.keys()\n        if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n            return False\n\n        # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n        # Resort to costly filtering of the __dict__ objects\n        # We use operator.itemgetter because it is much faster than dict comprehensions\n        # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n        # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n        # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n        # So we can use operator.itemgetter() instead of operator.attrgetter()\n        getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n        try:\n            return getter(self.__dict__) == getter(other.__dict__)\n        except KeyError:\n            # In rare cases (such as when using the deprecated BaseModel.copy() method),\n            # the __dict__ may not contain all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts\n            # for missing keys, and wrapping it in a `try` doesn't slow things down much\n            # in the common case.\n            self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n            other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n            return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n    # other instance is not a BaseModel\n    else:\n        return NotImplemented  # delegate to the other item in the comparison\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[BaseModel], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n    # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n    # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n    # *not* be called if not overridden.\n    warnings.warn(\n        'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n        '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n        '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n        'side effects.',\n        PydanticDeprecatedSince211,\n        stacklevel=2,\n    )\n    # Logic copied over from `GenerateSchema._model_schema`:\n    schema = cls.__dict__.get('__pydantic_core_schema__')\n    if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n        return cls.__pydantic_core_schema__\n\n    return handler(source)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(core_schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue\n</code></pre> <p>Hook into generating the model's JSON schema.</p> <p>Parameters:</p> Name Type Description Default <code>CoreSchema</code> <p>A <code>pydantic-core</code> CoreSchema. You can ignore this argument and call the handler with a new CoreSchema, wrap this CoreSchema (<code>{'type': 'nullable', 'schema': current_schema}</code>), or just call the handler with the original schema.</p> required <code>GetJsonSchemaHandler</code> <p>Call into Pydantic's internal JSON schema generation. This will raise a <code>pydantic.errors.PydanticInvalidForJsonSchema</code> if JSON schema generation fails. Since this gets called by <code>BaseModel.model_json_schema</code> you can override the <code>schema_generator</code> argument to that function to change JSON schema generation globally for a type.</p> required <p>Returns:</p> Type Description <code>JsonSchemaValue</code> <p>A JSON schema, as a Python object.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n    /,\n) -&gt; JsonSchemaValue:\n    \"\"\"Hook into generating the model's JSON schema.\n\n    Args:\n        core_schema: A `pydantic-core` CoreSchema.\n            You can ignore this argument and call the handler with a new CoreSchema,\n            wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n            or just call the handler with the original schema.\n        handler: Call into Pydantic's internal JSON schema generation.\n            This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n            generation fails.\n            Since this gets called by `BaseModel.model_json_schema` you can override the\n            `schema_generator` argument to that function to change JSON schema generation globally\n            for a type.\n\n    Returns:\n        A JSON schema, as a Python object.\n    \"\"\"\n    return handler(core_schema)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__get_pydantic_json_schema__(core_schema)","title":"<code>core_schema</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__get_pydantic_json_schema__(handler)","title":"<code>handler</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(item: str) -&gt; Any\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    private_attributes = object.__getattribute__(self, '__private_attributes__')\n    if item in private_attributes:\n        attribute = private_attributes[item]\n        if hasattr(attribute, '__get__'):\n            return attribute.__get__(self, type(self))  # type: ignore\n\n        try:\n            # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n            return self.__pydantic_private__[item]  # type: ignore\n        except KeyError as exc:\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n    else:\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # See `BaseModel.__repr_args__` for more details\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra and item in pydantic_extra:\n            return pydantic_extra[item]\n        else:\n            if hasattr(self.__class__, item):\n                return super().__getattribute__(item)  # Raises AttributeError if appropriate\n            else:\n                # this is the current error\n                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__getstate__","title":"__getstate__","text":"<pre><code>__getstate__() -&gt; dict[Any, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __getstate__(self) -&gt; dict[Any, Any]:\n    private = self.__pydantic_private__\n    if private:\n        private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n    return {\n        '__dict__': self.__dict__,\n        '__pydantic_extra__': self.__pydantic_extra__,\n        '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        '__pydantic_private__': private,\n    }\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Unpack[ConfigDict])\n</code></pre> <p>This signature is included purely to help type-checkers check arguments to class declaration, which provides a way to conveniently set model_config key/value pairs.</p> <pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n</code></pre> <p>However, this may be deceiving, since the actual calls to <code>__init_subclass__</code> will not receive any of the config arguments, and will only receive any keyword arguments passed during class initialization that are not expected keys in ConfigDict. (This is due to the way <code>ModelMetaclass.__new__</code> works.)</p> <p>Parameters:</p> Name Type Description Default <code>Unpack[ConfigDict]</code> <p>Keyword arguments passed to the class definition, which set model_config</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_init_subclass__</code> instead, which behaves similarly but is called after the class is fully initialized.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n    \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n    provides a way to conveniently set model_config key/value pairs.\n\n    ```python\n    from pydantic import BaseModel\n\n    class MyModel(BaseModel, extra='allow'): ...\n    ```\n\n    However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n    of the config arguments, and will only receive any keyword arguments passed during class initialization\n    that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n    Args:\n        **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n    Note:\n        You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n        *after* the class is fully initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; TupleGenerator\n</code></pre> <p>So <code>dict(model)</code> works.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __iter__(self) -&gt; TupleGenerator:\n    \"\"\"So `dict(model)` works.\"\"\"\n    yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n    extra = self.__pydantic_extra__\n    if extra:\n        yield from extra.items()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"<pre><code>__pydantic_init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>This is intended to behave just like <code>__init_subclass__</code>, but is called by <code>ModelMetaclass</code> only after basic class initialization is complete. In particular, attributes like <code>model_fields</code> will be present when this is called, but forward annotations are not guaranteed to be resolved yet, meaning that creating an instance of the class may fail.</p> <p>This is necessary because <code>__init_subclass__</code> will always be called by <code>type.__new__</code>, and it would require a prohibitively large refactor to the <code>ModelMetaclass</code> to ensure that <code>type.__new__</code> was called in such a manner that the class would already be sufficiently initialized.</p> <p>This will receive the same <code>kwargs</code> that would be passed to the standard <code>__init_subclass__</code>, namely, any kwargs passed to the class definition that aren't used internally by Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Any keyword arguments passed to the class definition that aren't used internally by Pydantic.</p> <code>{}</code> Note <p>You may want to override <code>__pydantic_on_complete__()</code> instead, which is called once the class and its fields are fully initialized and ready for validation.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n    only after basic class initialization is complete. In particular, attributes like `model_fields` will\n    be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n    meaning that creating an instance of the class may fail.\n\n    This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n    and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n    `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n    This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n    any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n    Args:\n        **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n            by Pydantic.\n\n    Note:\n        You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n        instead, which is called once the class and its fields are fully initialized and ready for validation.\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_init_subclass__(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__pydantic_on_complete__","title":"__pydantic_on_complete__  <code>classmethod</code>","text":"<pre><code>__pydantic_on_complete__() -&gt; None\n</code></pre> <p>This is called once the class and its fields are fully initialized and ready to be used.</p> <p>This typically happens when the class is created (just before <code>__pydantic_init_subclass__()</code> is called on the superclass), except when forward annotations are used that could not immediately be resolved. In that case, it will be called later, when the model is rebuilt automatically or explicitly using <code>model_rebuild()</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef __pydantic_on_complete__(cls) -&gt; None:\n    \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n    This typically happens when the class is created (just before\n    [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n    except when forward annotations are used that could not immediately be resolved.\n    In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n    [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n    \"\"\"\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__replace__","title":"__replace__","text":"<pre><code>__replace__(**changes: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __replace__(self, **changes: Any) -&gt; Self:\n    return self.model_copy(update=changes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__repr_args__","title":"__repr_args__","text":"<pre><code>__repr_args__() -&gt; _repr.ReprArgs\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __repr_args__(self) -&gt; _repr.ReprArgs:\n    # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n    # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n    # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n    computed_fields_repr_args = [\n        (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n    ]\n\n    for k, v in self.__dict__.items():\n        field = self.__pydantic_fields__.get(k)\n        if field and field.repr:\n            if v is not self:\n                yield k, v\n            else:\n                yield k, self.__repr_recursion__(v)\n    # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n    # This can happen if a `ValidationError` is raised during initialization and the instance's\n    # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n    # with a fallback, even though the type hints indicate the attribute will always be present.\n    try:\n        pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n    except AttributeError:\n        pydantic_extra = None\n\n    if pydantic_extra is not None:\n        yield from ((k, v) for k, v in pydantic_extra.items())\n    yield from computed_fields_repr_args\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n        setattr_handler(self, name, value)\n    # if None is returned from _setattr_handler, the attribute was set directly\n    elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n        setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n        self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__setstate__","title":"__setstate__","text":"<pre><code>__setstate__(state: dict[Any, Any]) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n    _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n    _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n    _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n    _object_setattr(self, '__dict__', state.get('__dict__', {}))\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__repr_str__(' ')\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.compute","title":"compute","text":"<pre><code>compute(sample: SampleLike) -&gt; MeasureValue\n</code></pre> <p>compute the measure</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def compute(self, sample: SampleLike) -&gt; MeasureValue:\n    tensor = sample.members[self.member_id]\n    return tensor.var(dim=self.axes)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.construct","title":"construct  <code>classmethod</code>","text":"<pre><code>construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\ndef construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `construct` method is deprecated; use `model_construct` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_construct(_fields_set=_fields_set, **values)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.copy","title":"copy","text":"<pre><code>copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to include in the copied model.</p> <code>None</code> <code>AbstractSetIntStr | MappingIntStrAny | None</code> <p>Optional set or mapping specifying which fields to exclude in the copied model.</p> <code>None</code> <code>Dict[str, Any] | None</code> <p>Optional dictionary of field-value pairs to override field values in the copied model.</p> <code>None</code> <code>bool</code> <p>If True, the values of fields that are Pydantic models will be deep-copied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the model with included, excluded and updated fields as specified.</p> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `copy` method is deprecated; use `model_copy` instead. '\n    'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n    category=None,\n)\ndef copy(\n    self,\n    *,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    update: Dict[str, Any] | None = None,  # noqa UP006\n    deep: bool = False,\n) -&gt; Self:  # pragma: no cover\n    \"\"\"Returns a copy of the model.\n\n    !!! warning \"Deprecated\"\n        This method is now deprecated; use `model_copy` instead.\n\n    If you need `include` or `exclude`, use:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n    data = {**data, **(update or {})}\n    copied = self.model_validate(data)\n    ```\n\n    Args:\n        include: Optional set or mapping specifying which fields to include in the copied model.\n        exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n        update: Optional dictionary of field-value pairs to override field values in the copied model.\n        deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n    Returns:\n        A copy of the model with included, excluded and updated fields as specified.\n    \"\"\"\n    warnings.warn(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import copy_internals\n\n    values = dict(\n        copy_internals._iter(\n            self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n        ),\n        **(update or {}),\n    )\n    if self.__pydantic_private__ is None:\n        private = None\n    else:\n        private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n    if self.__pydantic_extra__ is None:\n        extra: dict[str, Any] | None = None\n    else:\n        extra = self.__pydantic_extra__.copy()\n        for k in list(self.__pydantic_extra__):\n            if k not in values:  # k was in the exclude\n                extra.pop(k)\n        for k in list(values):\n            if k in self.__pydantic_extra__:  # k must have come from extra\n                extra[k] = values.pop(k)\n\n    # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n    if update:\n        fields_set = self.__pydantic_fields_set__ | update.keys()\n    else:\n        fields_set = set(self.__pydantic_fields_set__)\n\n    # removing excluded fields from `__pydantic_fields_set__`\n    if exclude:\n        fields_set -= set(exclude)\n\n    return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.copy(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.copy(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.dict","title":"dict","text":"<pre><code>dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\ndef dict(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `dict` method is deprecated; use `model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.from_orm","title":"from_orm  <code>classmethod</code>","text":"<pre><code>from_orm(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `from_orm` method is deprecated; set '\n    \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n    category=None,\n)\ndef from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if not cls.model_config.get('from_attributes', None):\n        raise PydanticUserError(\n            'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n        )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.json","title":"json","text":"<pre><code>json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\ndef json(  # noqa: D102\n    self,\n    *,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n    models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n    **dumps_kwargs: Any,\n) -&gt; str:\n    warnings.warn(\n        'The `json` method is deprecated; use `model_dump_json` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if encoder is not PydanticUndefined:\n        raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n    if models_as_dict is not PydanticUndefined:\n        raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n    if dumps_kwargs:\n        raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n    return self.model_dump_json(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_construct(_fields_set)","title":"<code>_fields_set</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_construct(values)","title":"<code>values</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's [<code>__dict__</code>][object.__dict__] attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of [cached properties][functools.cached_property]).</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>New model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_copy(update)","title":"<code>update</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_copy(deep)","title":"<code>deep</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the model.</p> Source code in <code>pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(indent)","title":"<code>indent</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(ensure_ascii)","title":"<code>ensure_ascii</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(include)","title":"<code>include</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(exclude)","title":"<code>exclude</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(exclude_unset)","title":"<code>exclude_unset</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(exclude_defaults)","title":"<code>exclude_defaults</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(exclude_none)","title":"<code>exclude_none</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(exclude_computed_fields)","title":"<code>exclude_computed_fields</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(round_trip)","title":"<code>round_trip</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(warnings)","title":"<code>warnings</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(fallback)","title":"<code>fallback</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_dump_json(serialize_as_any)","title":"<code>serialize_as_any</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_json_schema(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_json_schema(ref_template)","title":"<code>ref_template</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_json_schema(union_format)","title":"<code>union_format</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_json_schema(schema_generator)","title":"<code>schema_generator</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_json_schema(mode)","title":"<code>mode</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_parametrized_name(params)","title":"<code>params</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any)\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def model_post_init(self, __context: Any):\n    assert self.axes is None or AxisId(\"batch\") not in self.axes\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_rebuild(force)","title":"<code>force</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_rebuild(raise_errors)","title":"<code>raise_errors</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_rebuild(_parent_namespace_depth)","title":"<code>_parent_namespace_depth</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_rebuild(_types_namespace)","title":"<code>_types_namespace</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the object could not be validated.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate(from_attributes)","title":"<code>from_attributes</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_json(json_data)","title":"<code>json_data</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_json(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_json(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_json(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_json(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_json(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object containing string data to validate.</p> required <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the [<code>extra</code> configuration value][pydantic.ConfigDict.extra] for details.</p> <code>None</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Pydantic model.</p> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_strings(strict)","title":"<code>strict</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_strings(extra)","title":"<code>extra</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_strings(context)","title":"<code>context</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_strings(by_alias)","title":"<code>by_alias</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.model_validate_strings(by_name)","title":"<code>by_name</code>","text":""},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.parse_file","title":"parse_file  <code>classmethod</code>","text":"<pre><code>parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n    'use `model_validate_json`, otherwise `model_validate` instead.',\n    category=None,\n)\ndef parse_file(  # noqa: D102\n    cls,\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:\n    warnings.warn(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    obj = parse.load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n    )\n    return cls.parse_obj(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.parse_obj","title":"parse_obj  <code>classmethod</code>","text":"<pre><code>parse_obj(obj: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\ndef parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `parse_obj` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.parse_raw","title":"parse_raw  <code>classmethod</code>","text":"<pre><code>parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n    'otherwise load the data then use `model_validate` instead.',\n    category=None,\n)\ndef parse_raw(  # noqa: D102\n    cls,\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: DeprecatedParseProtocol | None = None,\n    allow_pickle: bool = False,\n) -&gt; Self:  # pragma: no cover\n    warnings.warn(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from .deprecated import parse\n\n    try:\n        obj = parse.load_str_bytes(\n            b,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n    except (ValueError, TypeError) as exc:\n        import json\n\n        # try to match V1\n        if isinstance(exc, UnicodeDecodeError):\n            type_str = 'value_error.unicodedecode'\n        elif isinstance(exc, json.JSONDecodeError):\n            type_str = 'value_error.jsondecode'\n        elif isinstance(exc, ValueError):\n            type_str = 'value_error'\n        else:\n            type_str = 'type_error'\n\n        # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n        error: pydantic_core.InitErrorDetails = {\n            # The type: ignore on the next line is to ignore the requirement of LiteralString\n            'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n            'loc': ('__root__',),\n            'input': b,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n    return cls.model_validate(obj)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\ndef schema(  # noqa: D102\n    cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n) -&gt; Dict[str, Any]:  # noqa UP006\n    warnings.warn(\n        'The `schema` method is deprecated; use `model_json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.schema_json","title":"schema_json  <code>classmethod</code>","text":"<pre><code>schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -&gt; str\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n    category=None,\n)\ndef schema_json(  # noqa: D102\n    cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n) -&gt; str:  # pragma: no cover\n    warnings.warn(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    import json\n\n    from .deprecated.json import pydantic_encoder\n\n    return json.dumps(\n        cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n        default=pydantic_encoder,\n        **dumps_kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.update_forward_refs","title":"update_forward_refs  <code>classmethod</code>","text":"<pre><code>update_forward_refs(**localns: Any) -&gt; None\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated(\n    'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n    category=None,\n)\ndef update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n    warnings.warn(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if localns:  # pragma: no cover\n        raise TypeError('`localns` arguments are not longer accepted.')\n    cls.model_rebuild(force=True)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.SampleVar.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(value: Any) -&gt; Self\n</code></pre> Source code in <code>pydantic/main.py</code> <pre><code>@classmethod\n@typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\ndef validate(cls, value: Any) -&gt; Self:  # noqa: D102\n    warnings.warn(\n        'The `validate` method is deprecated; use `model_validate` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return cls.model_validate(value)\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.tensor_custom_before_validator","title":"tensor_custom_before_validator","text":"<pre><code>tensor_custom_before_validator(data: Union[Tensor, Mapping[str, Any]])\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <code></code>\u00a0MeasureValue </li> </ul> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def tensor_custom_before_validator(data: Union[Tensor, Mapping[str, Any]]):\n    if isinstance(data, Tensor):\n        return data\n\n    # custom before validation logic\n    return Tensor(np.asarray(data[\"data\"]), dims=data[\"dims\"])\n</code></pre>"},{"location":"api/bioimageio/core/stat_measures/#bioimageio.core.stat_measures.tensor_custom_serializer","title":"tensor_custom_serializer","text":"<pre><code>tensor_custom_serializer(t: Tensor) -&gt; Dict[str, Any]\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0stat_measures <code></code>\u00a0MeasureValue </li> </ul> Source code in <code>src/bioimageio/core/stat_measures.py</code> <pre><code>def tensor_custom_serializer(t: Tensor) -&gt; Dict[str, Any]:\n    # custome serialization logic\n    return {\"data\": t.data.data.tolist(), \"dims\": list(map(str, t.dims))}\n</code></pre>"},{"location":"api/bioimageio/core/tensor/","title":"bioimageio.core.tensor","text":""},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor","title":"tensor","text":"Used by: <ul> <li> API Reference \u00a0core \u00a0Tensor </li> </ul> <p>Classes:</p> Name Description <code>Tensor</code> <p>A wrapper around an xr.DataArray for better integration with bioimageio.spec</p>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor","title":"Tensor","text":"<pre><code>Tensor(array: NDArray[Any], dims: Sequence[Union[AxisId, AxisLike]])\n</code></pre> <p>               Bases: <code>MagicTensorOpsMixin</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.tensor.Tensor[Tensor]\n              bioimageio.core._magic_tensor_ops.MagicTensorOpsMixin[MagicTensorOpsMixin]\n\n                              bioimageio.core._magic_tensor_ops.MagicTensorOpsMixin --&gt; bioimageio.core.tensor.Tensor\n                \n\n\n              click bioimageio.core.tensor.Tensor href \"\" \"bioimageio.core.tensor.Tensor\"\n              click bioimageio.core._magic_tensor_ops.MagicTensorOpsMixin href \"\" \"bioimageio.core._magic_tensor_ops.MagicTensorOpsMixin\"\n            </code></pre> <p>A wrapper around an xr.DataArray for better integration with bioimageio.spec and improved type annotations.</p> Returned by: <ul> <li> API Reference <code></code>\u00a0io <code></code>\u00a0load_tensor </li> </ul> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0block <ul> <li> <code></code>\u00a0Block </li> <li> <code></code>\u00a0split_tensor_into_blocks </li> </ul> </li> <li> <code></code>\u00a0core <ul> <li> <code></code>\u00a0Tensor </li> <li> <code></code>\u00a0create_prediction_pipeline </li> </ul> </li> <li> <code></code>\u00a0digest_spec <code></code>\u00a0TensorSource </li> <li> <code></code>\u00a0io <code></code>\u00a0save_tensor </li> <li> <code></code>\u00a0sample <code></code>\u00a0Sample </li> <li> <code></code>\u00a0stat_measures <ul> <li> <code></code>\u00a0MeasureValue </li> <li> <code></code>\u00a0tensor_custom_before_validator </li> <li> <code></code>\u00a0tensor_custom_serializer </li> </ul> </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__abs__</code> <code>__add__</code> <code>__and__</code> <code>__array__</code> <code>__eq__</code> <code>__floordiv__</code> <code>__ge__</code> <code>__getitem__</code> <code>__gt__</code> <code>__iadd__</code> <code>__iand__</code> <code>__ifloordiv__</code> <code>__ilshift__</code> <code>__imod__</code> <code>__imul__</code> <code>__invert__</code> <code>__ior__</code> <code>__ipow__</code> <code>__irshift__</code> <code>__isub__</code> <code>__iter__</code> <code>__itruediv__</code> <code>__ixor__</code> <code>__le__</code> <code>__len__</code> <code>__lshift__</code> <code>__lt__</code> <code>__mod__</code> <code>__mul__</code> <code>__ne__</code> <code>__neg__</code> <code>__or__</code> <code>__pos__</code> <code>__pow__</code> <code>__radd__</code> <code>__rand__</code> <code>__rfloordiv__</code> <code>__rmod__</code> <code>__rmul__</code> <code>__ror__</code> <code>__rpow__</code> <code>__rshift__</code> <code>__rsub__</code> <code>__rtruediv__</code> <code>__rxor__</code> <code>__setitem__</code> <code>__sub__</code> <code>__truediv__</code> <code>__xor__</code> <code>argmax</code> <code>argsort</code> <code>astype</code> <p>Return tensor cast to <code>dtype</code></p> <code>clip</code> <p>Return a tensor whose values are limited to [min, max].</p> <code>conj</code> <code>conjugate</code> <code>crop_to</code> <p>crop to match <code>sizes</code></p> <code>expand_dims</code> <code>from_numpy</code> <p>create a <code>Tensor</code> from a numpy array</p> <code>from_xarray</code> <p>create a <code>Tensor</code> from an xarray data array</p> <code>item</code> <p>Copy a tensor element to a standard Python scalar and return it.</p> <code>mean</code> <code>pad</code> <code>pad_to</code> <p>pad <code>tensor</code> to match <code>sizes</code></p> <code>quantile</code> <code>resize_to</code> <p>return cropped/padded tensor with <code>sizes</code></p> <code>round</code> <code>std</code> <code>sum</code> <p>Reduce this Tensor's data by applying sum along some dimension(s).</p> <code>transpose</code> <p>return a transposed tensor</p> <code>var</code> <p>Attributes:</p> Name Type Description <code>__hash__</code> <code>None</code> <code>__slots__</code> <code>data</code> <code>dims</code> <p>Tuple of dimension names associated with this tensor.</p> <code>dtype</code> <code>DTypeStr</code> <code>ndim</code> <p>Number of tensor dimensions.</p> <code>shape</code> <p>Tuple of tensor axes lengths</p> <code>shape_tuple</code> <p>Tuple of tensor axes lengths</p> <code>size</code> <p>Number of elements in the tensor.</p> <code>sizes</code> <p>Ordered, immutable mapping from axis ids to axis lengths.</p> <code>tagged_shape</code> <p>(alias for <code>sizes</code>) Ordered, immutable mapping from axis ids to lengths.</p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def __init__(\n    self,\n    array: NDArray[Any],\n    dims: Sequence[Union[AxisId, AxisLike]],\n) -&gt; None:\n    super().__init__()\n    axes = tuple(\n        a if isinstance(a, AxisId) else AxisInfo.create(a).id for a in dims\n    )\n    self._data = xr.DataArray(array, dims=axes)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__hash__","title":"__hash__  <code>instance-attribute</code>","text":"<pre><code>__hash__: None\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__slots__","title":"__slots__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__slots__ = ()\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.data","title":"data  <code>property</code>","text":"<pre><code>data\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.dims","title":"dims  <code>property</code>","text":"<pre><code>dims\n</code></pre> <p>Tuple of dimension names associated with this tensor.</p>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: DTypeStr\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.ndim","title":"ndim  <code>property</code>","text":"<pre><code>ndim\n</code></pre> <p>Number of tensor dimensions.</p>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.shape","title":"shape  <code>property</code>","text":"<pre><code>shape\n</code></pre> <p>Tuple of tensor axes lengths</p>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.shape_tuple","title":"shape_tuple  <code>property</code>","text":"<pre><code>shape_tuple\n</code></pre> <p>Tuple of tensor axes lengths</p>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre> <p>Number of elements in the tensor.</p> <p>Equal to math.prod(tensor.shape), i.e., the product of the tensors\u2019 dimensions.</p>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.sizes","title":"sizes  <code>property</code>","text":"<pre><code>sizes\n</code></pre> <p>Ordered, immutable mapping from axis ids to axis lengths.</p>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.tagged_shape","title":"tagged_shape  <code>property</code>","text":"<pre><code>tagged_shape\n</code></pre> <p>(alias for <code>sizes</code>) Ordered, immutable mapping from axis ids to lengths.</p>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    return self._unary_op(operator.abs)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__add__","title":"__add__","text":"<pre><code>__add__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __add__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.add)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__and__","title":"__and__","text":"<pre><code>__and__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __and__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.and_)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__array__","title":"__array__","text":"<pre><code>__array__(dtype: DTypeLike = None)\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def __array__(self, dtype: DTypeLike = None):\n    return np.asarray(self._data, dtype=dtype)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __eq__(self, other: _Compatible) -&gt; Self:  # type: ignore[override]\n    return self._binary_op(\n        other,\n        nputils.array_eq,  # pyright: ignore[reportUnknownArgumentType]\n    )\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __floordiv__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.floordiv)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __ge__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.ge)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: Union[SliceInfo, slice, int, PerAxis[Union[SliceInfo, slice, int]], Tensor, xr.DataArray]) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def __getitem__(\n    self,\n    key: Union[\n        SliceInfo,\n        slice,\n        int,\n        PerAxis[Union[SliceInfo, slice, int]],\n        Tensor,\n        xr.DataArray,\n    ],\n) -&gt; Self:\n    if isinstance(key, SliceInfo):\n        key = slice(*key)\n    elif isinstance(key, collections.abc.Mapping):\n        key = {\n            a: s if isinstance(s, int) else s if isinstance(s, slice) else slice(*s)\n            for a, s in key.items()\n        }\n    elif isinstance(key, Tensor):\n        key = key._data\n\n    return self.__class__.from_xarray(self._data[key])\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __gt__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.gt)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __iadd__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.iadd)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__iand__","title":"__iand__","text":"<pre><code>__iand__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __iand__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.iand)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__ifloordiv__","title":"__ifloordiv__","text":"<pre><code>__ifloordiv__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __ifloordiv__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.ifloordiv)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__ilshift__","title":"__ilshift__","text":"<pre><code>__ilshift__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __ilshift__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.ilshift)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__imod__","title":"__imod__","text":"<pre><code>__imod__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __imod__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.imod)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__imul__","title":"__imul__","text":"<pre><code>__imul__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __imul__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.imul)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__invert__","title":"__invert__","text":"<pre><code>__invert__() -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __invert__(self) -&gt; Self:\n    return self._unary_op(operator.invert)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__ior__","title":"__ior__","text":"<pre><code>__ior__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __ior__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.ior)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__ipow__","title":"__ipow__","text":"<pre><code>__ipow__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __ipow__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.ipow)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__irshift__","title":"__irshift__","text":"<pre><code>__irshift__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __irshift__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.irshift)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__isub__","title":"__isub__","text":"<pre><code>__isub__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __isub__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.isub)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Any]\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def __iter__(self: Any) -&gt; Iterator[Any]:\n    if self.ndim == 0:\n        raise TypeError(\"iteration over a 0-d array\")\n    return self._iter()\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__itruediv__","title":"__itruediv__","text":"<pre><code>__itruediv__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __itruediv__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.itruediv)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__ixor__","title":"__ixor__","text":"<pre><code>__ixor__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __ixor__(self, other: _Compatible) -&gt; Self:\n    return self._inplace_binary_op(other, operator.ixor)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__le__","title":"__le__","text":"<pre><code>__le__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __le__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.le)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.data)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__lshift__","title":"__lshift__","text":"<pre><code>__lshift__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __lshift__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.lshift)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __lt__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.lt)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __mod__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.mod)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __mul__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.mul)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __ne__(self, other: _Compatible) -&gt; Self:  # type: ignore[override]\n    return self._binary_op(\n        other,\n        nputils.array_ne,  # pyright: ignore[reportUnknownArgumentType]\n    )\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    return self._unary_op(operator.neg)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__or__","title":"__or__","text":"<pre><code>__or__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __or__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.or_)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __pos__(self) -&gt; Self:\n    return self._unary_op(operator.pos)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __pow__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.pow)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __radd__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.add, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__rand__","title":"__rand__","text":"<pre><code>__rand__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __rand__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.and_, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __rfloordiv__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.floordiv, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __rmod__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.mod, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __rmul__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.mul, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__ror__","title":"__ror__","text":"<pre><code>__ror__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __ror__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.or_, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __rpow__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.pow, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __rshift__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.rshift)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __rsub__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.sub, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __rtruediv__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.truediv, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__rxor__","title":"__rxor__","text":"<pre><code>__rxor__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __rxor__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.xor, reflexive=True)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key: Union[PerAxis[Union[SliceInfo, slice]], Tensor, xr.DataArray], value: Union[Tensor, xr.DataArray, float, int]) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def __setitem__(\n    self,\n    key: Union[PerAxis[Union[SliceInfo, slice]], Tensor, xr.DataArray],\n    value: Union[Tensor, xr.DataArray, float, int],\n) -&gt; None:\n    if isinstance(key, Tensor):\n        key = key._data\n    elif isinstance(key, xr.DataArray):\n        pass\n    else:\n        key = {a: s if isinstance(s, slice) else slice(*s) for a, s in key.items()}\n\n    if isinstance(value, Tensor):\n        value = value._data\n\n    self._data[key] = value\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __sub__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.sub)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __truediv__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.truediv)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.__xor__","title":"__xor__","text":"<pre><code>__xor__(other: _Compatible) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def __xor__(self, other: _Compatible) -&gt; Self:\n    return self._binary_op(other, operator.xor)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.argmax","title":"argmax","text":"<pre><code>argmax() -&gt; Mapping[AxisId, int]\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def argmax(self) -&gt; Mapping[AxisId, int]:\n    ret = self._data.argmax(...)\n    assert isinstance(ret, dict)\n    return {cast(AxisId, k): cast(int, v.item()) for k, v in ret.items()}\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.argsort","title":"argsort","text":"<pre><code>argsort(*args: Any, **kwargs: Any) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def argsort(self, *args: Any, **kwargs: Any) -&gt; Self:\n    return self._unary_op(\n        ops.argsort,  # pyright: ignore[reportUnknownArgumentType]\n        *args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.astype","title":"astype","text":"<pre><code>astype(dtype: DTypeStr, *, copy: bool = False)\n</code></pre> <p>Return tensor cast to <code>dtype</code></p> <p>note: if dtype is already satisfied copy if <code>copy</code></p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def astype(self, dtype: DTypeStr, *, copy: bool = False):\n    \"\"\"Return tensor cast to `dtype`\n\n    note: if dtype is already satisfied copy if `copy`\"\"\"\n    return self.__class__.from_xarray(self._data.astype(dtype, copy=copy))\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.clip","title":"clip","text":"<pre><code>clip(min: Optional[float] = None, max: Optional[float] = None)\n</code></pre> <p>Return a tensor whose values are limited to [min, max]. At least one of max or min must be given.</p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def clip(self, min: Optional[float] = None, max: Optional[float] = None):\n    \"\"\"Return a tensor whose values are limited to [min, max].\n    At least one of max or min must be given.\"\"\"\n    return self.__class__.from_xarray(self._data.clip(min, max))\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.conj","title":"conj","text":"<pre><code>conj(*args: Any, **kwargs: Any) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def conj(self, *args: Any, **kwargs: Any) -&gt; Self:\n    return self._unary_op(\n        ops.conj,  # pyright: ignore[reportUnknownArgumentType]\n        *args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.conjugate","title":"conjugate","text":"<pre><code>conjugate(*args: Any, **kwargs: Any) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def conjugate(self, *args: Any, **kwargs: Any) -&gt; Self:\n    return self._unary_op(\n        ops.conjugate,  # pyright: ignore[reportUnknownArgumentType]\n        *args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.crop_to","title":"crop_to","text":"<pre><code>crop_to(sizes: PerAxis[int], crop_where: Union[CropWhere, PerAxis[CropWhere]] = 'left_and_right') -&gt; Self\n</code></pre> <p>crop to match <code>sizes</code></p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def crop_to(\n    self,\n    sizes: PerAxis[int],\n    crop_where: Union[\n        CropWhere,\n        PerAxis[CropWhere],\n    ] = \"left_and_right\",\n) -&gt; Self:\n    \"\"\"crop to match `sizes`\"\"\"\n    if isinstance(crop_where, str):\n        crop_axis_where: PerAxis[CropWhere] = {a: crop_where for a in self.dims}\n    else:\n        crop_axis_where = crop_where\n\n    slices: Dict[AxisId, SliceInfo] = {}\n\n    for a, s_is in self.sizes.items():\n        if a not in sizes or sizes[a] == s_is:\n            pass\n        elif sizes[a] &gt; s_is:\n            logger.warning(\n                \"Cannot crop axis {} of size {} to larger size {}\",\n                a,\n                s_is,\n                sizes[a],\n            )\n        elif a not in crop_axis_where:\n            raise ValueError(\n                f\"Don't know where to crop axis {a}, `crop_where`={crop_where}\"\n            )\n        else:\n            crop_this_axis_where = crop_axis_where[a]\n            if crop_this_axis_where == \"left\":\n                slices[a] = SliceInfo(s_is - sizes[a], s_is)\n            elif crop_this_axis_where == \"right\":\n                slices[a] = SliceInfo(0, sizes[a])\n            elif crop_this_axis_where == \"left_and_right\":\n                slices[a] = SliceInfo(\n                    start := (s_is - sizes[a]) // 2, sizes[a] + start\n                )\n            else:\n                assert_never(crop_this_axis_where)\n\n    return self[slices]\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.expand_dims","title":"expand_dims","text":"<pre><code>expand_dims(dims: Union[Sequence[AxisId], PerAxis[int]]) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def expand_dims(self, dims: Union[Sequence[AxisId], PerAxis[int]]) -&gt; Self:\n    return self.__class__.from_xarray(self._data.expand_dims(dims=dims))\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.from_numpy","title":"from_numpy  <code>classmethod</code>","text":"<pre><code>from_numpy(array: NDArray[Any], *, dims: Optional[Union[AxisLike, Sequence[AxisLike]]]) -&gt; Tensor\n</code></pre> <p>create a <code>Tensor</code> from a numpy array</p> <p>Parameters:</p> Name Type Description Default <code>NDArray[Any]</code> <p>the nd numpy array</p> required <code>Optional[Union[AxisLike, Sequence[AxisLike]]]</code> <p>A description of the array's axes, if None axes are guessed (which might fail and raise a ValueError.)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>dims</code> is None and dims guessing fails.</p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    array: NDArray[Any],\n    *,\n    dims: Optional[Union[AxisLike, Sequence[AxisLike]]],\n) -&gt; Tensor:\n    \"\"\"create a `Tensor` from a numpy array\n\n    Args:\n        array: the nd numpy array\n        dims: A description of the array's axes,\n            if None axes are guessed (which might fail and raise a ValueError.)\n\n    Raises:\n        ValueError: if `dims` is None and dims guessing fails.\n    \"\"\"\n\n    if dims is None:\n        return cls._interprete_array_wo_known_axes(array)\n    elif isinstance(dims, collections.abc.Sequence):\n        dim_seq = list(dims)\n    else:\n        dim_seq = [dims]\n\n    axis_infos = [AxisInfo.create(a) for a in dim_seq]\n    original_shape = tuple(array.shape)\n\n    successful_view = _get_array_view(array, axis_infos)\n    if successful_view is None:\n        raise ValueError(\n            f\"Array shape {original_shape} does not map to axes {dims}\"\n        )\n\n    return Tensor(successful_view, dims=tuple(a.id for a in axis_infos))\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.from_numpy(array)","title":"<code>array</code>","text":""},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.from_numpy(dims)","title":"<code>dims</code>","text":""},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.from_xarray","title":"from_xarray  <code>classmethod</code>","text":"<pre><code>from_xarray(data_array: xr.DataArray) -&gt; Self\n</code></pre> <p>create a <code>Tensor</code> from an xarray data array</p> this factory method is round-trip save <p>for any <code>Tensor</code>'s  <code>data</code> property (an xarray.DataArray).</p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>@classmethod\ndef from_xarray(cls, data_array: xr.DataArray) -&gt; Self:\n    \"\"\"create a `Tensor` from an xarray data array\n\n    note for internal use: this factory method is round-trip save\n        for any `Tensor`'s  `data` property (an xarray.DataArray).\n    \"\"\"\n    return cls(\n        array=data_array.data, dims=tuple(AxisId(d) for d in data_array.dims)\n    )\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.item","title":"item","text":"<pre><code>item(key: Union[None, SliceInfo, slice, int, PerAxis[Union[SliceInfo, slice, int]]] = None)\n</code></pre> <p>Copy a tensor element to a standard Python scalar and return it.</p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def item(\n    self,\n    key: Union[\n        None, SliceInfo, slice, int, PerAxis[Union[SliceInfo, slice, int]]\n    ] = None,\n):\n    \"\"\"Copy a tensor element to a standard Python scalar and return it.\"\"\"\n    if key is None:\n        ret = self._data.item()\n    else:\n        ret = self[key]._data.item()\n\n    assert isinstance(ret, (bool, float, int))\n    return ret\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.mean","title":"mean","text":"<pre><code>mean(dim: Optional[Union[AxisId, Sequence[AxisId]]] = None) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def mean(self, dim: Optional[Union[AxisId, Sequence[AxisId]]] = None) -&gt; Self:\n    return self.__class__.from_xarray(self._data.mean(dim=dim))\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.pad","title":"pad","text":"<pre><code>pad(pad_width: PerAxis[PadWidthLike], mode: PadMode = 'symmetric') -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def pad(\n    self,\n    pad_width: PerAxis[PadWidthLike],\n    mode: PadMode = \"symmetric\",\n) -&gt; Self:\n    pad_width = {a: PadWidth.create(p) for a, p in pad_width.items()}\n    return self.__class__.from_xarray(\n        self._data.pad(pad_width=pad_width, mode=mode)\n    )\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.pad_to","title":"pad_to","text":"<pre><code>pad_to(sizes: PerAxis[int], pad_where: Union[PadWhere, PerAxis[PadWhere]] = 'left_and_right', mode: PadMode = 'symmetric') -&gt; Self\n</code></pre> <p>pad <code>tensor</code> to match <code>sizes</code></p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def pad_to(\n    self,\n    sizes: PerAxis[int],\n    pad_where: Union[PadWhere, PerAxis[PadWhere]] = \"left_and_right\",\n    mode: PadMode = \"symmetric\",\n) -&gt; Self:\n    \"\"\"pad `tensor` to match `sizes`\"\"\"\n    if isinstance(pad_where, str):\n        pad_axis_where: PerAxis[PadWhere] = {a: pad_where for a in self.dims}\n    else:\n        pad_axis_where = pad_where\n\n    pad_width: Dict[AxisId, PadWidth] = {}\n    for a, s_is in self.sizes.items():\n        if a not in sizes or sizes[a] == s_is:\n            pad_width[a] = PadWidth(0, 0)\n        elif s_is &gt; sizes[a]:\n            pad_width[a] = PadWidth(0, 0)\n            logger.warning(\n                \"Cannot pad axis {} of size {} to smaller size {}\",\n                a,\n                s_is,\n                sizes[a],\n            )\n        elif a not in pad_axis_where:\n            raise ValueError(\n                f\"Don't know where to pad axis {a}, `pad_where`={pad_where}\"\n            )\n        else:\n            pad_this_axis_where = pad_axis_where[a]\n            d = sizes[a] - s_is\n            if pad_this_axis_where == \"left\":\n                pad_width[a] = PadWidth(d, 0)\n            elif pad_this_axis_where == \"right\":\n                pad_width[a] = PadWidth(0, d)\n            elif pad_this_axis_where == \"left_and_right\":\n                pad_width[a] = PadWidth(left := d // 2, d - left)\n            else:\n                assert_never(pad_this_axis_where)\n\n    return self.pad(pad_width, mode)\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.quantile","title":"quantile","text":"<pre><code>quantile(q: Union[float, Sequence[float]], dim: Optional[Union[AxisId, Sequence[AxisId]]] = None, method: QuantileMethod = 'linear') -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def quantile(\n    self,\n    q: Union[float, Sequence[float]],\n    dim: Optional[Union[AxisId, Sequence[AxisId]]] = None,\n    method: QuantileMethod = \"linear\",\n) -&gt; Self:\n    assert (\n        isinstance(q, (float, int))\n        and q &gt;= 0.0\n        or not isinstance(q, (float, int))\n        and all(qq &gt;= 0.0 for qq in q)\n    )\n    assert (\n        isinstance(q, (float, int))\n        and q &lt;= 1.0\n        or not isinstance(q, (float, int))\n        and all(qq &lt;= 1.0 for qq in q)\n    )\n    assert dim is None or (\n        (quantile_dim := AxisId(\"quantile\")) != dim and quantile_dim not in set(dim)\n    )\n    return self.__class__.from_xarray(\n        self._data.quantile(q, dim=dim, method=method)\n    )\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.resize_to","title":"resize_to","text":"<pre><code>resize_to(sizes: PerAxis[int], *, pad_where: Union[PadWhere, PerAxis[PadWhere]] = 'left_and_right', crop_where: Union[CropWhere, PerAxis[CropWhere]] = 'left_and_right', pad_mode: PadMode = 'symmetric')\n</code></pre> <p>return cropped/padded tensor with <code>sizes</code></p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def resize_to(\n    self,\n    sizes: PerAxis[int],\n    *,\n    pad_where: Union[\n        PadWhere,\n        PerAxis[PadWhere],\n    ] = \"left_and_right\",\n    crop_where: Union[\n        CropWhere,\n        PerAxis[CropWhere],\n    ] = \"left_and_right\",\n    pad_mode: PadMode = \"symmetric\",\n):\n    \"\"\"return cropped/padded tensor with `sizes`\"\"\"\n    crop_to_sizes: Dict[AxisId, int] = {}\n    pad_to_sizes: Dict[AxisId, int] = {}\n    new_axes = dict(sizes)\n    for a, s_is in self.sizes.items():\n        a = AxisId(str(a))\n        _ = new_axes.pop(a, None)\n        if a not in sizes or sizes[a] == s_is:\n            pass\n        elif s_is &gt; sizes[a]:\n            crop_to_sizes[a] = sizes[a]\n        else:\n            pad_to_sizes[a] = sizes[a]\n\n    tensor = self\n    if crop_to_sizes:\n        tensor = tensor.crop_to(crop_to_sizes, crop_where=crop_where)\n\n    if pad_to_sizes:\n        tensor = tensor.pad_to(pad_to_sizes, pad_where=pad_where, mode=pad_mode)\n\n    if new_axes:\n        tensor = tensor.expand_dims(new_axes)\n\n    return tensor\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.round","title":"round","text":"<pre><code>round(*args: Any, **kwargs: Any) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/_magic_tensor_ops.py</code> <pre><code>def round(self, *args: Any, **kwargs: Any) -&gt; Self:\n    return self._unary_op(\n        ops.round_,  # pyright: ignore[reportUnknownArgumentType]\n        *args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.std","title":"std","text":"<pre><code>std(dim: Optional[Union[AxisId, Sequence[AxisId]]] = None) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def std(self, dim: Optional[Union[AxisId, Sequence[AxisId]]] = None) -&gt; Self:\n    return self.__class__.from_xarray(self._data.std(dim=dim))\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.sum","title":"sum","text":"<pre><code>sum(dim: Optional[Union[AxisId, Sequence[AxisId]]] = None) -&gt; Self\n</code></pre> <p>Reduce this Tensor's data by applying sum along some dimension(s).</p> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def sum(self, dim: Optional[Union[AxisId, Sequence[AxisId]]] = None) -&gt; Self:\n    \"\"\"Reduce this Tensor's data by applying sum along some dimension(s).\"\"\"\n    return self.__class__.from_xarray(self._data.sum(dim=dim))\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.transpose","title":"transpose","text":"<pre><code>transpose(axes: Sequence[AxisId]) -&gt; Self\n</code></pre> <p>return a transposed tensor</p> <p>Parameters:</p> Name Type Description Default <code>Sequence[AxisId]</code> <p>the desired tensor axes</p> required Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def transpose(\n    self,\n    axes: Sequence[AxisId],\n) -&gt; Self:\n    \"\"\"return a transposed tensor\n\n    Args:\n        axes: the desired tensor axes\n    \"\"\"\n    # expand missing tensor axes\n    missing_axes = tuple(a for a in axes if a not in self.dims)\n    array = self._data\n    if missing_axes:\n        array = array.expand_dims(missing_axes)\n\n    # transpose to the correct axis order\n    return self.__class__.from_xarray(array.transpose(*axes))\n</code></pre>"},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.transpose(axes)","title":"<code>axes</code>","text":""},{"location":"api/bioimageio/core/tensor/#bioimageio.core.tensor.Tensor.var","title":"var","text":"<pre><code>var(dim: Optional[Union[AxisId, Sequence[AxisId]]] = None) -&gt; Self\n</code></pre> Source code in <code>src/bioimageio/core/tensor.py</code> <pre><code>def var(self, dim: Optional[Union[AxisId, Sequence[AxisId]]] = None) -&gt; Self:\n    return self.__class__.from_xarray(self._data.var(dim=dim))\n</code></pre>"},{"location":"api/bioimageio/core/backends/","title":"bioimageio.core.backends","text":""},{"location":"api/bioimageio/core/backends/#bioimageio.core.backends","title":"backends","text":"Used by: <ul> <li> API Reference \u00a0core \u00a0create_model_adapter </li> </ul> <p>Modules:</p> Name Description <code>keras_backend</code> <code>onnx_backend</code> <code>pytorch_backend</code> <code>tensorflow_backend</code> <code>torchscript_backend</code> <p>Attributes:</p> Name Type Description <code>create_model_adapter</code>"},{"location":"api/bioimageio/core/backends/#bioimageio.core.backends.create_model_adapter","title":"create_model_adapter  <code>module-attribute</code>","text":"<pre><code>create_model_adapter = ModelAdapter.create\n</code></pre> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0create_model_adapter </li> </ul>"},{"location":"api/bioimageio/core/backends/keras_backend/","title":"Keras backend","text":""},{"location":"api/bioimageio/core/backends/keras_backend/#bioimageio.core.backends.keras_backend","title":"keras_backend","text":"<p>Classes:</p> Name Description <code>KerasModelAdapter</code> <p>Attributes:</p> Name Type Description <code>tf_version</code>"},{"location":"api/bioimageio/core/backends/keras_backend/#bioimageio.core.backends.keras_backend.tf_version","title":"tf_version  <code>module-attribute</code>","text":"<pre><code>tf_version = Version(tf.__version__)\n</code></pre>"},{"location":"api/bioimageio/core/backends/keras_backend/#bioimageio.core.backends.keras_backend.KerasModelAdapter","title":"KerasModelAdapter","text":"<pre><code>KerasModelAdapter(*, model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], devices: Optional[Sequence[str]] = None)\n</code></pre> <p>               Bases: <code>ModelAdapter</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.backends.keras_backend.KerasModelAdapter[KerasModelAdapter]\n              bioimageio.core.backends._model_adapter.ModelAdapter[ModelAdapter]\n\n                              bioimageio.core.backends._model_adapter.ModelAdapter --&gt; bioimageio.core.backends.keras_backend.KerasModelAdapter\n                \n\n\n              click bioimageio.core.backends.keras_backend.KerasModelAdapter href \"\" \"bioimageio.core.backends.keras_backend.KerasModelAdapter\"\n              click bioimageio.core.backends._model_adapter.ModelAdapter href \"\" \"bioimageio.core.backends._model_adapter.ModelAdapter\"\n            </code></pre> <p>Methods:</p> Name Description <code>create</code> <p>Creates model adapter based on the passed spec</p> <code>forward</code> <p>Run forward pass of model to get model predictions</p> <code>load</code> <code>unload</code> <p>Unload model from any devices, freeing their memory.</p> Source code in <code>src/bioimageio/core/backends/keras_backend.py</code> <pre><code>def __init__(\n    self,\n    *,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    devices: Optional[Sequence[str]] = None,\n) -&gt; None:\n    super().__init__(model_description=model_description)\n    if model_description.weights.keras_hdf5 is None:\n        raise ValueError(\"model has not keras_hdf5 weights specified\")\n    model_tf_version = model_description.weights.keras_hdf5.tensorflow_version\n\n    if tf_version is None or model_tf_version is None:\n        logger.warning(\"Could not check tensorflow versions.\")\n    elif model_tf_version &gt; tf_version:\n        logger.warning(\n            \"The model specifies a newer tensorflow version than installed: {} &gt; {}.\",\n            model_tf_version,\n            tf_version,\n        )\n    elif (model_tf_version.major, model_tf_version.minor) != (\n        tf_version.major,\n        tf_version.minor,\n    ):\n        logger.warning(\n            \"Model tensorflow version {} does not match {}.\",\n            model_tf_version,\n            tf_version,\n        )\n\n    # TODO keras device management\n    if devices is not None:\n        logger.warning(\n            \"Device management is not implemented for keras yet, ignoring the devices {}\",\n            devices,\n        )\n\n    weight_reader = model_description.weights.keras_hdf5.get_reader()\n    if weight_reader.suffix in (\".h5\", \"hdf5\"):\n        import h5py  # pyright: ignore[reportMissingTypeStubs]\n\n        h5_file = h5py.File(weight_reader, mode=\"r\")\n        self._network = legacy_h5_format.load_model_from_hdf5(h5_file)\n    else:\n        with TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir) / weight_reader.original_file_name\n            with temp_path.open(\"wb\") as f:\n                shutil.copyfileobj(weight_reader, f)\n\n            self._network = keras.models.load_model(temp_path)\n\n    self._output_axes = [\n        tuple(a.id for a in get_axes_infos(out))\n        for out in model_description.outputs\n    ]\n</code></pre>"},{"location":"api/bioimageio/core/backends/keras_backend/#bioimageio.core.backends.keras_backend.KerasModelAdapter.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], *, devices: Optional[Sequence[str]] = None, weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None)\n</code></pre> <p>Creates model adapter based on the passed spec Note: All specific adapters should happen inside this function to prevent different framework initializations interfering with each other</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0backends <code></code>\u00a0create_model_adapter </li> <li> <code></code>\u00a0model_adapters <code></code>\u00a0create_model_adapter </li> </ul> </li> </ul> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\n@classmethod\ndef create(\n    cls,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    *,\n    devices: Optional[Sequence[str]] = None,\n    weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None,\n):\n    \"\"\"\n    Creates model adapter based on the passed spec\n    Note: All specific adapters should happen inside this function to prevent different framework\n    initializations interfering with each other\n    \"\"\"\n    if not isinstance(model_description, (v0_4.ModelDescr, v0_5.ModelDescr)):\n        raise TypeError(\n            f\"expected v0_4.ModelDescr or v0_5.ModelDescr, but got {type(model_description)}\"\n        )\n\n    weights = model_description.weights\n    errors: List[Exception] = []\n    weight_format_priority_order = (\n        DEFAULT_WEIGHT_FORMAT_PRIORITY_ORDER\n        if weight_format_priority_order is None\n        else weight_format_priority_order\n    )\n    # limit weight formats to the ones present\n    weight_format_priority_order_present: Sequence[SupportedWeightsFormat] = [\n        w for w in weight_format_priority_order if getattr(weights, w) is not None\n    ]\n    if not weight_format_priority_order_present:\n        raise ValueError(\n            f\"None of the specified weight formats ({weight_format_priority_order}) is present ({weight_format_priority_order_present})\"\n        )\n\n    for wf in weight_format_priority_order_present:\n        if wf == \"pytorch_state_dict\":\n            assert weights.pytorch_state_dict is not None\n            try:\n                from .pytorch_backend import PytorchModelAdapter\n\n                return PytorchModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"tensorflow_saved_model_bundle\":\n            assert weights.tensorflow_saved_model_bundle is not None\n            try:\n                from .tensorflow_backend import create_tf_model_adapter\n\n                return create_tf_model_adapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"onnx\":\n            assert weights.onnx is not None\n            try:\n                from .onnx_backend import ONNXModelAdapter\n\n                return ONNXModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"torchscript\":\n            assert weights.torchscript is not None\n            try:\n                from .torchscript_backend import TorchscriptModelAdapter\n\n                return TorchscriptModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"keras_hdf5\":\n            assert weights.keras_hdf5 is not None\n            # keras can either be installed as a separate package or used as part of tensorflow\n            # we try to first import the keras model adapter using the separate package and,\n            # if it is not available, try to load the one using tf\n            try:\n                try:\n                    from .keras_backend import KerasModelAdapter\n                except Exception:\n                    from .tensorflow_backend import KerasModelAdapter\n\n                return KerasModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        else:\n            assert_never(wf)\n\n    assert errors\n    if len(weight_format_priority_order) == 1:\n        assert len(errors) == 1\n        raise errors[0]\n\n    else:\n        msg = (\n            \"None of the weight format specific model adapters could be created\"\n            + \" in this environment.\"\n        )\n        raise ExceptionGroup(msg, errors)\n</code></pre>"},{"location":"api/bioimageio/core/backends/keras_backend/#bioimageio.core.backends.keras_backend.KerasModelAdapter.forward","title":"forward","text":"<pre><code>forward(input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]) -&gt; Sample\n</code></pre> <p>Run forward pass of model to get model predictions</p> <p>Note: sample id and stample stat attributes are passed through</p> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>def forward(\n    self, input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]\n) -&gt; Sample:\n    \"\"\"\n    Run forward pass of model to get model predictions\n\n    Note: sample id and stample stat attributes are passed through\n    \"\"\"\n    unexpected = [mid for mid in input_sample.members if mid not in self._input_ids]\n    if unexpected:\n        warnings.warn(f\"Got unexpected input tensor IDs: {unexpected}\")\n\n    input_arrays = [\n        (\n            None\n            if (a := input_sample.members.get(in_id)) is None\n            else a.transpose(in_order).data.data\n        )\n        for in_id, in_order in zip(self._input_ids, self._input_axes)\n    ]\n    output_arrays = self._forward_impl(input_arrays)\n    assert len(output_arrays) &lt;= len(self._output_ids)\n    output_tensors = [\n        None if a is None else Tensor(a, dims=d)\n        for a, d in zip(output_arrays, self._output_axes)\n    ]\n    return Sample(\n        members={\n            tid: out\n            for tid, out in zip(\n                self._output_ids,\n                output_tensors,\n            )\n            if out is not None\n        },\n        stat=input_sample.stat,\n        id=(\n            input_sample.id\n            if isinstance(input_sample, Sample)\n            else input_sample.sample_id\n        ),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/keras_backend/#bioimageio.core.backends.keras_backend.KerasModelAdapter.load","title":"load","text":"<pre><code>load(*, devices: Optional[Sequence[str]] = None) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\ndef load(self, *, devices: Optional[Sequence[str]] = None) -&gt; None:\n    warnings.warn(\"Deprecated. ModelAdapter is loaded on initialization\")\n</code></pre>"},{"location":"api/bioimageio/core/backends/keras_backend/#bioimageio.core.backends.keras_backend.KerasModelAdapter.unload","title":"unload","text":"<pre><code>unload() -&gt; None\n</code></pre> <p>Unload model from any devices, freeing their memory. The moder adapter should be considered unusable afterwards.</p> Source code in <code>src/bioimageio/core/backends/keras_backend.py</code> <pre><code>def unload(self) -&gt; None:\n    logger.warning(\n        \"Device management is not implemented for keras yet, cannot unload model\"\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/onnx_backend/","title":"Onnx backend","text":""},{"location":"api/bioimageio/core/backends/onnx_backend/#bioimageio.core.backends.onnx_backend","title":"onnx_backend","text":"<p>Classes:</p> Name Description <code>ONNXModelAdapter</code>"},{"location":"api/bioimageio/core/backends/onnx_backend/#bioimageio.core.backends.onnx_backend.ONNXModelAdapter","title":"ONNXModelAdapter","text":"<pre><code>ONNXModelAdapter(*, model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], devices: Optional[Sequence[str]] = None)\n</code></pre> <p>               Bases: <code>ModelAdapter</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.backends.onnx_backend.ONNXModelAdapter[ONNXModelAdapter]\n              bioimageio.core.backends._model_adapter.ModelAdapter[ModelAdapter]\n\n                              bioimageio.core.backends._model_adapter.ModelAdapter --&gt; bioimageio.core.backends.onnx_backend.ONNXModelAdapter\n                \n\n\n              click bioimageio.core.backends.onnx_backend.ONNXModelAdapter href \"\" \"bioimageio.core.backends.onnx_backend.ONNXModelAdapter\"\n              click bioimageio.core.backends._model_adapter.ModelAdapter href \"\" \"bioimageio.core.backends._model_adapter.ModelAdapter\"\n            </code></pre> <p>Methods:</p> Name Description <code>create</code> <p>Creates model adapter based on the passed spec</p> <code>forward</code> <p>Run forward pass of model to get model predictions</p> <code>load</code> <code>unload</code> <p>Unload model from any devices, freeing their memory.</p> Source code in <code>src/bioimageio/core/backends/onnx_backend.py</code> <pre><code>def __init__(\n    self,\n    *,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    devices: Optional[Sequence[str]] = None,\n):\n    super().__init__(model_description=model_description)\n\n    onnx_descr = model_description.weights.onnx\n    if onnx_descr is None:\n        raise ValueError(\"No ONNX weights specified for {model_description.name}\")\n\n    providers = None\n    if hasattr(rt, \"get_available_providers\"):\n        providers = rt.get_available_providers()\n\n    if (\n        isinstance(onnx_descr, v0_5.OnnxWeightsDescr)\n        and onnx_descr.external_data is not None\n    ):\n        src = onnx_descr.source.absolute()\n        src_data = onnx_descr.external_data.source.absolute()\n        if (\n            isinstance(src, Path)\n            and isinstance(src_data, Path)\n            and src.parent == src_data.parent\n        ):\n            logger.debug(\n                \"Loading ONNX model with external data from {}\",\n                src.parent,\n            )\n            self._session = rt.InferenceSession(\n                src,\n                providers=providers,  # pyright: ignore[reportUnknownArgumentType]\n            )\n        else:\n            src_reader = onnx_descr.get_reader()\n            src_data_reader = onnx_descr.external_data.get_reader()\n            with tempfile.TemporaryDirectory() as tmpdir:\n                logger.debug(\n                    \"Loading ONNX model with external data from {}\",\n                    tmpdir,\n                )\n                src = Path(tmpdir) / src_reader.original_file_name\n                src_data = Path(tmpdir) / src_data_reader.original_file_name\n                with src.open(\"wb\") as f:\n                    shutil.copyfileobj(src_reader, f)\n                with src_data.open(\"wb\") as f:\n                    shutil.copyfileobj(src_data_reader, f)\n\n                self._session = rt.InferenceSession(\n                    src,\n                    providers=providers,  # pyright: ignore[reportUnknownArgumentType]\n                )\n    else:\n        # load single source file from bytes (without external data, so probably &lt;2GB)\n        logger.debug(\n            \"Loading ONNX model from bytes (read from {})\", onnx_descr.source\n        )\n        reader = onnx_descr.get_reader()\n        self._session = rt.InferenceSession(\n            reader.read(),\n            providers=providers,  # pyright: ignore[reportUnknownArgumentType]\n        )\n\n    onnx_inputs = self._session.get_inputs()\n    self._input_names: List[str] = [ipt.name for ipt in onnx_inputs]\n\n    if devices is not None:\n        warnings.warn(\n            f\"Device management is not implemented for onnx yet, ignoring the devices {devices}\"\n        )\n</code></pre>"},{"location":"api/bioimageio/core/backends/onnx_backend/#bioimageio.core.backends.onnx_backend.ONNXModelAdapter.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], *, devices: Optional[Sequence[str]] = None, weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None)\n</code></pre> <p>Creates model adapter based on the passed spec Note: All specific adapters should happen inside this function to prevent different framework initializations interfering with each other</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0backends <code></code>\u00a0create_model_adapter </li> <li> <code></code>\u00a0model_adapters <code></code>\u00a0create_model_adapter </li> </ul> </li> </ul> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\n@classmethod\ndef create(\n    cls,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    *,\n    devices: Optional[Sequence[str]] = None,\n    weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None,\n):\n    \"\"\"\n    Creates model adapter based on the passed spec\n    Note: All specific adapters should happen inside this function to prevent different framework\n    initializations interfering with each other\n    \"\"\"\n    if not isinstance(model_description, (v0_4.ModelDescr, v0_5.ModelDescr)):\n        raise TypeError(\n            f\"expected v0_4.ModelDescr or v0_5.ModelDescr, but got {type(model_description)}\"\n        )\n\n    weights = model_description.weights\n    errors: List[Exception] = []\n    weight_format_priority_order = (\n        DEFAULT_WEIGHT_FORMAT_PRIORITY_ORDER\n        if weight_format_priority_order is None\n        else weight_format_priority_order\n    )\n    # limit weight formats to the ones present\n    weight_format_priority_order_present: Sequence[SupportedWeightsFormat] = [\n        w for w in weight_format_priority_order if getattr(weights, w) is not None\n    ]\n    if not weight_format_priority_order_present:\n        raise ValueError(\n            f\"None of the specified weight formats ({weight_format_priority_order}) is present ({weight_format_priority_order_present})\"\n        )\n\n    for wf in weight_format_priority_order_present:\n        if wf == \"pytorch_state_dict\":\n            assert weights.pytorch_state_dict is not None\n            try:\n                from .pytorch_backend import PytorchModelAdapter\n\n                return PytorchModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"tensorflow_saved_model_bundle\":\n            assert weights.tensorflow_saved_model_bundle is not None\n            try:\n                from .tensorflow_backend import create_tf_model_adapter\n\n                return create_tf_model_adapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"onnx\":\n            assert weights.onnx is not None\n            try:\n                from .onnx_backend import ONNXModelAdapter\n\n                return ONNXModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"torchscript\":\n            assert weights.torchscript is not None\n            try:\n                from .torchscript_backend import TorchscriptModelAdapter\n\n                return TorchscriptModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"keras_hdf5\":\n            assert weights.keras_hdf5 is not None\n            # keras can either be installed as a separate package or used as part of tensorflow\n            # we try to first import the keras model adapter using the separate package and,\n            # if it is not available, try to load the one using tf\n            try:\n                try:\n                    from .keras_backend import KerasModelAdapter\n                except Exception:\n                    from .tensorflow_backend import KerasModelAdapter\n\n                return KerasModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        else:\n            assert_never(wf)\n\n    assert errors\n    if len(weight_format_priority_order) == 1:\n        assert len(errors) == 1\n        raise errors[0]\n\n    else:\n        msg = (\n            \"None of the weight format specific model adapters could be created\"\n            + \" in this environment.\"\n        )\n        raise ExceptionGroup(msg, errors)\n</code></pre>"},{"location":"api/bioimageio/core/backends/onnx_backend/#bioimageio.core.backends.onnx_backend.ONNXModelAdapter.forward","title":"forward","text":"<pre><code>forward(input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]) -&gt; Sample\n</code></pre> <p>Run forward pass of model to get model predictions</p> <p>Note: sample id and stample stat attributes are passed through</p> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>def forward(\n    self, input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]\n) -&gt; Sample:\n    \"\"\"\n    Run forward pass of model to get model predictions\n\n    Note: sample id and stample stat attributes are passed through\n    \"\"\"\n    unexpected = [mid for mid in input_sample.members if mid not in self._input_ids]\n    if unexpected:\n        warnings.warn(f\"Got unexpected input tensor IDs: {unexpected}\")\n\n    input_arrays = [\n        (\n            None\n            if (a := input_sample.members.get(in_id)) is None\n            else a.transpose(in_order).data.data\n        )\n        for in_id, in_order in zip(self._input_ids, self._input_axes)\n    ]\n    output_arrays = self._forward_impl(input_arrays)\n    assert len(output_arrays) &lt;= len(self._output_ids)\n    output_tensors = [\n        None if a is None else Tensor(a, dims=d)\n        for a, d in zip(output_arrays, self._output_axes)\n    ]\n    return Sample(\n        members={\n            tid: out\n            for tid, out in zip(\n                self._output_ids,\n                output_tensors,\n            )\n            if out is not None\n        },\n        stat=input_sample.stat,\n        id=(\n            input_sample.id\n            if isinstance(input_sample, Sample)\n            else input_sample.sample_id\n        ),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/onnx_backend/#bioimageio.core.backends.onnx_backend.ONNXModelAdapter.load","title":"load","text":"<pre><code>load(*, devices: Optional[Sequence[str]] = None) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\ndef load(self, *, devices: Optional[Sequence[str]] = None) -&gt; None:\n    warnings.warn(\"Deprecated. ModelAdapter is loaded on initialization\")\n</code></pre>"},{"location":"api/bioimageio/core/backends/onnx_backend/#bioimageio.core.backends.onnx_backend.ONNXModelAdapter.unload","title":"unload","text":"<pre><code>unload() -&gt; None\n</code></pre> <p>Unload model from any devices, freeing their memory. The moder adapter should be considered unusable afterwards.</p> Source code in <code>src/bioimageio/core/backends/onnx_backend.py</code> <pre><code>def unload(self) -&gt; None:\n    warnings.warn(\n        \"Device management is not implemented for onnx yet, cannot unload model\"\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/pytorch_backend/","title":"Pytorch backend","text":""},{"location":"api/bioimageio/core/backends/pytorch_backend/#bioimageio.core.backends.pytorch_backend","title":"pytorch_backend","text":"<p>Classes:</p> Name Description <code>PytorchModelAdapter</code> <p>Functions:</p> Name Description <code>get_devices</code> <code>load_torch_model</code> <code>load_torch_state_dict</code>"},{"location":"api/bioimageio/core/backends/pytorch_backend/#bioimageio.core.backends.pytorch_backend.PytorchModelAdapter","title":"PytorchModelAdapter","text":"<pre><code>PytorchModelAdapter(*, model_description: AnyModelDescr, devices: Optional[Sequence[Union[str, torch.device]]] = None, mode: Literal['eval', 'train'] = 'eval')\n</code></pre> <p>               Bases: <code>ModelAdapter</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.backends.pytorch_backend.PytorchModelAdapter[PytorchModelAdapter]\n              bioimageio.core.backends._model_adapter.ModelAdapter[ModelAdapter]\n\n                              bioimageio.core.backends._model_adapter.ModelAdapter --&gt; bioimageio.core.backends.pytorch_backend.PytorchModelAdapter\n                \n\n\n              click bioimageio.core.backends.pytorch_backend.PytorchModelAdapter href \"\" \"bioimageio.core.backends.pytorch_backend.PytorchModelAdapter\"\n              click bioimageio.core.backends._model_adapter.ModelAdapter href \"\" \"bioimageio.core.backends._model_adapter.ModelAdapter\"\n            </code></pre> <p>Methods:</p> Name Description <code>create</code> <p>Creates model adapter based on the passed spec</p> <code>forward</code> <p>Run forward pass of model to get model predictions</p> <code>load</code> <code>unload</code> <p>Unload model from any devices, freeing their memory.</p> Source code in <code>src/bioimageio/core/backends/pytorch_backend.py</code> <pre><code>def __init__(\n    self,\n    *,\n    model_description: AnyModelDescr,\n    devices: Optional[Sequence[Union[str, torch.device]]] = None,\n    mode: Literal[\"eval\", \"train\"] = \"eval\",\n):\n    super().__init__(model_description=model_description)\n    weights = model_description.weights.pytorch_state_dict\n    if weights is None:\n        raise ValueError(\"No `pytorch_state_dict` weights found\")\n\n    devices = get_devices(devices)\n    self._model = load_torch_model(weights, load_state=True, devices=devices)\n    if mode == \"eval\":\n        self._model = self._model.eval()\n    elif mode == \"train\":\n        self._model = self._model.train()\n    else:\n        assert_never(mode)\n\n    self._mode: Literal[\"eval\", \"train\"] = mode\n    self._primary_device = devices[0]\n</code></pre>"},{"location":"api/bioimageio/core/backends/pytorch_backend/#bioimageio.core.backends.pytorch_backend.PytorchModelAdapter.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], *, devices: Optional[Sequence[str]] = None, weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None)\n</code></pre> <p>Creates model adapter based on the passed spec Note: All specific adapters should happen inside this function to prevent different framework initializations interfering with each other</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0backends <code></code>\u00a0create_model_adapter </li> <li> <code></code>\u00a0model_adapters <code></code>\u00a0create_model_adapter </li> </ul> </li> </ul> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\n@classmethod\ndef create(\n    cls,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    *,\n    devices: Optional[Sequence[str]] = None,\n    weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None,\n):\n    \"\"\"\n    Creates model adapter based on the passed spec\n    Note: All specific adapters should happen inside this function to prevent different framework\n    initializations interfering with each other\n    \"\"\"\n    if not isinstance(model_description, (v0_4.ModelDescr, v0_5.ModelDescr)):\n        raise TypeError(\n            f\"expected v0_4.ModelDescr or v0_5.ModelDescr, but got {type(model_description)}\"\n        )\n\n    weights = model_description.weights\n    errors: List[Exception] = []\n    weight_format_priority_order = (\n        DEFAULT_WEIGHT_FORMAT_PRIORITY_ORDER\n        if weight_format_priority_order is None\n        else weight_format_priority_order\n    )\n    # limit weight formats to the ones present\n    weight_format_priority_order_present: Sequence[SupportedWeightsFormat] = [\n        w for w in weight_format_priority_order if getattr(weights, w) is not None\n    ]\n    if not weight_format_priority_order_present:\n        raise ValueError(\n            f\"None of the specified weight formats ({weight_format_priority_order}) is present ({weight_format_priority_order_present})\"\n        )\n\n    for wf in weight_format_priority_order_present:\n        if wf == \"pytorch_state_dict\":\n            assert weights.pytorch_state_dict is not None\n            try:\n                from .pytorch_backend import PytorchModelAdapter\n\n                return PytorchModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"tensorflow_saved_model_bundle\":\n            assert weights.tensorflow_saved_model_bundle is not None\n            try:\n                from .tensorflow_backend import create_tf_model_adapter\n\n                return create_tf_model_adapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"onnx\":\n            assert weights.onnx is not None\n            try:\n                from .onnx_backend import ONNXModelAdapter\n\n                return ONNXModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"torchscript\":\n            assert weights.torchscript is not None\n            try:\n                from .torchscript_backend import TorchscriptModelAdapter\n\n                return TorchscriptModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"keras_hdf5\":\n            assert weights.keras_hdf5 is not None\n            # keras can either be installed as a separate package or used as part of tensorflow\n            # we try to first import the keras model adapter using the separate package and,\n            # if it is not available, try to load the one using tf\n            try:\n                try:\n                    from .keras_backend import KerasModelAdapter\n                except Exception:\n                    from .tensorflow_backend import KerasModelAdapter\n\n                return KerasModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        else:\n            assert_never(wf)\n\n    assert errors\n    if len(weight_format_priority_order) == 1:\n        assert len(errors) == 1\n        raise errors[0]\n\n    else:\n        msg = (\n            \"None of the weight format specific model adapters could be created\"\n            + \" in this environment.\"\n        )\n        raise ExceptionGroup(msg, errors)\n</code></pre>"},{"location":"api/bioimageio/core/backends/pytorch_backend/#bioimageio.core.backends.pytorch_backend.PytorchModelAdapter.forward","title":"forward","text":"<pre><code>forward(input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]) -&gt; Sample\n</code></pre> <p>Run forward pass of model to get model predictions</p> <p>Note: sample id and stample stat attributes are passed through</p> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>def forward(\n    self, input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]\n) -&gt; Sample:\n    \"\"\"\n    Run forward pass of model to get model predictions\n\n    Note: sample id and stample stat attributes are passed through\n    \"\"\"\n    unexpected = [mid for mid in input_sample.members if mid not in self._input_ids]\n    if unexpected:\n        warnings.warn(f\"Got unexpected input tensor IDs: {unexpected}\")\n\n    input_arrays = [\n        (\n            None\n            if (a := input_sample.members.get(in_id)) is None\n            else a.transpose(in_order).data.data\n        )\n        for in_id, in_order in zip(self._input_ids, self._input_axes)\n    ]\n    output_arrays = self._forward_impl(input_arrays)\n    assert len(output_arrays) &lt;= len(self._output_ids)\n    output_tensors = [\n        None if a is None else Tensor(a, dims=d)\n        for a, d in zip(output_arrays, self._output_axes)\n    ]\n    return Sample(\n        members={\n            tid: out\n            for tid, out in zip(\n                self._output_ids,\n                output_tensors,\n            )\n            if out is not None\n        },\n        stat=input_sample.stat,\n        id=(\n            input_sample.id\n            if isinstance(input_sample, Sample)\n            else input_sample.sample_id\n        ),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/pytorch_backend/#bioimageio.core.backends.pytorch_backend.PytorchModelAdapter.load","title":"load","text":"<pre><code>load(*, devices: Optional[Sequence[str]] = None) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\ndef load(self, *, devices: Optional[Sequence[str]] = None) -&gt; None:\n    warnings.warn(\"Deprecated. ModelAdapter is loaded on initialization\")\n</code></pre>"},{"location":"api/bioimageio/core/backends/pytorch_backend/#bioimageio.core.backends.pytorch_backend.PytorchModelAdapter.unload","title":"unload","text":"<pre><code>unload() -&gt; None\n</code></pre> <p>Unload model from any devices, freeing their memory. The moder adapter should be considered unusable afterwards.</p> Source code in <code>src/bioimageio/core/backends/pytorch_backend.py</code> <pre><code>def unload(self) -&gt; None:\n    del self._model\n    _ = gc.collect()  # deallocate memory\n    assert torch is not None\n    torch.cuda.empty_cache()  # release reserved memory\n</code></pre>"},{"location":"api/bioimageio/core/backends/pytorch_backend/#bioimageio.core.backends.pytorch_backend.get_devices","title":"get_devices","text":"<pre><code>get_devices(devices: Optional[Sequence[Union[torch.device, str]]] = None) -&gt; List[torch.device]\n</code></pre> Source code in <code>src/bioimageio/core/backends/pytorch_backend.py</code> <pre><code>def get_devices(\n    devices: Optional[Sequence[Union[torch.device, str]]] = None,\n) -&gt; List[torch.device]:\n    if not devices:\n        torch_devices = [\n            torch.device(\"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\n        ]\n    else:\n        torch_devices = [torch.device(d) for d in devices]\n\n    if len(torch_devices) &gt; 1:\n        warnings.warn(\n            f\"Multiple devices for single pytorch model not yet implemented; ignoring {torch_devices[1:]}\"\n        )\n        torch_devices = torch_devices[:1]\n\n    return torch_devices\n</code></pre>"},{"location":"api/bioimageio/core/backends/pytorch_backend/#bioimageio.core.backends.pytorch_backend.load_torch_model","title":"load_torch_model","text":"<pre><code>load_torch_model(weight_spec: Union[v0_4.PytorchStateDictWeightsDescr, v0_5.PytorchStateDictWeightsDescr], *, load_state: bool = True, devices: Optional[Sequence[Union[str, torch.device]]] = None) -&gt; nn.Module\n</code></pre> Source code in <code>src/bioimageio/core/backends/pytorch_backend.py</code> <pre><code>def load_torch_model(\n    weight_spec: Union[\n        v0_4.PytorchStateDictWeightsDescr, v0_5.PytorchStateDictWeightsDescr\n    ],\n    *,\n    load_state: bool = True,\n    devices: Optional[Sequence[Union[str, torch.device]]] = None,\n) -&gt; nn.Module:\n    custom_callable = import_callable(\n        weight_spec.architecture,\n        sha256=(\n            weight_spec.architecture_sha256\n            if isinstance(weight_spec, v0_4.PytorchStateDictWeightsDescr)\n            else weight_spec.sha256\n        ),\n    )\n    model_kwargs = (\n        weight_spec.kwargs\n        if isinstance(weight_spec, v0_4.PytorchStateDictWeightsDescr)\n        else weight_spec.architecture.kwargs\n    )\n    torch_model = custom_callable(**model_kwargs)\n\n    if not isinstance(torch_model, nn.Module):\n        if isinstance(\n            weight_spec.architecture,\n            (v0_4.CallableFromFile, v0_4.CallableFromDepencency),\n        ):\n            callable_name = weight_spec.architecture.callable_name\n        else:\n            callable_name = weight_spec.architecture.callable\n\n        raise ValueError(f\"Calling {callable_name} did not return a torch.nn.Module.\")\n\n    if load_state or devices:\n        use_devices = get_devices(devices)\n        torch_model = torch_model.to(use_devices[0])\n        if load_state:\n            torch_model = load_torch_state_dict(\n                torch_model,\n                path=download(weight_spec),\n                devices=use_devices,\n            )\n    return torch_model\n</code></pre>"},{"location":"api/bioimageio/core/backends/pytorch_backend/#bioimageio.core.backends.pytorch_backend.load_torch_state_dict","title":"load_torch_state_dict","text":"<pre><code>load_torch_state_dict(model: nn.Module, path: Union[Path, ZipPath, BytesReader], devices: Sequence[torch.device]) -&gt; nn.Module\n</code></pre> Source code in <code>src/bioimageio/core/backends/pytorch_backend.py</code> <pre><code>def load_torch_state_dict(\n    model: nn.Module,\n    path: Union[Path, ZipPath, BytesReader],\n    devices: Sequence[torch.device],\n) -&gt; nn.Module:\n    model = model.to(devices[0])\n    if isinstance(path, (Path, ZipPath)):\n        ctxt = path.open(\"rb\")\n    else:\n        ctxt = nullcontext(BytesIO(path.read()))\n\n    with ctxt as f:\n        assert not isinstance(f, TextIOWrapper)\n        if Version(str(torch.__version__)) &lt; Version(\"1.13\"):\n            state = torch.load(f, map_location=devices[0])\n        else:\n            state = torch.load(f, map_location=devices[0], weights_only=True)\n\n    incompatible = model.load_state_dict(state)\n    if (\n        isinstance(incompatible, tuple)\n        and hasattr(incompatible, \"missing_keys\")\n        and hasattr(incompatible, \"unexpected_keys\")\n    ):\n        if incompatible.missing_keys:\n            logger.warning(\"Missing state dict keys: {}\", incompatible.missing_keys)\n\n        if hasattr(incompatible, \"unexpected_keys\") and incompatible.unexpected_keys:\n            logger.warning(\n                \"Unexpected state dict keys: {}\", incompatible.unexpected_keys\n            )\n    else:\n        logger.warning(\n            \"`model.load_state_dict()` unexpectedly returned: {} \"\n            + \"(expected named tuple with `missing_keys` and `unexpected_keys` attributes)\",\n            (s[:20] + \"...\" if len(s := str(incompatible)) &gt; 20 else s),\n        )\n\n    return model\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/","title":"Tensorflow backend","text":""},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend","title":"tensorflow_backend","text":"<p>Classes:</p> Name Description <code>KerasModelAdapter</code> <code>TensorflowModelAdapter</code> <p>Functions:</p> Name Description <code>create_tf_model_adapter</code>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.KerasModelAdapter","title":"KerasModelAdapter","text":"<pre><code>KerasModelAdapter(*, model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], devices: Optional[Sequence[str]] = None)\n</code></pre> <p>               Bases: <code>ModelAdapter</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.backends.tensorflow_backend.KerasModelAdapter[KerasModelAdapter]\n              bioimageio.core.backends._model_adapter.ModelAdapter[ModelAdapter]\n\n                              bioimageio.core.backends._model_adapter.ModelAdapter --&gt; bioimageio.core.backends.tensorflow_backend.KerasModelAdapter\n                \n\n\n              click bioimageio.core.backends.tensorflow_backend.KerasModelAdapter href \"\" \"bioimageio.core.backends.tensorflow_backend.KerasModelAdapter\"\n              click bioimageio.core.backends._model_adapter.ModelAdapter href \"\" \"bioimageio.core.backends._model_adapter.ModelAdapter\"\n            </code></pre> <p>Methods:</p> Name Description <code>create</code> <p>Creates model adapter based on the passed spec</p> <code>forward</code> <p>Run forward pass of model to get model predictions</p> <code>load</code> <code>unload</code> <p>Unload model from any devices, freeing their memory.</p> Source code in <code>src/bioimageio/core/backends/tensorflow_backend.py</code> <pre><code>def __init__(\n    self,\n    *,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    devices: Optional[Sequence[str]] = None,\n):\n    if model_description.weights.tensorflow_saved_model_bundle is None:\n        raise ValueError(\"No `tensorflow_saved_model_bundle` weights found\")\n\n    super().__init__(model_description=model_description)\n    if devices is not None:\n        logger.warning(\n            f\"Device management is not implemented for tensorflow yet, ignoring the devices {devices}\"\n        )\n\n    # TODO: check how to load tf weights without unzipping\n    weight_file = ensure_unzipped(\n        model_description.weights.tensorflow_saved_model_bundle.source,\n        Path(\"bioimageio_unzipped_tf_weights\"),\n    )\n\n    try:\n        self._network = tf.keras.layers.TFSMLayer(  # pyright: ignore[reportAttributeAccessIssue]\n            weight_file,\n            call_endpoint=\"serve\",\n        )\n    except Exception as e:\n        try:\n            self._network = tf.keras.layers.TFSMLayer(  # pyright: ignore[reportAttributeAccessIssue]\n                weight_file, call_endpoint=\"serving_default\"\n            )\n        except Exception as ee:\n            logger.opt(exception=ee).info(\n                \"keras.layers.TFSMLayer error for alternative call_endpoint='serving_default'\"\n            )\n            raise e\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.KerasModelAdapter.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], *, devices: Optional[Sequence[str]] = None, weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None)\n</code></pre> <p>Creates model adapter based on the passed spec Note: All specific adapters should happen inside this function to prevent different framework initializations interfering with each other</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0backends <code></code>\u00a0create_model_adapter </li> <li> <code></code>\u00a0model_adapters <code></code>\u00a0create_model_adapter </li> </ul> </li> </ul> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\n@classmethod\ndef create(\n    cls,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    *,\n    devices: Optional[Sequence[str]] = None,\n    weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None,\n):\n    \"\"\"\n    Creates model adapter based on the passed spec\n    Note: All specific adapters should happen inside this function to prevent different framework\n    initializations interfering with each other\n    \"\"\"\n    if not isinstance(model_description, (v0_4.ModelDescr, v0_5.ModelDescr)):\n        raise TypeError(\n            f\"expected v0_4.ModelDescr or v0_5.ModelDescr, but got {type(model_description)}\"\n        )\n\n    weights = model_description.weights\n    errors: List[Exception] = []\n    weight_format_priority_order = (\n        DEFAULT_WEIGHT_FORMAT_PRIORITY_ORDER\n        if weight_format_priority_order is None\n        else weight_format_priority_order\n    )\n    # limit weight formats to the ones present\n    weight_format_priority_order_present: Sequence[SupportedWeightsFormat] = [\n        w for w in weight_format_priority_order if getattr(weights, w) is not None\n    ]\n    if not weight_format_priority_order_present:\n        raise ValueError(\n            f\"None of the specified weight formats ({weight_format_priority_order}) is present ({weight_format_priority_order_present})\"\n        )\n\n    for wf in weight_format_priority_order_present:\n        if wf == \"pytorch_state_dict\":\n            assert weights.pytorch_state_dict is not None\n            try:\n                from .pytorch_backend import PytorchModelAdapter\n\n                return PytorchModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"tensorflow_saved_model_bundle\":\n            assert weights.tensorflow_saved_model_bundle is not None\n            try:\n                from .tensorflow_backend import create_tf_model_adapter\n\n                return create_tf_model_adapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"onnx\":\n            assert weights.onnx is not None\n            try:\n                from .onnx_backend import ONNXModelAdapter\n\n                return ONNXModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"torchscript\":\n            assert weights.torchscript is not None\n            try:\n                from .torchscript_backend import TorchscriptModelAdapter\n\n                return TorchscriptModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"keras_hdf5\":\n            assert weights.keras_hdf5 is not None\n            # keras can either be installed as a separate package or used as part of tensorflow\n            # we try to first import the keras model adapter using the separate package and,\n            # if it is not available, try to load the one using tf\n            try:\n                try:\n                    from .keras_backend import KerasModelAdapter\n                except Exception:\n                    from .tensorflow_backend import KerasModelAdapter\n\n                return KerasModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        else:\n            assert_never(wf)\n\n    assert errors\n    if len(weight_format_priority_order) == 1:\n        assert len(errors) == 1\n        raise errors[0]\n\n    else:\n        msg = (\n            \"None of the weight format specific model adapters could be created\"\n            + \" in this environment.\"\n        )\n        raise ExceptionGroup(msg, errors)\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.KerasModelAdapter.forward","title":"forward","text":"<pre><code>forward(input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]) -&gt; Sample\n</code></pre> <p>Run forward pass of model to get model predictions</p> <p>Note: sample id and stample stat attributes are passed through</p> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>def forward(\n    self, input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]\n) -&gt; Sample:\n    \"\"\"\n    Run forward pass of model to get model predictions\n\n    Note: sample id and stample stat attributes are passed through\n    \"\"\"\n    unexpected = [mid for mid in input_sample.members if mid not in self._input_ids]\n    if unexpected:\n        warnings.warn(f\"Got unexpected input tensor IDs: {unexpected}\")\n\n    input_arrays = [\n        (\n            None\n            if (a := input_sample.members.get(in_id)) is None\n            else a.transpose(in_order).data.data\n        )\n        for in_id, in_order in zip(self._input_ids, self._input_axes)\n    ]\n    output_arrays = self._forward_impl(input_arrays)\n    assert len(output_arrays) &lt;= len(self._output_ids)\n    output_tensors = [\n        None if a is None else Tensor(a, dims=d)\n        for a, d in zip(output_arrays, self._output_axes)\n    ]\n    return Sample(\n        members={\n            tid: out\n            for tid, out in zip(\n                self._output_ids,\n                output_tensors,\n            )\n            if out is not None\n        },\n        stat=input_sample.stat,\n        id=(\n            input_sample.id\n            if isinstance(input_sample, Sample)\n            else input_sample.sample_id\n        ),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.KerasModelAdapter.load","title":"load","text":"<pre><code>load(*, devices: Optional[Sequence[str]] = None) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\ndef load(self, *, devices: Optional[Sequence[str]] = None) -&gt; None:\n    warnings.warn(\"Deprecated. ModelAdapter is loaded on initialization\")\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.KerasModelAdapter.unload","title":"unload","text":"<pre><code>unload() -&gt; None\n</code></pre> <p>Unload model from any devices, freeing their memory. The moder adapter should be considered unusable afterwards.</p> Source code in <code>src/bioimageio/core/backends/tensorflow_backend.py</code> <pre><code>def unload(self) -&gt; None:\n    logger.warning(\n        \"Device management is not implemented for tensorflow&gt;=2 models\"\n        + f\" using `{self.__class__.__name__}`, cannot unload model\"\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter","title":"TensorflowModelAdapter","text":"<pre><code>TensorflowModelAdapter(*, model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], devices: Optional[Sequence[str]] = None)\n</code></pre> <p>               Bases: <code>ModelAdapter</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter[TensorflowModelAdapter]\n              bioimageio.core.backends._model_adapter.ModelAdapter[ModelAdapter]\n\n                              bioimageio.core.backends._model_adapter.ModelAdapter --&gt; bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter\n                \n\n\n              click bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter href \"\" \"bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter\"\n              click bioimageio.core.backends._model_adapter.ModelAdapter href \"\" \"bioimageio.core.backends._model_adapter.ModelAdapter\"\n            </code></pre> <p>Methods:</p> Name Description <code>create</code> <p>Creates model adapter based on the passed spec</p> <code>forward</code> <p>Run forward pass of model to get model predictions</p> <code>load</code> <code>unload</code> <p>Unload model from any devices, freeing their memory.</p> <p>Attributes:</p> Name Type Description <code>weight_format</code> Source code in <code>src/bioimageio/core/backends/tensorflow_backend.py</code> <pre><code>def __init__(\n    self,\n    *,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    devices: Optional[Sequence[str]] = None,\n):\n    super().__init__(model_description=model_description)\n\n    weight_file = model_description.weights.tensorflow_saved_model_bundle\n    if model_description.weights.tensorflow_saved_model_bundle is None:\n        raise ValueError(\"No `tensorflow_saved_model_bundle` weights found\")\n\n    if devices is not None:\n        logger.warning(\n            f\"Device management is not implemented for tensorflow yet, ignoring the devices {devices}\"\n        )\n\n    # TODO: check how to load tf weights without unzipping\n    weight_file = ensure_unzipped(\n        model_description.weights.tensorflow_saved_model_bundle.source,\n        Path(\"bioimageio_unzipped_tf_weights\"),\n    )\n    self._network = str(weight_file)\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter.weight_format","title":"weight_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight_format = 'tensorflow_saved_model_bundle'\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], *, devices: Optional[Sequence[str]] = None, weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None)\n</code></pre> <p>Creates model adapter based on the passed spec Note: All specific adapters should happen inside this function to prevent different framework initializations interfering with each other</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0backends <code></code>\u00a0create_model_adapter </li> <li> <code></code>\u00a0model_adapters <code></code>\u00a0create_model_adapter </li> </ul> </li> </ul> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\n@classmethod\ndef create(\n    cls,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    *,\n    devices: Optional[Sequence[str]] = None,\n    weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None,\n):\n    \"\"\"\n    Creates model adapter based on the passed spec\n    Note: All specific adapters should happen inside this function to prevent different framework\n    initializations interfering with each other\n    \"\"\"\n    if not isinstance(model_description, (v0_4.ModelDescr, v0_5.ModelDescr)):\n        raise TypeError(\n            f\"expected v0_4.ModelDescr or v0_5.ModelDescr, but got {type(model_description)}\"\n        )\n\n    weights = model_description.weights\n    errors: List[Exception] = []\n    weight_format_priority_order = (\n        DEFAULT_WEIGHT_FORMAT_PRIORITY_ORDER\n        if weight_format_priority_order is None\n        else weight_format_priority_order\n    )\n    # limit weight formats to the ones present\n    weight_format_priority_order_present: Sequence[SupportedWeightsFormat] = [\n        w for w in weight_format_priority_order if getattr(weights, w) is not None\n    ]\n    if not weight_format_priority_order_present:\n        raise ValueError(\n            f\"None of the specified weight formats ({weight_format_priority_order}) is present ({weight_format_priority_order_present})\"\n        )\n\n    for wf in weight_format_priority_order_present:\n        if wf == \"pytorch_state_dict\":\n            assert weights.pytorch_state_dict is not None\n            try:\n                from .pytorch_backend import PytorchModelAdapter\n\n                return PytorchModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"tensorflow_saved_model_bundle\":\n            assert weights.tensorflow_saved_model_bundle is not None\n            try:\n                from .tensorflow_backend import create_tf_model_adapter\n\n                return create_tf_model_adapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"onnx\":\n            assert weights.onnx is not None\n            try:\n                from .onnx_backend import ONNXModelAdapter\n\n                return ONNXModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"torchscript\":\n            assert weights.torchscript is not None\n            try:\n                from .torchscript_backend import TorchscriptModelAdapter\n\n                return TorchscriptModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"keras_hdf5\":\n            assert weights.keras_hdf5 is not None\n            # keras can either be installed as a separate package or used as part of tensorflow\n            # we try to first import the keras model adapter using the separate package and,\n            # if it is not available, try to load the one using tf\n            try:\n                try:\n                    from .keras_backend import KerasModelAdapter\n                except Exception:\n                    from .tensorflow_backend import KerasModelAdapter\n\n                return KerasModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        else:\n            assert_never(wf)\n\n    assert errors\n    if len(weight_format_priority_order) == 1:\n        assert len(errors) == 1\n        raise errors[0]\n\n    else:\n        msg = (\n            \"None of the weight format specific model adapters could be created\"\n            + \" in this environment.\"\n        )\n        raise ExceptionGroup(msg, errors)\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter.forward","title":"forward","text":"<pre><code>forward(input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]) -&gt; Sample\n</code></pre> <p>Run forward pass of model to get model predictions</p> <p>Note: sample id and stample stat attributes are passed through</p> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>def forward(\n    self, input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]\n) -&gt; Sample:\n    \"\"\"\n    Run forward pass of model to get model predictions\n\n    Note: sample id and stample stat attributes are passed through\n    \"\"\"\n    unexpected = [mid for mid in input_sample.members if mid not in self._input_ids]\n    if unexpected:\n        warnings.warn(f\"Got unexpected input tensor IDs: {unexpected}\")\n\n    input_arrays = [\n        (\n            None\n            if (a := input_sample.members.get(in_id)) is None\n            else a.transpose(in_order).data.data\n        )\n        for in_id, in_order in zip(self._input_ids, self._input_axes)\n    ]\n    output_arrays = self._forward_impl(input_arrays)\n    assert len(output_arrays) &lt;= len(self._output_ids)\n    output_tensors = [\n        None if a is None else Tensor(a, dims=d)\n        for a, d in zip(output_arrays, self._output_axes)\n    ]\n    return Sample(\n        members={\n            tid: out\n            for tid, out in zip(\n                self._output_ids,\n                output_tensors,\n            )\n            if out is not None\n        },\n        stat=input_sample.stat,\n        id=(\n            input_sample.id\n            if isinstance(input_sample, Sample)\n            else input_sample.sample_id\n        ),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter.load","title":"load","text":"<pre><code>load(*, devices: Optional[Sequence[str]] = None) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\ndef load(self, *, devices: Optional[Sequence[str]] = None) -&gt; None:\n    warnings.warn(\"Deprecated. ModelAdapter is loaded on initialization\")\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.TensorflowModelAdapter.unload","title":"unload","text":"<pre><code>unload() -&gt; None\n</code></pre> <p>Unload model from any devices, freeing their memory. The moder adapter should be considered unusable afterwards.</p> Source code in <code>src/bioimageio/core/backends/tensorflow_backend.py</code> <pre><code>def unload(self) -&gt; None:\n    logger.warning(\n        \"Device management is not implemented for tensorflow 1, cannot unload model\"\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/tensorflow_backend/#bioimageio.core.backends.tensorflow_backend.create_tf_model_adapter","title":"create_tf_model_adapter","text":"<pre><code>create_tf_model_adapter(model_description: AnyModelDescr, devices: Optional[Sequence[str]])\n</code></pre> Source code in <code>src/bioimageio/core/backends/tensorflow_backend.py</code> <pre><code>def create_tf_model_adapter(\n    model_description: AnyModelDescr, devices: Optional[Sequence[str]]\n):\n    tf_version = v0_5.Version(tf.__version__)\n    weights = model_description.weights.tensorflow_saved_model_bundle\n    if weights is None:\n        raise ValueError(\"No `tensorflow_saved_model_bundle` weights found\")\n\n    model_tf_version = weights.tensorflow_version\n    if model_tf_version is None:\n        logger.warning(\n            \"The model does not specify the tensorflow version.\"\n            + f\"Cannot check if it is compatible with intalled tensorflow {tf_version}.\"\n        )\n    elif model_tf_version &gt; tf_version:\n        logger.warning(\n            f\"The model specifies a newer tensorflow version than installed: {model_tf_version} &gt; {tf_version}.\"\n        )\n    elif (model_tf_version.major, model_tf_version.minor) != (\n        tf_version.major,\n        tf_version.minor,\n    ):\n        logger.warning(\n            \"The tensorflow version specified by the model does not match the installed: \"\n            + f\"{model_tf_version} != {tf_version}.\"\n        )\n\n    if tf_version.major &lt;= 1:\n        return TensorflowModelAdapter(\n            model_description=model_description, devices=devices\n        )\n    else:\n        return KerasModelAdapter(model_description=model_description, devices=devices)\n</code></pre>"},{"location":"api/bioimageio/core/backends/torchscript_backend/","title":"Torchscript backend","text":""},{"location":"api/bioimageio/core/backends/torchscript_backend/#bioimageio.core.backends.torchscript_backend","title":"torchscript_backend","text":"<p>Classes:</p> Name Description <code>TorchscriptModelAdapter</code>"},{"location":"api/bioimageio/core/backends/torchscript_backend/#bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter","title":"TorchscriptModelAdapter","text":"<pre><code>TorchscriptModelAdapter(*, model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], devices: Optional[Sequence[str]] = None)\n</code></pre> <p>               Bases: <code>ModelAdapter</code></p> <pre><code>\n              flowchart TD\n              bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter[TorchscriptModelAdapter]\n              bioimageio.core.backends._model_adapter.ModelAdapter[ModelAdapter]\n\n                              bioimageio.core.backends._model_adapter.ModelAdapter --&gt; bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter\n                \n\n\n              click bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter href \"\" \"bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter\"\n              click bioimageio.core.backends._model_adapter.ModelAdapter href \"\" \"bioimageio.core.backends._model_adapter.ModelAdapter\"\n            </code></pre> <p>Methods:</p> Name Description <code>create</code> <p>Creates model adapter based on the passed spec</p> <code>forward</code> <p>Run forward pass of model to get model predictions</p> <code>load</code> <code>unload</code> <p>Unload model from any devices, freeing their memory.</p> <p>Attributes:</p> Name Type Description <code>devices</code> Source code in <code>src/bioimageio/core/backends/torchscript_backend.py</code> <pre><code>def __init__(\n    self,\n    *,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    devices: Optional[Sequence[str]] = None,\n):\n    super().__init__(model_description=model_description)\n    if model_description.weights.torchscript is None:\n        raise ValueError(\n            f\"No torchscript weights found for model {model_description.name}\"\n        )\n\n    if devices is None:\n        self.devices = [\"cuda\" if torch.cuda.is_available() else \"cpu\"]\n    else:\n        self.devices = [torch.device(d) for d in devices]\n\n    if len(self.devices) &gt; 1:\n        warnings.warn(\n            \"Multiple devices for single torchscript model not yet implemented\"\n        )\n\n    weight_reader = model_description.weights.torchscript.get_reader()\n    self._model = torch.jit.load(weight_reader)\n\n    self._model.to(self.devices[0])\n    self._model = self._model.eval()\n</code></pre>"},{"location":"api/bioimageio/core/backends/torchscript_backend/#bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter.devices","title":"devices  <code>instance-attribute</code>","text":"<pre><code>devices = ['cuda' if torch.cuda.is_available() else 'cpu']\n</code></pre>"},{"location":"api/bioimageio/core/backends/torchscript_backend/#bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr], *, devices: Optional[Sequence[str]] = None, weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None)\n</code></pre> <p>Creates model adapter based on the passed spec Note: All specific adapters should happen inside this function to prevent different framework initializations interfering with each other</p> Used by: <ul> <li> API Reference <ul> <li> <code></code>\u00a0backends <code></code>\u00a0create_model_adapter </li> <li> <code></code>\u00a0model_adapters <code></code>\u00a0create_model_adapter </li> </ul> </li> </ul> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\n@classmethod\ndef create(\n    cls,\n    model_description: Union[v0_4.ModelDescr, v0_5.ModelDescr],\n    *,\n    devices: Optional[Sequence[str]] = None,\n    weight_format_priority_order: Optional[Sequence[SupportedWeightsFormat]] = None,\n):\n    \"\"\"\n    Creates model adapter based on the passed spec\n    Note: All specific adapters should happen inside this function to prevent different framework\n    initializations interfering with each other\n    \"\"\"\n    if not isinstance(model_description, (v0_4.ModelDescr, v0_5.ModelDescr)):\n        raise TypeError(\n            f\"expected v0_4.ModelDescr or v0_5.ModelDescr, but got {type(model_description)}\"\n        )\n\n    weights = model_description.weights\n    errors: List[Exception] = []\n    weight_format_priority_order = (\n        DEFAULT_WEIGHT_FORMAT_PRIORITY_ORDER\n        if weight_format_priority_order is None\n        else weight_format_priority_order\n    )\n    # limit weight formats to the ones present\n    weight_format_priority_order_present: Sequence[SupportedWeightsFormat] = [\n        w for w in weight_format_priority_order if getattr(weights, w) is not None\n    ]\n    if not weight_format_priority_order_present:\n        raise ValueError(\n            f\"None of the specified weight formats ({weight_format_priority_order}) is present ({weight_format_priority_order_present})\"\n        )\n\n    for wf in weight_format_priority_order_present:\n        if wf == \"pytorch_state_dict\":\n            assert weights.pytorch_state_dict is not None\n            try:\n                from .pytorch_backend import PytorchModelAdapter\n\n                return PytorchModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"tensorflow_saved_model_bundle\":\n            assert weights.tensorflow_saved_model_bundle is not None\n            try:\n                from .tensorflow_backend import create_tf_model_adapter\n\n                return create_tf_model_adapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"onnx\":\n            assert weights.onnx is not None\n            try:\n                from .onnx_backend import ONNXModelAdapter\n\n                return ONNXModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"torchscript\":\n            assert weights.torchscript is not None\n            try:\n                from .torchscript_backend import TorchscriptModelAdapter\n\n                return TorchscriptModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        elif wf == \"keras_hdf5\":\n            assert weights.keras_hdf5 is not None\n            # keras can either be installed as a separate package or used as part of tensorflow\n            # we try to first import the keras model adapter using the separate package and,\n            # if it is not available, try to load the one using tf\n            try:\n                try:\n                    from .keras_backend import KerasModelAdapter\n                except Exception:\n                    from .tensorflow_backend import KerasModelAdapter\n\n                return KerasModelAdapter(\n                    model_description=model_description, devices=devices\n                )\n            except Exception as e:\n                errors.append(e)\n        else:\n            assert_never(wf)\n\n    assert errors\n    if len(weight_format_priority_order) == 1:\n        assert len(errors) == 1\n        raise errors[0]\n\n    else:\n        msg = (\n            \"None of the weight format specific model adapters could be created\"\n            + \" in this environment.\"\n        )\n        raise ExceptionGroup(msg, errors)\n</code></pre>"},{"location":"api/bioimageio/core/backends/torchscript_backend/#bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter.forward","title":"forward","text":"<pre><code>forward(input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]) -&gt; Sample\n</code></pre> <p>Run forward pass of model to get model predictions</p> <p>Note: sample id and stample stat attributes are passed through</p> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>def forward(\n    self, input_sample: Union[Sample, SampleBlock, SampleBlockWithOrigin]\n) -&gt; Sample:\n    \"\"\"\n    Run forward pass of model to get model predictions\n\n    Note: sample id and stample stat attributes are passed through\n    \"\"\"\n    unexpected = [mid for mid in input_sample.members if mid not in self._input_ids]\n    if unexpected:\n        warnings.warn(f\"Got unexpected input tensor IDs: {unexpected}\")\n\n    input_arrays = [\n        (\n            None\n            if (a := input_sample.members.get(in_id)) is None\n            else a.transpose(in_order).data.data\n        )\n        for in_id, in_order in zip(self._input_ids, self._input_axes)\n    ]\n    output_arrays = self._forward_impl(input_arrays)\n    assert len(output_arrays) &lt;= len(self._output_ids)\n    output_tensors = [\n        None if a is None else Tensor(a, dims=d)\n        for a, d in zip(output_arrays, self._output_axes)\n    ]\n    return Sample(\n        members={\n            tid: out\n            for tid, out in zip(\n                self._output_ids,\n                output_tensors,\n            )\n            if out is not None\n        },\n        stat=input_sample.stat,\n        id=(\n            input_sample.id\n            if isinstance(input_sample, Sample)\n            else input_sample.sample_id\n        ),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/backends/torchscript_backend/#bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter.load","title":"load","text":"<pre><code>load(*, devices: Optional[Sequence[str]] = None) -&gt; None\n</code></pre> Source code in <code>src/bioimageio/core/backends/_model_adapter.py</code> <pre><code>@final\ndef load(self, *, devices: Optional[Sequence[str]] = None) -&gt; None:\n    warnings.warn(\"Deprecated. ModelAdapter is loaded on initialization\")\n</code></pre>"},{"location":"api/bioimageio/core/backends/torchscript_backend/#bioimageio.core.backends.torchscript_backend.TorchscriptModelAdapter.unload","title":"unload","text":"<pre><code>unload() -&gt; None\n</code></pre> <p>Unload model from any devices, freeing their memory. The moder adapter should be considered unusable afterwards.</p> Source code in <code>src/bioimageio/core/backends/torchscript_backend.py</code> <pre><code>def unload(self) -&gt; None:\n    self._devices = None\n    del self._model\n    _ = gc.collect()  # deallocate memory\n    torch.cuda.empty_cache()  # release reserved memory\n</code></pre>"},{"location":"api/bioimageio/core/utils/","title":"bioimageio.core.utils","text":""},{"location":"api/bioimageio/core/utils/#bioimageio.core.utils","title":"utils","text":"<p>Functions:</p> Name Description <code>compare</code>"},{"location":"api/bioimageio/core/utils/#bioimageio.core.utils.compare","title":"compare","text":"<pre><code>compare(a: Sequence[str], b: Sequence[str], name_a: str = 'source', name_b: str = 'updated', *, diff_format: Literal['unified', 'html'])\n</code></pre> Source code in <code>src/bioimageio/core/utils/_compare.py</code> <pre><code>def compare(\n    a: Sequence[str],\n    b: Sequence[str],\n    name_a: str = \"source\",\n    name_b: str = \"updated\",\n    *,\n    diff_format: Literal[\"unified\", \"html\"],\n):\n    if diff_format == \"html\":\n        diff = HtmlDiff().make_file(a, b, name_a, name_b, charset=\"utf-8\")\n    elif diff_format == \"unified\":\n        diff = \"\\n\".join(\n            unified_diff(\n                a,\n                b,\n                name_a,\n                name_b,\n                lineterm=\"\",\n            )\n        )\n    else:\n        assert_never(diff_format)\n\n    return diff\n</code></pre>"},{"location":"api/bioimageio/core/weight_converters/","title":"bioimageio.core.weight_converters","text":""},{"location":"api/bioimageio/core/weight_converters/#bioimageio.core.weight_converters","title":"weight_converters","text":"Used by: <ul> <li> API Reference \u00a0core \u00a0add_weights </li> </ul> <p>Modules:</p> Name Description <code>keras_to_tensorflow</code> <code>pytorch_to_onnx</code> <code>pytorch_to_torchscript</code> <code>torchscript_to_onnx</code> <p>Functions:</p> Name Description <code>add_weights</code> <p>Convert model weights to other formats and add them to the model description</p>"},{"location":"api/bioimageio/core/weight_converters/#bioimageio.core.weight_converters.add_weights","title":"add_weights","text":"<pre><code>add_weights(model_descr: ModelDescr, *, output_path: DirectoryPath, source_format: Optional[WeightsFormat] = None, target_format: Optional[WeightsFormat] = None, verbose: bool = False, allow_tracing: bool = True) -&gt; Union[ModelDescr, InvalidDescr]\n</code></pre> <p>Convert model weights to other formats and add them to the model description</p> <p>Parameters:</p> Name Type Description Default <code>DirectoryPath</code> <p>Path to save updated model package to.</p> required <code>Optional[WeightsFormat]</code> <p>convert from a specific weights format.            Default: choose automatically from any available.</p> <code>None</code> <code>Optional[WeightsFormat]</code> <p>convert to a specific weights format.            Default: attempt to convert to any missing format.</p> <code>None</code> <code>bool</code> <p>log more (error) output</p> <code>False</code> <code>bool</code> <p>allow conversion to torchscript by tracing if scripting fails.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[ModelDescr, InvalidDescr]</code> <p>A (potentially invalid) model copy stored at <code>output_path</code> with added weights if any conversion was possible.</p> Used by: <ul> <li> API Reference <code></code>\u00a0core <code></code>\u00a0add_weights </li> </ul> Source code in <code>src/bioimageio/core/weight_converters/_add_weights.py</code> <pre><code>def add_weights(\n    model_descr: ModelDescr,\n    *,\n    output_path: DirectoryPath,\n    source_format: Optional[WeightsFormat] = None,\n    target_format: Optional[WeightsFormat] = None,\n    verbose: bool = False,\n    allow_tracing: bool = True,\n) -&gt; Union[ModelDescr, InvalidDescr]:\n    \"\"\"Convert model weights to other formats and add them to the model description\n\n    Args:\n        output_path: Path to save updated model package to.\n        source_format: convert from a specific weights format.\n                       Default: choose automatically from any available.\n        target_format: convert to a specific weights format.\n                       Default: attempt to convert to any missing format.\n        verbose: log more (error) output\n        allow_tracing: allow conversion to torchscript by tracing if scripting fails.\n\n    Returns:\n        A (potentially invalid) model copy stored at `output_path` with added weights if any conversion was possible.\n\n    \"\"\"\n    if not isinstance(model_descr, ModelDescr):\n        if model_descr.type == \"model\" and not isinstance(model_descr, InvalidDescr):\n            raise TypeError(\n                f\"Model format {model_descr.format} is not supported, please update\"\n                + f\" model to format {ModelDescr.implemented_format_version} first.\"\n            )\n\n        raise TypeError(type(model_descr))\n\n    # save model to local folder\n    output_path = save_bioimageio_package_as_folder(\n        model_descr, output_path=output_path\n    )\n    # reload from local folder to make sure we do not edit the given model\n    model_descr = load_model_description(\n        output_path, perform_io_checks=False, format_version=\"latest\"\n    )\n\n    if source_format is None:\n        available = set(model_descr.weights.available_formats)\n    else:\n        available = {source_format}\n\n    if target_format is None:\n        missing = set(model_descr.weights.missing_formats)\n    else:\n        missing = {target_format}\n\n    originally_missing = set(missing)\n\n    if \"pytorch_state_dict\" in available and \"torchscript\" in missing:\n        logger.info(\n            \"Attempting to convert 'pytorch_state_dict' weights to 'torchscript'.\"\n        )\n        from .pytorch_to_torchscript import convert\n\n        try:\n            torchscript_weights_path = output_path / \"weights_torchscript.pt\"\n            model_descr.weights.torchscript = convert(\n                model_descr,\n                output_path=torchscript_weights_path,\n                use_tracing=False,\n            )\n        except Exception as e:\n            if verbose:\n                traceback.print_exception(type(e), e, e.__traceback__)\n\n            logger.error(e)\n        else:\n            available.add(\"torchscript\")\n            missing.discard(\"torchscript\")\n\n    if allow_tracing and \"pytorch_state_dict\" in available and \"torchscript\" in missing:\n        logger.info(\n            \"Attempting to convert 'pytorch_state_dict' weights to 'torchscript' by tracing.\"\n        )\n        from .pytorch_to_torchscript import convert\n\n        try:\n            torchscript_weights_path = output_path / \"weights_torchscript_traced.pt\"\n\n            model_descr.weights.torchscript = convert(\n                model_descr,\n                output_path=torchscript_weights_path,\n                use_tracing=True,\n            )\n        except Exception as e:\n            if verbose:\n                traceback.print_exception(type(e), e, e.__traceback__)\n\n            logger.error(e)\n        else:\n            available.add(\"torchscript\")\n            missing.discard(\"torchscript\")\n\n    if \"pytorch_state_dict\" in available and \"onnx\" in missing:\n        logger.info(\"Attempting to convert 'pytorch_state_dict' weights to 'onnx'.\")\n        from .pytorch_to_onnx import convert\n\n        try:\n            onnx_weights_path = output_path / \"weights.onnx\"\n\n            model_descr.weights.onnx = convert(\n                model_descr,\n                output_path=onnx_weights_path,\n                verbose=verbose,\n            )\n        except Exception as e:\n            if verbose:\n                traceback.print_exception(type(e), e, e.__traceback__)\n\n            logger.error(e)\n        else:\n            available.add(\"onnx\")\n            missing.discard(\"onnx\")\n\n    if \"torchscript\" in available and \"onnx\" in missing:\n        logger.info(\"Attempting to convert 'torchscript' weights to 'onnx'.\")\n        from .torchscript_to_onnx import convert\n\n        try:\n            onnx_weights_path = output_path / \"weights.onnx\"\n            model_descr.weights.onnx = convert(\n                model_descr,\n                output_path=onnx_weights_path,\n                verbose=verbose,\n            )\n        except Exception as e:\n            if verbose:\n                traceback.print_exception(type(e), e, e.__traceback__)\n\n            logger.error(e)\n        else:\n            available.add(\"onnx\")\n            missing.discard(\"onnx\")\n\n    if missing:\n        logger.warning(\n            f\"Converting from any of the available weights formats {available} to any\"\n            + f\" of {missing} failed or is not yet implemented. Please create an issue\"\n            + \" at https://github.com/bioimage-io/core-bioimage-io-python/issues/new/choose\"\n            + \" if you would like bioimageio.core to support a particular conversion.\"\n        )\n\n    if originally_missing == missing:\n        logger.warning(\"failed to add any converted weights\")\n        return model_descr\n    else:\n        logger.info(\"added weights formats {}\", originally_missing - missing)\n        # resave model with updated rdf.yaml\n        _ = save_bioimageio_package_as_folder(model_descr, output_path=output_path)\n        tested_model_descr = load_description_and_test(\n            model_descr, format_version=\"latest\", expected_type=\"model\"\n        )\n        if not isinstance(tested_model_descr, ModelDescr):\n            logger.error(\n                f\"The updated model description at {output_path} did not pass testing.\"\n            )\n\n        return tested_model_descr\n</code></pre>"},{"location":"api/bioimageio/core/weight_converters/#bioimageio.core.weight_converters.add_weights(output_path)","title":"<code>output_path</code>","text":""},{"location":"api/bioimageio/core/weight_converters/#bioimageio.core.weight_converters.add_weights(source_format)","title":"<code>source_format</code>","text":""},{"location":"api/bioimageio/core/weight_converters/#bioimageio.core.weight_converters.add_weights(target_format)","title":"<code>target_format</code>","text":""},{"location":"api/bioimageio/core/weight_converters/#bioimageio.core.weight_converters.add_weights(verbose)","title":"<code>verbose</code>","text":""},{"location":"api/bioimageio/core/weight_converters/#bioimageio.core.weight_converters.add_weights(allow_tracing)","title":"<code>allow_tracing</code>","text":""},{"location":"api/bioimageio/core/weight_converters/keras_to_tensorflow/","title":"Keras to tensorflow","text":""},{"location":"api/bioimageio/core/weight_converters/keras_to_tensorflow/#bioimageio.core.weight_converters.keras_to_tensorflow","title":"keras_to_tensorflow","text":"<p>Functions:</p> Name Description <code>convert</code> <p>Convert model weights from the 'keras_hdf5' format to the 'tensorflow_saved_model_bundle' format.</p>"},{"location":"api/bioimageio/core/weight_converters/keras_to_tensorflow/#bioimageio.core.weight_converters.keras_to_tensorflow.convert","title":"convert","text":"<pre><code>convert(model_descr: ModelDescr, output_path: Path) -&gt; TensorflowSavedModelBundleWeightsDescr\n</code></pre> <p>Convert model weights from the 'keras_hdf5' format to the 'tensorflow_saved_model_bundle' format.</p> <p>This method handles the conversion of Keras HDF5 model weights into a TensorFlow SavedModel bundle, which is the recommended format for deploying TensorFlow models. The method supports both TensorFlow 1.x and 2.x versions, with appropriate checks to ensure compatibility.</p> <p>Adapted from: https://github.com/deepimagej/pydeepimagej/blob/5aaf0e71f9b04df591d5ca596f0af633a7e024f5/pydeepimagej/yaml/create_config.py</p> <p>Parameters:</p> Name Type Description Default <code>ModelDescr</code> <p>The bioimage.io model description containing the model's metadata and weights.</p> required <code>Path</code> <p>Path with .zip suffix (.zip is appended otherwise) to which a zip archive with the TensorFlow SavedModel bundle will be saved.</p> required <p>Raises:     ValueError:         - If the specified <code>output_path</code> already exists.         - If the Keras HDF5 weights are missing in the model description.     RuntimeError:         If there is a mismatch between the TensorFlow version used by the model and the version installed.     NotImplementedError:         If the model has multiple inputs or outputs and TensorFlow 1.x is being used.</p> <p>Returns:</p> Type Description <code>TensorflowSavedModelBundleWeightsDescr</code> <p>A descriptor object containing information about the converted TensorFlow SavedModel bundle.</p> Source code in <code>src/bioimageio/core/weight_converters/keras_to_tensorflow.py</code> <pre><code>def convert(\n    model_descr: ModelDescr, output_path: Path\n) -&gt; TensorflowSavedModelBundleWeightsDescr:\n    \"\"\"\n    Convert model weights from the 'keras_hdf5' format to the 'tensorflow_saved_model_bundle' format.\n\n    This method handles the conversion of Keras HDF5 model weights into a TensorFlow SavedModel bundle,\n    which is the recommended format for deploying TensorFlow models. The method supports both TensorFlow 1.x\n    and 2.x versions, with appropriate checks to ensure compatibility.\n\n    Adapted from:\n    https://github.com/deepimagej/pydeepimagej/blob/5aaf0e71f9b04df591d5ca596f0af633a7e024f5/pydeepimagej/yaml/create_config.py\n\n    Args:\n        model_descr:\n            The bioimage.io model description containing the model's metadata and weights.\n        output_path:\n            Path with .zip suffix (.zip is appended otherwise) to which a zip archive\n            with the TensorFlow SavedModel bundle will be saved.\n    Raises:\n        ValueError:\n            - If the specified `output_path` already exists.\n            - If the Keras HDF5 weights are missing in the model description.\n        RuntimeError:\n            If there is a mismatch between the TensorFlow version used by the model and the version installed.\n        NotImplementedError:\n            If the model has multiple inputs or outputs and TensorFlow 1.x is being used.\n\n    Returns:\n        A descriptor object containing information about the converted TensorFlow SavedModel bundle.\n    \"\"\"\n    tf_major_ver = int(tensorflow.__version__.split(\".\")[0])\n\n    if output_path.suffix != \".zip\":\n        output_path = output_path.with_suffix(\"\")\n\n    if output_path.exists():\n        raise ValueError(f\"The ouptut directory at {output_path} must not exist.\")\n\n    if model_descr.weights.keras_hdf5 is None:\n        raise ValueError(\"Missing Keras Hdf5 weights to convert from.\")\n\n    weight_spec = model_descr.weights.keras_hdf5\n    weight_reader = weight_spec.get_reader()\n\n    if weight_spec.tensorflow_version:\n        model_tf_major_ver = int(weight_spec.tensorflow_version.major)\n        if model_tf_major_ver != tf_major_ver:\n            raise RuntimeError(\n                f\"Tensorflow major versions of model {model_tf_major_ver} is not {tf_major_ver}\"\n            )\n\n    td_kwargs: dict[str, Any] = (\n        dict(ignore_cleanup_errors=True) if sys.version_info &gt;= (3, 10) else {}\n    )\n    with TemporaryDirectory(**td_kwargs) as temp_dir:\n        local_weights = ensure_unzipped(\n            weight_reader, Path(temp_dir) / \"bioimageio_unzipped_tf_weights\"\n        )\n        if tf_major_ver == 1:\n            if len(model_descr.inputs) != 1 or len(model_descr.outputs) != 1:\n                raise NotImplementedError(\n                    \"Weight conversion for models with multiple inputs or outputs is not yet implemented.\"\n                )\n\n            input_name = str(\n                d.id\n                if isinstance((d := model_descr.inputs[0]), InputTensorDescr)\n                else d.name\n            )\n            output_name = str(\n                d.id\n                if isinstance((d := model_descr.outputs[0]), OutputTensorDescr)\n                else d.name\n            )\n            return _convert_tf1(\n                ensure_unzipped(local_weights, Path(\"bioimageio_unzipped_tf_weights\")),\n                output_path,\n                input_name,\n                output_name,\n            )\n        else:\n            return _convert_tf2(local_weights, output_path)\n</code></pre>"},{"location":"api/bioimageio/core/weight_converters/keras_to_tensorflow/#bioimageio.core.weight_converters.keras_to_tensorflow.convert(model_descr)","title":"<code>model_descr</code>","text":""},{"location":"api/bioimageio/core/weight_converters/keras_to_tensorflow/#bioimageio.core.weight_converters.keras_to_tensorflow.convert(output_path)","title":"<code>output_path</code>","text":""},{"location":"api/bioimageio/core/weight_converters/pytorch_to_onnx/","title":"Pytorch to onnx","text":""},{"location":"api/bioimageio/core/weight_converters/pytorch_to_onnx/#bioimageio.core.weight_converters.pytorch_to_onnx","title":"pytorch_to_onnx","text":"<p>Functions:</p> Name Description <code>convert</code> <p>Convert model weights from the Torchscript state_dict format to the ONNX format.</p>"},{"location":"api/bioimageio/core/weight_converters/pytorch_to_onnx/#bioimageio.core.weight_converters.pytorch_to_onnx.convert","title":"convert","text":"<pre><code>convert(model_descr: ModelDescr, output_path: Path, *, verbose: bool = False, opset_version: int = 18) -&gt; OnnxWeightsDescr\n</code></pre> <p>Convert model weights from the Torchscript state_dict format to the ONNX format.</p> <p>Parameters:</p> Name Type Description Default <code>ModelDescr</code> <p>The model description object that contains the model and its weights.</p> required <code>Path</code> <p>The file path where the ONNX model will be saved.</p> required <code>bool</code> <p>If True, will print out detailed information during the ONNX export process. Defaults to False.</p> <code>False</code> <code>int</code> <p>The ONNX opset version to use for the export. Defaults to 18.</p> <code>18</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided model does not have weights in the PyTorch state_dict format.</p> <p>Returns:</p> Type Description <code>OnnxWeightsDescr</code> <p>A description of the exported ONNX weights.</p> Source code in <code>src/bioimageio/core/weight_converters/pytorch_to_onnx.py</code> <pre><code>def convert(\n    model_descr: ModelDescr,\n    output_path: Path,\n    *,\n    verbose: bool = False,\n    opset_version: int = 18,\n) -&gt; OnnxWeightsDescr:\n    \"\"\"\n    Convert model weights from the Torchscript state_dict format to the ONNX format.\n\n    Args:\n        model_descr:\n            The model description object that contains the model and its weights.\n        output_path:\n            The file path where the ONNX model will be saved.\n        verbose:\n            If True, will print out detailed information during the ONNX export process. Defaults to False.\n        opset_version:\n            The ONNX opset version to use for the export. Defaults to 18.\n\n    Raises:\n        ValueError:\n            If the provided model does not have weights in the PyTorch state_dict format.\n\n    Returns:\n        A description of the exported ONNX weights.\n    \"\"\"\n\n    state_dict_weights_descr = model_descr.weights.pytorch_state_dict\n    if state_dict_weights_descr is None:\n        raise ValueError(\n            \"The provided model does not have weights in the pytorch state dict format\"\n        )\n\n    model = load_torch_model(state_dict_weights_descr, load_state=True)\n\n    return export_to_onnx(\n        model_descr,\n        model,\n        output_path,\n        verbose,\n        opset_version,\n        parent=\"pytorch_state_dict\",\n    )\n</code></pre>"},{"location":"api/bioimageio/core/weight_converters/pytorch_to_onnx/#bioimageio.core.weight_converters.pytorch_to_onnx.convert(model_descr)","title":"<code>model_descr</code>","text":""},{"location":"api/bioimageio/core/weight_converters/pytorch_to_onnx/#bioimageio.core.weight_converters.pytorch_to_onnx.convert(output_path)","title":"<code>output_path</code>","text":""},{"location":"api/bioimageio/core/weight_converters/pytorch_to_onnx/#bioimageio.core.weight_converters.pytorch_to_onnx.convert(verbose)","title":"<code>verbose</code>","text":""},{"location":"api/bioimageio/core/weight_converters/pytorch_to_onnx/#bioimageio.core.weight_converters.pytorch_to_onnx.convert(opset_version)","title":"<code>opset_version</code>","text":""},{"location":"api/bioimageio/core/weight_converters/pytorch_to_torchscript/","title":"Pytorch to torchscript","text":""},{"location":"api/bioimageio/core/weight_converters/pytorch_to_torchscript/#bioimageio.core.weight_converters.pytorch_to_torchscript","title":"pytorch_to_torchscript","text":"<p>Functions:</p> Name Description <code>convert</code> <p>Convert model weights from the PyTorch <code>state_dict</code> format to TorchScript.</p>"},{"location":"api/bioimageio/core/weight_converters/pytorch_to_torchscript/#bioimageio.core.weight_converters.pytorch_to_torchscript.convert","title":"convert","text":"<pre><code>convert(model_descr: ModelDescr, output_path: Path, *, use_tracing: bool = True) -&gt; TorchscriptWeightsDescr\n</code></pre> <p>Convert model weights from the PyTorch <code>state_dict</code> format to TorchScript.</p> <p>Parameters:</p> Name Type Description Default <code>ModelDescr</code> <p>The model description object that contains the model and its weights in the PyTorch <code>state_dict</code> format.</p> required <code>Path</code> <p>The file path where the TorchScript model will be saved.</p> required <code>bool</code> <p>Whether to use tracing or scripting to export the TorchScript format. - <code>True</code>: Use tracing, which is recommended for models with straightforward control flow. - <code>False</code>: Use scripting, which is better for models with dynamic control flow (e.g., loops, conditionals).</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided model does not have weights in the PyTorch <code>state_dict</code> format.</p> <p>Returns:</p> Type Description <code>TorchscriptWeightsDescr</code> <p>A descriptor object that contains information about the exported TorchScript weights.</p> Source code in <code>src/bioimageio/core/weight_converters/pytorch_to_torchscript.py</code> <pre><code>def convert(\n    model_descr: ModelDescr,\n    output_path: Path,\n    *,\n    use_tracing: bool = True,\n) -&gt; TorchscriptWeightsDescr:\n    \"\"\"\n    Convert model weights from the PyTorch `state_dict` format to TorchScript.\n\n    Args:\n        model_descr:\n            The model description object that contains the model and its weights in the PyTorch `state_dict` format.\n        output_path:\n            The file path where the TorchScript model will be saved.\n        use_tracing:\n            Whether to use tracing or scripting to export the TorchScript format.\n            - `True`: Use tracing, which is recommended for models with straightforward control flow.\n            - `False`: Use scripting, which is better for models with dynamic control flow (e.g., loops, conditionals).\n\n    Raises:\n        ValueError:\n            If the provided model does not have weights in the PyTorch `state_dict` format.\n\n    Returns:\n        A descriptor object that contains information about the exported TorchScript weights.\n    \"\"\"\n    state_dict_weights_descr = model_descr.weights.pytorch_state_dict\n    if state_dict_weights_descr is None:\n        raise ValueError(\n            \"The provided model does not have weights in the pytorch state dict format\"\n        )\n\n    input_data = model_descr.get_input_test_arrays()\n\n    with torch.no_grad():\n        input_data = [torch.from_numpy(inp) for inp in input_data]\n        model = load_torch_model(state_dict_weights_descr, load_state=True)\n        scripted_model: Union[  # pyright: ignore[reportUnknownVariableType]\n            ScriptModule, Tuple[Any, ...]\n        ] = (\n            torch.jit.trace(model, input_data)\n            if use_tracing\n            else torch.jit.script(model)\n        )\n        assert not isinstance(scripted_model, tuple), scripted_model\n\n    scripted_model.save(output_path)\n\n    return TorchscriptWeightsDescr(\n        source=output_path.absolute(),\n        pytorch_version=Version(torch.__version__),\n        parent=\"pytorch_state_dict\",\n        comment=(\n            f\"Converted with bioimageio.core {__version__}\"\n            + f\" with use_tracing={use_tracing}.\"\n        ),\n    )\n</code></pre>"},{"location":"api/bioimageio/core/weight_converters/pytorch_to_torchscript/#bioimageio.core.weight_converters.pytorch_to_torchscript.convert(model_descr)","title":"<code>model_descr</code>","text":""},{"location":"api/bioimageio/core/weight_converters/pytorch_to_torchscript/#bioimageio.core.weight_converters.pytorch_to_torchscript.convert(output_path)","title":"<code>output_path</code>","text":""},{"location":"api/bioimageio/core/weight_converters/pytorch_to_torchscript/#bioimageio.core.weight_converters.pytorch_to_torchscript.convert(use_tracing)","title":"<code>use_tracing</code>","text":""},{"location":"api/bioimageio/core/weight_converters/torchscript_to_onnx/","title":"Torchscript to onnx","text":""},{"location":"api/bioimageio/core/weight_converters/torchscript_to_onnx/#bioimageio.core.weight_converters.torchscript_to_onnx","title":"torchscript_to_onnx","text":"<p>Functions:</p> Name Description <code>convert</code> <p>Convert model weights from the PyTorch state_dict format to the ONNX format.</p>"},{"location":"api/bioimageio/core/weight_converters/torchscript_to_onnx/#bioimageio.core.weight_converters.torchscript_to_onnx.convert","title":"convert","text":"<pre><code>convert(model_descr: ModelDescr, output_path: Path, *, verbose: bool = False, opset_version: int = 18) -&gt; OnnxWeightsDescr\n</code></pre> <p>Convert model weights from the PyTorch state_dict format to the ONNX format.</p> <p>Parameters:</p> Name Type Description Default <code>Union[v0_4.ModelDescr, v0_5.ModelDescr]</code> <p>The model description object that contains the model and its weights.</p> required <code>Path</code> <p>The file path where the ONNX model will be saved.</p> required <code>bool</code> <p>If True, will print out detailed information during the ONNX export process. Defaults to False.</p> <code>False</code> <code>int</code> <p>The ONNX opset version to use for the export. Defaults to 18.</p> <code>18</code> <p>Raises:     ValueError:         If the provided model does not have weights in the torchscript format.</p> <p>Returns:</p> Type Description <code>OnnxWeightsDescr</code> <p>A description of the exported ONNX weights.</p> Source code in <code>src/bioimageio/core/weight_converters/torchscript_to_onnx.py</code> <pre><code>def convert(\n    model_descr: ModelDescr,\n    output_path: Path,\n    *,\n    verbose: bool = False,\n    opset_version: int = 18,\n) -&gt; OnnxWeightsDescr:\n    \"\"\"\n    Convert model weights from the PyTorch state_dict format to the ONNX format.\n\n    Args:\n        model_descr (Union[v0_4.ModelDescr, v0_5.ModelDescr]):\n            The model description object that contains the model and its weights.\n        output_path (Path):\n            The file path where the ONNX model will be saved.\n        verbose (bool, optional):\n            If True, will print out detailed information during the ONNX export process. Defaults to False.\n        opset_version (int, optional):\n            The ONNX opset version to use for the export. Defaults to 18.\n    Raises:\n        ValueError:\n            If the provided model does not have weights in the torchscript format.\n\n    Returns:\n        A description of the exported ONNX weights.\n    \"\"\"\n\n    torchscript_descr = model_descr.weights.torchscript\n    if torchscript_descr is None:\n        raise ValueError(\n            \"The provided model does not have weights in the torchscript format\"\n        )\n\n    weight_reader = torchscript_descr.get_reader()\n    model = torch.jit.load(weight_reader)  # pyright: ignore[reportUnknownVariableType]\n    model.to(\"cpu\")\n    model = model.eval()  # pyright: ignore[reportUnknownVariableType]\n\n    torch_sample_inputs = get_torch_sample_inputs(model_descr)\n    exported_program = TS2EPConverter(\n        model,  # pyright: ignore[reportUnknownArgumentType]\n        torch_sample_inputs,\n    ).convert()\n\n    return export_to_onnx(\n        model_descr,\n        exported_program.module(),\n        output_path,\n        verbose,\n        opset_version,\n        parent=\"torchscript\",\n    )\n</code></pre>"},{"location":"api/bioimageio/core/weight_converters/torchscript_to_onnx/#bioimageio.core.weight_converters.torchscript_to_onnx.convert(model_descr)","title":"<code>model_descr</code>","text":""},{"location":"api/bioimageio/core/weight_converters/torchscript_to_onnx/#bioimageio.core.weight_converters.torchscript_to_onnx.convert(output_path)","title":"<code>output_path</code>","text":""},{"location":"api/bioimageio/core/weight_converters/torchscript_to_onnx/#bioimageio.core.weight_converters.torchscript_to_onnx.convert(verbose)","title":"<code>verbose</code>","text":""},{"location":"api/bioimageio/core/weight_converters/torchscript_to_onnx/#bioimageio.core.weight_converters.torchscript_to_onnx.convert(opset_version)","title":"<code>opset_version</code>","text":""}]}